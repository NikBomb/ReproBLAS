#include <complex.h>
#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <math.h>
#include "../config.h"
#include "../Common/Common.h"
#include <immintrin.h>
#include <emmintrin.h>

/*[[[cog
import cog
import generate
import dataTypes
import asumI2
]]]*/
//[[[end]]]

void scasumI2(int n, float complex* v, int incv, int fold, float complex* sum){
  /*[[[cog
  cog.out(generate.generate(asumI2.ASumI2(dataTypes.FloatComplex), cog.inFile, args, params, mode))
  ]]]*/
  #ifdef __AVX__
    __m256 mask_ABS; AVX_ABS_MASKS(mask_ABS);
    __m256 mask_BLP; AVX_BLP_MASKS(mask_BLP);
    float complex tmp_cons[4] __attribute__((aligned(32)));
    SET_DAZ_FLAG;
    int i, j;

    float* sum_base = (float*) sum;
    float* v_base = (float*) v;
    __m256 v_0;
    __m256 q_0;
    __m256 s_0;
    __m256 s_buffer[MAX_FOLD];

    for(j = 0; j < fold; j += 1){
      s_buffer[j] = (__m256)_mm256_broadcast_sd((double *)(sum_base + (j * 2)));
    }
    if(incv == 1){

      for(i = 0; i + 4 <= n; i += 4, v_base += 8){
        v_0 = _mm256_and_ps(_mm256_loadu_ps(v_base), mask_ABS);
        for(j = 0; j < fold - 1; j++){
          s_0 = s_buffer[j];
          q_0 = _mm256_add_ps(s_0, _mm256_or_ps(v_0, mask_BLP));
          s_buffer[j] = q_0;
          q_0 = _mm256_sub_ps(s_0, q_0);
          v_0 = _mm256_add_ps(v_0, q_0);
        }
        s_buffer[j] = _mm256_add_ps(s_buffer[j], _mm256_or_ps(v_0, mask_BLP));
      }
      if(i < n){
        v_0 = _mm256_and_ps((__m256)_mm256_set_pd(0, (n - i)>2?((double*)v_base)[2]:0, (n - i)>1?((double*)v_base)[1]:0, ((double*)v_base)[0]), mask_ABS);
        for(j = 0; j < fold - 1; j++){
          s_0 = s_buffer[j];
          q_0 = _mm256_add_ps(s_0, _mm256_or_ps(v_0, mask_BLP));
          s_buffer[j] = q_0;
          q_0 = _mm256_sub_ps(s_0, q_0);
          v_0 = _mm256_add_ps(v_0, q_0);
        }
        s_buffer[j] = _mm256_add_ps(s_buffer[j], _mm256_or_ps(v_0, mask_BLP));
      }
    }else{

      for(i = 0; i + 4 <= n; i += 4, v_base += (incv * 8)){
        v_0 = _mm256_and_ps(_mm256_set_ps(v_base[((incv * 6) + 1)], v_base[(incv * 6)], v_base[((incv * 4) + 1)], v_base[(incv * 4)], v_base[((incv * 2) + 1)], v_base[(incv * 2)], v_base[1], v_base[0]), mask_ABS);
        for(j = 0; j < fold - 1; j++){
          s_0 = s_buffer[j];
          q_0 = _mm256_add_ps(s_0, _mm256_or_ps(v_0, mask_BLP));
          s_buffer[j] = q_0;
          q_0 = _mm256_sub_ps(s_0, q_0);
          v_0 = _mm256_add_ps(v_0, q_0);
        }
        s_buffer[j] = _mm256_add_ps(s_buffer[j], _mm256_or_ps(v_0, mask_BLP));
      }
      if(i < n){
        v_0 = _mm256_and_ps((__m256)_mm256_set_pd(0, (n - i)>2?((double*)v_base)[(incv * 2)]:0, (n - i)>1?((double*)v_base)[incv]:0, ((double*)v_base)[0]), mask_ABS);
        for(j = 0; j < fold - 1; j++){
          s_0 = s_buffer[j];
          q_0 = _mm256_add_ps(s_0, _mm256_or_ps(v_0, mask_BLP));
          s_buffer[j] = q_0;
          q_0 = _mm256_sub_ps(s_0, q_0);
          v_0 = _mm256_add_ps(v_0, q_0);
        }
        s_buffer[j] = _mm256_add_ps(s_buffer[j], _mm256_or_ps(v_0, mask_BLP));
      }
    }
    for(j = 0; j < fold; j += 1){
      s_buffer[j] = _mm256_sub_ps(s_buffer[j], _mm256_set_ps(sum_base[((j * 2) + 1)], sum_base[(j * 2)], sum_base[((j * 2) + 1)], sum_base[(j * 2)], sum_base[((j * 2) + 1)], sum_base[(j * 2)], 0, 0));
      _mm256_store_ps((float*)tmp_cons, s_buffer[j]);
      sum[j] = tmp_cons[0] + tmp_cons[1] + tmp_cons[2] + tmp_cons[3];
    }
  #elif defined(__SSE2__)
    __m128 mask_ABS; SSE_ABS_MASKS(mask_ABS);
    __m128 mask_BLP; SSE_BLP_MASKS(mask_BLP);
    float complex tmp_cons[2] __attribute__((aligned(16)));
    SET_DAZ_FLAG;
    int i, j;

    float* sum_base = (float*) sum;
    float* v_base = (float*) v;
    __m128 v_0;
    __m128 q_0;
    __m128 s_0;
    __m128 s_buffer[MAX_FOLD];

    for(j = 0; j < fold; j += 1){
      s_buffer[j] = (__m128)_mm_load1_pd((double *)(sum_base + (j * 2)));
    }
    if(incv == 1){

      for(i = 0; i + 2 <= n; i += 2, v_base += 4){
        v_0 = _mm_and_ps(_mm_loadu_ps(v_base), mask_ABS);
        for(j = 0; j < fold - 1; j++){
          s_0 = s_buffer[j];
          q_0 = _mm_add_ps(s_0, _mm_or_ps(v_0, mask_BLP));
          s_buffer[j] = q_0;
          q_0 = _mm_sub_ps(s_0, q_0);
          v_0 = _mm_add_ps(v_0, q_0);
        }
        s_buffer[j] = _mm_add_ps(s_buffer[j], _mm_or_ps(v_0, mask_BLP));
      }
      if(i < n){
        v_0 = _mm_and_ps(_mm_set_ps(0, 0, v_base[1], v_base[0]), mask_ABS);
        for(j = 0; j < fold - 1; j++){
          s_0 = s_buffer[j];
          q_0 = _mm_add_ps(s_0, _mm_or_ps(v_0, mask_BLP));
          s_buffer[j] = q_0;
          q_0 = _mm_sub_ps(s_0, q_0);
          v_0 = _mm_add_ps(v_0, q_0);
        }
        s_buffer[j] = _mm_add_ps(s_buffer[j], _mm_or_ps(v_0, mask_BLP));
      }
    }else{

      for(i = 0; i + 2 <= n; i += 2, v_base += (incv * 4)){
        v_0 = _mm_and_ps(_mm_set_ps(v_base[((incv * 2) + 1)], v_base[(incv * 2)], v_base[1], v_base[0]), mask_ABS);
        for(j = 0; j < fold - 1; j++){
          s_0 = s_buffer[j];
          q_0 = _mm_add_ps(s_0, _mm_or_ps(v_0, mask_BLP));
          s_buffer[j] = q_0;
          q_0 = _mm_sub_ps(s_0, q_0);
          v_0 = _mm_add_ps(v_0, q_0);
        }
        s_buffer[j] = _mm_add_ps(s_buffer[j], _mm_or_ps(v_0, mask_BLP));
      }
      if(i < n){
        v_0 = _mm_and_ps(_mm_set_ps(0, 0, v_base[1], v_base[0]), mask_ABS);
        for(j = 0; j < fold - 1; j++){
          s_0 = s_buffer[j];
          q_0 = _mm_add_ps(s_0, _mm_or_ps(v_0, mask_BLP));
          s_buffer[j] = q_0;
          q_0 = _mm_sub_ps(s_0, q_0);
          v_0 = _mm_add_ps(v_0, q_0);
        }
        s_buffer[j] = _mm_add_ps(s_buffer[j], _mm_or_ps(v_0, mask_BLP));
      }
    }
    for(j = 0; j < fold; j += 1){
      s_buffer[j] = _mm_sub_ps(s_buffer[j], _mm_set_ps(sum_base[((j * 2) + 1)], sum_base[(j * 2)], 0, 0));
      _mm_store_ps((float*)tmp_cons, s_buffer[j]);
      sum[j] = tmp_cons[0] + tmp_cons[1];
    }
  #else
    int_float tmp_BLP;
    SET_DAZ_FLAG;
    switch(fold){
      case 3:{
        int i;

        float* sum_base = (float*) sum;
        float* v_base = (float*) v;
        float v_0, v_1;
        float q_0, q_1;
        float s_0_0, s_0_1;
        float s_1_0, s_1_1;
        float s_2_0, s_2_1;

        s_0_0 = sum_base[0];
        s_0_1 = sum_base[1];
        s_1_0 = sum_base[2];
        s_1_1 = sum_base[3];
        s_2_0 = sum_base[4];
        s_2_1 = sum_base[5];
        if(incv == 1){

          for(i = 0; i + 1 <= n; i += 1, v_base += 2){
            v_0 = fabs(v_base[0]);
            v_1 = fabs(v_base[1]);
            q_0 = s_0_0;
            q_1 = s_0_1;
            tmp_BLP.f = v_0;
            tmp_BLP.i |= 1;
            s_0_0 = s_0_0 + tmp_BLP.f;
            tmp_BLP.f = v_1;
            tmp_BLP.i |= 1;
            s_0_1 = s_0_1 + tmp_BLP.f;
            q_0 = q_0 - s_0_0;
            q_1 = q_1 - s_0_1;
            v_0 = v_0 + q_0;
            v_1 = v_1 + q_1;
            q_0 = s_1_0;
            q_1 = s_1_1;
            tmp_BLP.f = v_0;
            tmp_BLP.i |= 1;
            s_1_0 = s_1_0 + tmp_BLP.f;
            tmp_BLP.f = v_1;
            tmp_BLP.i |= 1;
            s_1_1 = s_1_1 + tmp_BLP.f;
            q_0 = q_0 - s_1_0;
            q_1 = q_1 - s_1_1;
            v_0 = v_0 + q_0;
            v_1 = v_1 + q_1;
            tmp_BLP.f = v_0;
            tmp_BLP.i |= 1;
            s_2_0 = s_2_0 + tmp_BLP.f;
            tmp_BLP.f = v_1;
            tmp_BLP.i |= 1;
            s_2_1 = s_2_1 + tmp_BLP.f;
          }
        }else{

          for(i = 0; i + 1 <= n; i += 1, v_base += (incv * 2)){
            v_0 = fabs(v_base[0]);
            v_1 = fabs(v_base[1]);
            q_0 = s_0_0;
            q_1 = s_0_1;
            tmp_BLP.f = v_0;
            tmp_BLP.i |= 1;
            s_0_0 = s_0_0 + tmp_BLP.f;
            tmp_BLP.f = v_1;
            tmp_BLP.i |= 1;
            s_0_1 = s_0_1 + tmp_BLP.f;
            q_0 = q_0 - s_0_0;
            q_1 = q_1 - s_0_1;
            v_0 = v_0 + q_0;
            v_1 = v_1 + q_1;
            q_0 = s_1_0;
            q_1 = s_1_1;
            tmp_BLP.f = v_0;
            tmp_BLP.i |= 1;
            s_1_0 = s_1_0 + tmp_BLP.f;
            tmp_BLP.f = v_1;
            tmp_BLP.i |= 1;
            s_1_1 = s_1_1 + tmp_BLP.f;
            q_0 = q_0 - s_1_0;
            q_1 = q_1 - s_1_1;
            v_0 = v_0 + q_0;
            v_1 = v_1 + q_1;
            tmp_BLP.f = v_0;
            tmp_BLP.i |= 1;
            s_2_0 = s_2_0 + tmp_BLP.f;
            tmp_BLP.f = v_1;
            tmp_BLP.i |= 1;
            s_2_1 = s_2_1 + tmp_BLP.f;
          }
        }
        ((float*)sum)[0] = s_0_0;
        ((float*)sum)[1] = s_0_1;
        ((float*)sum)[2] = s_1_0;
        ((float*)sum)[3] = s_1_1;
        ((float*)sum)[4] = s_2_0;
        ((float*)sum)[5] = s_2_1;
        RESET_DAZ_FLAG
        return;
      }
      default:{
        int i, j;

        float* sum_base = (float*) sum;
        float* v_base = (float*) v;
        float v_0, v_1;
        float q_0, q_1;
        float s_0, s_1;
        float s_buffer[(MAX_FOLD * 2)];

        for(j = 0; j < fold; j += 1){
          s_buffer[(j * 2)] = sum_base[(j * 2)];
          s_buffer[((j * 2) + 1)] = sum_base[((j * 2) + 1)];
        }
        if(incv == 1){

          for(i = 0; i + 1 <= n; i += 1, v_base += 2){
            v_0 = fabs(v_base[0]);
            v_1 = fabs(v_base[1]);
            for(j = 0; j < fold - 1; j++){
              s_0 = s_buffer[(j * 2)];
              s_1 = s_buffer[((j * 2) + 1)];
              tmp_BLP.f = v_0;
              tmp_BLP.i |= 1;
              q_0 = s_0 + tmp_BLP.f;
              tmp_BLP.f = v_1;
              tmp_BLP.i |= 1;
              q_1 = s_1 + tmp_BLP.f;
              s_buffer[(j * 2)] = q_0;
              s_buffer[((j * 2) + 1)] = q_1;
              q_0 = s_0 - q_0;
              q_1 = s_1 - q_1;
              v_0 = v_0 + q_0;
              v_1 = v_1 + q_1;
            }
            tmp_BLP.f = v_0;
            tmp_BLP.i |= 1;
            s_buffer[(j * 2)] = s_buffer[(j * 2)] + tmp_BLP.f;
            tmp_BLP.f = v_1;
            tmp_BLP.i |= 1;
            s_buffer[((j * 2) + 1)] = s_buffer[((j * 2) + 1)] + tmp_BLP.f;
          }
        }else{

          for(i = 0; i + 1 <= n; i += 1, v_base += (incv * 2)){
            v_0 = fabs(v_base[0]);
            v_1 = fabs(v_base[1]);
            for(j = 0; j < fold - 1; j++){
              s_0 = s_buffer[(j * 2)];
              s_1 = s_buffer[((j * 2) + 1)];
              tmp_BLP.f = v_0;
              tmp_BLP.i |= 1;
              q_0 = s_0 + tmp_BLP.f;
              tmp_BLP.f = v_1;
              tmp_BLP.i |= 1;
              q_1 = s_1 + tmp_BLP.f;
              s_buffer[(j * 2)] = q_0;
              s_buffer[((j * 2) + 1)] = q_1;
              q_0 = s_0 - q_0;
              q_1 = s_1 - q_1;
              v_0 = v_0 + q_0;
              v_1 = v_1 + q_1;
            }
            tmp_BLP.f = v_0;
            tmp_BLP.i |= 1;
            s_buffer[(j * 2)] = s_buffer[(j * 2)] + tmp_BLP.f;
            tmp_BLP.f = v_1;
            tmp_BLP.i |= 1;
            s_buffer[((j * 2) + 1)] = s_buffer[((j * 2) + 1)] + tmp_BLP.f;
          }
        }
        for(j = 0; j < fold; j += 1){
          ((float*)sum)[(j * 2)] = s_buffer[(j * 2)];
          ((float*)sum)[((j * 2) + 1)] = s_buffer[((j * 2) + 1)];
        }
        RESET_DAZ_FLAG
        return;
      }
    }
  #endif
  //[[[end]]]
}
