#include <stdlib.h>

#include <indexedBLAS.h>
#include <idxd.h>

#include "../common/common.h"

/*[[[cog
import cog
import generate
import dataTypes
from src.common import blockSize
from scripts import terminal

cog.out(generate.generate(blockSize.BlockSize("zmzgemv", "Y_BLOCK", 1, 128, 128, ["bench_rzgemv_fold_{}".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))
cog.out(generate.generate(blockSize.BlockSize("zmzgemv", "X_BLOCK", 1, 4 * terminal.get_diendurance(), 4 * terminal.get_diendurance(), ["bench_rzgemv_fold_{}".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))

cog.out(generate.generate(blockSize.BlockSize("zmzgemv", "YT_BLOCK", 1, 128, 128, ["bench_rzgemv_fold_{}_trans".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))
cog.out(generate.generate(blockSize.BlockSize("zmzgemv", "XT_BLOCK", 1, 4 * terminal.get_diendurance(), 4 * terminal.get_diendurance(), ["bench_rzgemv_fold_{}_trans".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))
cog.out(generate.generate(blockSize.BlockSize("zmzgemv", "T_BLOCK", 1, 32, 32, ["bench_rzgemv_fold_{}_trans".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))
]]]*/
#define Y_BLOCK 128
#define X_BLOCK 8192
#define YT_BLOCK 128
#define XT_BLOCK 8192
#define T_BLOCK 32
//[[[end]]]

void idxdBLAS_zmzgemv(const int fold, const char Order,
             const char TransA, const int M, const int N,
             const void *alpha, const void *A, const int lda,
             const void *X, const int incX,
             double *priY, const int incpriY, const int incincpriY,
             double *carY, const int inccarY, const int incinccarY){
  int i;
  int ii;
  int iii;
  int j;
  int jj;
  int jjj;
  double *alphaX;
  int incalphaX;
  double *bufA;
  switch(Order){
    case 'r':
    case 'R':
      switch(TransA){
        case 'n':
        case 'N':
          if(((double*)alpha)[0] == 1.0 && ((double*)alpha)[1] == 0.0){
            alphaX = (double*)X;
            incalphaX = incX;
          }else{
            alphaX = (double*)malloc(N * 2 * sizeof(double));
            for(j = 0; j < N; j++){
              alphaX[2 * j] = ((double*)X)[2 * j * incX] * ((double*)alpha)[0] - ((double*)X)[2 * j * incX + 1] * ((double*)alpha)[1];
              alphaX[2 * j + 1] = ((double*)X)[2 * j * incX] * ((double*)alpha)[1] + ((double*)X)[2 * j * incX + 1] * ((double*)alpha)[0];
            }
            incalphaX = 1;
          }
          for(i = 0; i < M; i += Y_BLOCK){
            for(j = 0; j < N; j += X_BLOCK){
              for(ii = i; ii < M && ii < i + Y_BLOCK; ii++){
                idxdBLAS_zmzdotu(fold, MIN(X_BLOCK, N - j), (double*)A + 2 * (ii * lda + j), 1, alphaX + 2 * j * incalphaX, incalphaX, priY + 2 * ii * incpriY * incincpriY * fold, incpriY, carY + 2 * ii * inccarY * incinccarY * fold, inccarY);
              }
            }
          }
          if(((double*)alpha)[0] != 1.0 || ((double*)alpha)[1] != 0.0){
            free(alphaX);
          }
          break;
        case 't':
        case 'T':
          if(((double*)alpha)[0] == 1.0 && ((double*)alpha)[1] == 0.0){
            alphaX = (double*)X;
            incalphaX = incX;
          }else{
            alphaX = (double*)malloc(M * 2 * sizeof(double));
            for(j = 0; j < M; j++){
              alphaX[2 * j] = ((double*)X)[2 * j * incX] * ((double*)alpha)[0] - ((double*)X)[2 * j * incX + 1] * ((double*)alpha)[1];
              alphaX[2 * j + 1] = ((double*)X)[2 * j * incX] * ((double*)alpha)[1] + ((double*)X)[2 * j * incX + 1] * ((double*)alpha)[0];
            }
            incalphaX = 1;
          }
          bufA = (double*)malloc(2 * XT_BLOCK * YT_BLOCK * sizeof(double));
          for(i = 0; i < N; i += YT_BLOCK){
            for(j = 0; j < M; j += XT_BLOCK){
              for(jj = j; jj < M && jj < j + XT_BLOCK; jj += T_BLOCK){
                for(ii = i; ii < N && ii < i + YT_BLOCK; ii+= T_BLOCK){
                  for(jjj = jj; jjj < M && jjj < jj + MIN(T_BLOCK, XT_BLOCK); jjj++){
                    for(iii = ii; iii < N && iii < ii + MIN(T_BLOCK, YT_BLOCK); iii++){
                      bufA[2 * ((iii - i) * XT_BLOCK + (jjj - j))] = ((double*)A)[2 * (jjj * lda + iii)];
                      bufA[2 * ((iii - i) * XT_BLOCK + (jjj - j)) + 1] = ((double*)A)[2 * (jjj * lda + iii) + 1];
                    }
                  }
                }
              }
              for(ii = i; ii < N && ii < i + YT_BLOCK; ii++){
                idxdBLAS_zmzdotu(fold, MIN(XT_BLOCK, M - j), bufA + 2 * (ii - i) * XT_BLOCK, 1, alphaX + 2 * j * incalphaX, incalphaX, priY + 2 * ii * incpriY * incincpriY * fold, incpriY, carY + 2 * ii * inccarY * incinccarY * fold, inccarY);
              }
            }
          }
          free(bufA);
          if(((double*)alpha)[0] != 1.0 || ((double*)alpha)[1] != 0.0){
            free(alphaX);
          }
          break;
        default:
          if(((double*)alpha)[0] == 1.0 && ((double*)alpha)[1] == 0.0){
            alphaX = (double*)X;
            incalphaX = incX;
          }else{
            alphaX = (double*)malloc(M * 2 * sizeof(double));
            for(j = 0; j < M; j++){
              alphaX[2 * j] = ((double*)X)[2 * j * incX] * ((double*)alpha)[0] - ((double*)X)[2 * j * incX + 1] * ((double*)alpha)[1];
              alphaX[2 * j + 1] = ((double*)X)[2 * j * incX] * ((double*)alpha)[1] + ((double*)X)[2 * j * incX + 1] * ((double*)alpha)[0];
            }
            incalphaX = 1;
          }
          bufA = (double*)malloc(2 * XT_BLOCK * YT_BLOCK * sizeof(double));
          for(i = 0; i < N; i += YT_BLOCK){
            for(j = 0; j < M; j += XT_BLOCK){
              for(jj = j; jj < M && jj < j + XT_BLOCK; jj += T_BLOCK){
                for(ii = i; ii < N && ii < i + YT_BLOCK; ii+= T_BLOCK){
                  for(jjj = jj; jjj < M && jjj < jj + MIN(T_BLOCK, XT_BLOCK); jjj++){
                    for(iii = ii; iii < N && iii < ii + MIN(T_BLOCK, YT_BLOCK); iii++){
                      bufA[2 * ((iii - i) * XT_BLOCK + (jjj - j))] = ((double*)A)[2 * (jjj * lda + iii)];
                      bufA[2 * ((iii - i) * XT_BLOCK + (jjj - j)) + 1] = ((double*)A)[2 * (jjj * lda + iii) + 1];
                    }
                  }
                }
              }
              for(ii = i; ii < N && ii < i + YT_BLOCK; ii++){
                idxdBLAS_zmzdotc(fold, MIN(XT_BLOCK, M - j), bufA + 2 * (ii - i) * XT_BLOCK, 1, alphaX + 2 * j * incalphaX, incalphaX, priY + 2 * ii * incpriY * incincpriY * fold, incpriY, carY + 2 * ii * inccarY * incinccarY * fold, inccarY);
              }
            }
          }
          free(bufA);
          if(((double*)alpha)[0] != 1.0 || ((double*)alpha)[1] != 0.0){
            free(alphaX);
          }
          break;
      }
      break;
    default:
      switch(TransA){
        case 'n':
        case 'N':
          idxdBLAS_zmzgemv(fold, 'r', 't', N, M, alpha, A, lda, X, incX, priY, incpriY, incincpriY, carY, inccarY, incinccarY);
          break;
        case 't':
        case 'T':
          idxdBLAS_zmzgemv(fold, 'r', 'n', N, M, alpha, A, lda, X, incX, priY, incpriY, incincpriY, carY, inccarY, incinccarY);
          break;
        default:
          if(((double*)alpha)[0] == 1.0 && ((double*)alpha)[1] == 0.0){
            alphaX = (double*)X;
            incalphaX = incX;
          }else{
            alphaX = (double*)malloc(M * 2 * sizeof(double));
            for(j = 0; j < M; j++){
              alphaX[2 * j] = ((double*)X)[2 * j * incX] * ((double*)alpha)[0] - ((double*)X)[2 * j * incX + 1] * ((double*)alpha)[1];
              alphaX[2 * j + 1] = ((double*)X)[2 * j * incX] * ((double*)alpha)[1] + ((double*)X)[2 * j * incX + 1] * ((double*)alpha)[0];
            }
            incalphaX = 1;
          }
          for(i = 0; i < N; i += Y_BLOCK){
            for(j = 0; j < M; j += X_BLOCK){
              for(ii = i; ii < N && ii < i + Y_BLOCK; ii++){
                idxdBLAS_zmzdotc(fold, MIN(X_BLOCK, M - j), (double*)A + 2 * (ii * lda + j), 1, alphaX + 2 * j * incalphaX, incalphaX, priY + 2 * ii * incpriY * incincpriY * fold, incpriY, carY + 2 * ii * inccarY * incinccarY * fold, inccarY);
              }
            }
          }
          if(((double*)alpha)[0] != 1.0 || ((double*)alpha)[1] != 0.0){
            free(alphaX);
          }
          break;
      }
      break;
  }
}
