/*
 *  Created   13/10/25   H.D. Nguyen
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>

#include "../config.h"
#include "../common/common.h"
#include "indexedBLAS.h"

/*[[[cog
import cog
import generate
import dataTypes
import depositSum
import vectorizations
from src.common import blockSize
from scripts import terminal

code_block = generate.CodeBlock()
vectorizations.conditionally_include_vectorizations(code_block)
cog.out(str(code_block))

cog.outl()

cog.out(generate.generate(blockSize.BlockSize("dmdsum", "N_block_MAX", 32, terminal.get_diendurance(), terminal.get_diendurance(), ["bench_rdsum_fold_{}".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))
]]]*/
//[[[end]]]

void dmdsum(const int fold, const int N, const double *X, const int incX, double *manY, const int incmanY, double *carY, const int inccarY){
  double amax;
  int i, j;
  int N_block = N_block_MAX;
  int deposits = 0;

  for (i = 0; i < N; i += N_block) {
    N_block = MIN((N - i), N_block);

    amax = damax(N_block, X, incX);

    if (isinf(amax) || isinf(manY[0])){
      for (j = 0; j < N_block; j++){
        manY[0] += X[j * incX];
      }
    }
    if (isnan(manY[0])){
      return;
    } else if (isinf(manY[0])){
      X += N_block * incX;
      continue;
    }

    if (deposits + N_block > DIENDURANCE) {
      dmrenorm(fold, manY, incmanY, carY, inccarY);
      deposits = 0;
    }

    dmdupdate(fold, amax, manY, incmanY, carY, inccarY);

    /*[[[cog
    cog.out(generate.generate(depositSum.DepositSum(dataTypes.Double, "fold", "N_block", "X", "incX", "manY", "incmanY"), cog.inFile, args, params, mode))
    ]]]*/
    //[[[end]]]

    deposits += N_block;
  }

  dmrenorm(fold, manY, incmanY, carY, inccarY);
}
