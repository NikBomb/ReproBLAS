/*
 *  Created   13/10/25   H.D. Nguyen
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>

#include "../config.h"
#include "../Common/Common.h"
#include "indexedBLAS.h"

/*[[[cog
import cog
import generate
import dataTypes
import depositSSq
import vectorizations

code_block = generate.CodeBlock()
vectorizations.conditionally_include_vectorizations(code_block)
cog.out(str(code_block))
]]]*/
//[[[end]]]

#define N_block_MAX 1024
//TODO make N_block_max a parameter
//TODO make sure to note in comments that we assume the indexed type has been renormalized before the call (probably already covered in the deposit documentation

double dmzssq(const int fold, const int N, const void *X, const int incX, const double scaleY, double *manY, const int incmanY, double *carY, const int inccarY){
  double amax_tmp[2];
  double amax;
  double scl = 0.0;
  double new_scl;
  int i, j;
  int N_block = MIN(N_block_MAX, dicapacity());
  int deposits = 0;
  double_complex_indexed *ssq = zialloc(fold);
  zisetzero(fold, ssq);

  const double *x = (const double*)X;

  for (i = 0; i < N; i += N_block) {
    N_block = MIN((N - i), N_block);

    zamax_sub(N_block, x, incX, amax_tmp);
    amax = MAX(amax_tmp[0], amax_tmp[1]);

    if (isinf(amax) || isinf(manY[0])){
      for (j = 0; j < N_block; j++){
        manY[0] += fabs(x[j * 2 * incX]);
        manY[0] += fabs(x[j * 2 * incX + 1]);
      }
    }
    if (isnan(manY[0]) || isnan(ssq[0]) || isnan(ssq[1])){
      manY[0] += ssq[0] + ssq[1];
      free(ssq);
      return dscale(1.0);
    } else if (isinf(manY[0])){
      x += N_block * 2 * incX;
      continue;
    }

    if (deposits + N_block > dicapacity()) {
      zirenorm(fold, ssq);
      deposits = 0;
    }

    new_scl = dscale(amax);
    if (new_scl > scl) {
      if(scl > 0.0){
        zmdrescale(fold, new_scl, scl, ssq, 1, ssq + 2 * fold, 1);
      }
      scl = new_scl;
    }

    new_scl = 1.0/scl;
    amax *= new_scl;
    amax = amax * amax;

    zidupdate(fold, amax, ssq);

    /*[[[cog
      cog.out(generate.generate(depositSSq.DepositSSq(dataTypes.DoubleComplex, "N_block", "x", "incX", "ssq", 1, "new_scl"), cog.inFile, args, params, mode))
      ]]]*/
    //[[[end]]]

    deposits += N_block;
  }

  zirenorm(fold, ssq);
  new_scl = dmdmaddsq(fold, scl, ssq, 2, ssq + 2 * fold, 2, scaleY, manY, incmanY, carY, inccarY);
  scl = dmdmaddsq(fold, scl, ssq + 1, 2, ssq + 2 * fold + 1, 2, new_scl, manY, incmanY, carY, inccarY);

  free(ssq);

  if (isinf(manY[0]) || isnan(manY[0])){
    return dscale(1.0);
  } else {
    return scl;
  }
}
