#include <stdlib.h>

#include <idxdBLAS.h>
#include <idxd.h>

#include "../common/common.h"

/*[[[cog
import cog
import generate
import dataTypes
from src.common import blockSize
from scripts import terminal

rounded_cache = 2**(int(terminal.get_cache()).bit_length() - 1)
xy_block = rounded_cache//dataTypes.Double.byte_size
y_block = max(xy_block//256, 1)

cog.out(generate.generate(blockSize.BlockSize("didgemm", "Y_BLOCK", 1, y_block, y_block, ["bench_rdgemm_AvgTransA_AvgTransB_fold_{}".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))
cog.out(generate.generate(blockSize.BlockSize("didgemm", "XY_BLOCK", y_block, xy_block, xy_block, ["bench_rdgemm_AvgTransA_AvgTransB_fold_{}".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))
cog.out(generate.generate(blockSize.BlockSize("didgemm", "YT_BLOCK", 1, y_block, y_block, ["bench_rdgemm_AvgTransA_AvgTransB_fold_{}".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))
cog.out(generate.generate(blockSize.BlockSize("didgemm", "XYT_BLOCK", y_block, xy_block, xy_block, ["bench_rdgemm_AvgTransA_AvgTransB_fold_{}".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))
]]]*/
#define Y_BLOCK 32
#define XY_BLOCK 32768
#define YT_BLOCK 32
#define XYT_BLOCK 32768
//[[[end]]]
#define X_BLOCK (XY_BLOCK/Y_BLOCK)
#define XT_BLOCK (XYT_BLOCK/YT_BLOCK)

void idxdBLAS_didgemm(const int fold, const char Order,
             const char TransA, const char TransB,
             const int M, const int N, const int K,
             const double alpha, const double *A, const int lda,
             const double *B, const int ldb,
             double_indexed *C, const int ldc){
  int i;
  int ii;
  int k;
  int kk;
  int j;
  int jj;
  double *bufA;
  int ldbufa;
  double *bufB;

  //early returns
  if(M == 0 || N == 0 || K == 0 || alpha == 0.0){
    return;
  }

  switch(Order){

    //row major
    case 'r':
    case 'R':
      switch(TransA){

        //row major A not transposed
        case 'n':
        case 'N':
          if(alpha == 1.0){
            bufA = (double*)A;
            ldbufa = lda;
          }else{
            bufA = (double*)malloc(M * K * sizeof(double));
            for(i = 0; i < M; i++){
              for(k = 0; k < K; k++){
                bufA[i * K + k] = A[i * lda + k] * alpha;
              }
            }
            ldbufa = K;
          }
          switch(TransB){

            //row major A not transposed B not transposed
            case 'n':
            case 'N':
              bufB = (double*)malloc(XT_BLOCK * YT_BLOCK * sizeof(double));
              for(i = 0; i < M; i += Y_BLOCK){
                for(j = 0; j < N; j += YT_BLOCK){
                  for(k = 0; k < K; k += XT_BLOCK){
                    for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                      for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                        bufB[(jj - j) * XT_BLOCK + (kk - k)] = B[kk * ldb + jj];
                      }
                    }
                    for(ii = i; ii < M && ii < i + Y_BLOCK; ii++){
                      for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                        idxdBLAS_diddot(fold, MIN(XT_BLOCK, K - k), bufA + ii * ldbufa + k, 1, bufB + (jj - j) * XT_BLOCK, 1, C + (ii * ldc + jj) * idxd_dinum(fold));
                      }
                    }
                  }
                }
              }
              free(bufB);
              break;

            //row major A not transposed B transposed
            default:
              for(i = 0; i < M; i += Y_BLOCK){
                for(j = 0; j < N; j += Y_BLOCK){
                  for(k = 0; k < K; k += X_BLOCK){
                    for(ii = i; ii < M && ii < i + Y_BLOCK; ii++){
                      for(jj = j; jj < N && jj < j + Y_BLOCK; jj++){
                        idxdBLAS_diddot(fold, MIN(X_BLOCK, K - k), bufA + ii * ldbufa + k, 1, B + jj * ldb + k, 1, C + (ii * ldc + jj) * idxd_dinum(fold));
                      }
                    }
                  }
                }
              }
              break;

          }
          if(alpha != 1.0){
            free(bufA);
          }
          break;

        //row major A transposed
        default:
          switch(TransB){

            //row major A transposed B not transposed
            case 'n':
            case 'N':
              bufA = (double*)malloc(XT_BLOCK * YT_BLOCK * sizeof(double));
              bufB = (double*)malloc(XT_BLOCK * YT_BLOCK * sizeof(double));
              if(alpha == 1.0){
                for(i = 0; i < M; i += YT_BLOCK){
                  for(j = 0; j < N; j += YT_BLOCK){
                    for(k = 0; k < K; k += XT_BLOCK){
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          bufA[(ii - i) * XT_BLOCK + (kk - k)] = A[kk * lda + ii];
                        }
                      }
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                          bufB[(jj - j) * XT_BLOCK + (kk - k)] = B[kk * ldb + jj];
                        }
                      }
                      for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                        for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                          idxdBLAS_diddot(fold, MIN(XT_BLOCK, K - k), bufA + (ii - i) * XT_BLOCK, 1, bufB + (jj - j) * XT_BLOCK, 1, C + (ii * ldc + jj) * idxd_dinum(fold));
                        }
                      }
                    }
                  }
                }
              }else{
                for(i = 0; i < M; i += YT_BLOCK){
                  for(j = 0; j < N; j += YT_BLOCK){
                    for(k = 0; k < K; k += XT_BLOCK){
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          bufA[(ii - i) * XT_BLOCK + (kk - k)] = A[kk * lda + ii] * alpha;
                        }
                      }
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                          bufB[(jj - j) * XT_BLOCK + (kk - k)] = B[kk * ldb + jj];
                        }
                      }
                      for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                        for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                          idxdBLAS_diddot(fold, MIN(XT_BLOCK, K - k), bufA + (ii - i) * XT_BLOCK, 1, bufB + (jj - j) * XT_BLOCK, 1, C + (ii * ldc + jj) * idxd_dinum(fold));
                        }
                      }
                    }
                  }
                }
              }
              free(bufA);
              free(bufB);
              break;

            //row major A transposed B transposed
            default:
              bufA = (double*)malloc(XT_BLOCK * YT_BLOCK * sizeof(double));
              if(alpha == 1.0){
                for(i = 0; i < M; i += YT_BLOCK){
                  for(j = 0; j < N; j += Y_BLOCK){
                    for(k = 0; k < K; k += XT_BLOCK){
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          bufA[(ii - i) * XT_BLOCK + (kk - k)] = A[kk * lda + ii];
                        }
                      }
                      for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                        for(jj = j; jj < N && jj < j + Y_BLOCK; jj++){
                          idxdBLAS_diddot(fold, MIN(XT_BLOCK, K - k), bufA + (ii - i) * XT_BLOCK, 1, B + jj * ldb + k, 1, C + (ii * ldc + jj) * idxd_dinum(fold));
                        }
                      }
                    }
                  }
                }
              }else{
                for(i = 0; i < M; i += YT_BLOCK){
                  for(j = 0; j < N; j += Y_BLOCK){
                    for(k = 0; k < K; k += XT_BLOCK){
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          bufA[(ii - i) * XT_BLOCK + (kk - k)] = A[kk * lda + ii] * alpha;
                        }
                      }
                      for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                        for(jj = j; jj < N && jj < j + Y_BLOCK; jj++){
                          idxdBLAS_diddot(fold, MIN(XT_BLOCK, K - k), bufA + (ii - i) * XT_BLOCK, 1, B + jj * ldb + k, 1, C + (ii * ldc + jj) * idxd_dinum(fold));
                        }
                      }
                    }
                  }
                }
              }
              free(bufA);
              break;
          }
          break;
      }
      break;

    //column major
    default:
      switch(TransA){

        //column major A not transposed
        case 'n':
        case 'N':
          switch(TransB){

            //column major A not transposed B not transposed
            case 'n':
            case 'N':
              bufA = (double*)malloc(XT_BLOCK * YT_BLOCK * sizeof(double));
              if(alpha == 1.0){
                for(i = 0; i < M; i += YT_BLOCK){
                  for(j = 0; j < N; j += Y_BLOCK){
                    for(k = 0; k < K; k += XT_BLOCK){
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          bufA[(ii - i) * XT_BLOCK + (kk - k)] = A[kk * lda + ii];
                        }
                      }
                      for(jj = j; jj < N && jj < j + Y_BLOCK; jj++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          idxdBLAS_diddot(fold, MIN(XT_BLOCK, K - k), bufA + (ii - i) * XT_BLOCK, 1, B + jj * ldb + k, 1, C + (jj * ldc + ii) * idxd_dinum(fold));
                        }
                      }
                    }
                  }
                }
              }else{
                for(i = 0; i < M; i += YT_BLOCK){
                  for(j = 0; j < N; j += Y_BLOCK){
                    for(k = 0; k < K; k += XT_BLOCK){
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          bufA[(ii - i) * XT_BLOCK + (kk - k)] = A[kk * lda + ii] * alpha;
                        }
                      }
                      for(jj = j; jj < N && jj < j + Y_BLOCK; jj++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          idxdBLAS_diddot(fold, MIN(XT_BLOCK, K - k), bufA + (ii - i) * XT_BLOCK, 1, B + jj * ldb + k, 1, C + (jj * ldc + ii) * idxd_dinum(fold));
                        }
                      }
                    }
                  }
                }
              }
              free(bufA);
              break;

            //column major A not transposed B transposed
            default:
              bufA = (double*)malloc(XT_BLOCK * YT_BLOCK * sizeof(double));
              bufB = (double*)malloc(XT_BLOCK * YT_BLOCK * sizeof(double));
              if(alpha == 1.0){
                for(i = 0; i < M; i += YT_BLOCK){
                  for(j = 0; j < N; j += YT_BLOCK){
                    for(k = 0; k < K; k += XT_BLOCK){
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          bufA[(ii - i) * XT_BLOCK + (kk - k)] = A[kk * lda + ii];
                        }
                      }
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                          bufB[(jj - j) * XT_BLOCK + (kk - k)] = B[kk * ldb + jj];
                        }
                      }
                      for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          idxdBLAS_diddot(fold, MIN(XT_BLOCK, K - k), bufA + (ii - i) * XT_BLOCK, 1, bufB + (jj - j) * XT_BLOCK, 1, C + (jj * ldc + ii) * idxd_dinum(fold));
                        }
                      }
                    }
                  }
                }
              }else{
                for(i = 0; i < M; i += YT_BLOCK){
                  for(j = 0; j < N; j += YT_BLOCK){
                    for(k = 0; k < K; k += XT_BLOCK){
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          bufA[(ii - i) * XT_BLOCK + (kk - k)] = A[kk * lda + ii] * alpha;
                        }
                      }
                      for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                        for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                          bufB[(jj - j) * XT_BLOCK + (kk - k)] = B[kk * ldb + jj];
                        }
                      }
                      for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                        for(ii = i; ii < M && ii < i + YT_BLOCK; ii++){
                          idxdBLAS_diddot(fold, MIN(XT_BLOCK, K - k), bufA + (ii - i) * XT_BLOCK, 1, bufB + (jj - j) * XT_BLOCK, 1, C + (jj * ldc + ii) * idxd_dinum(fold));
                        }
                      }
                    }
                  }
                }
              }
              free(bufA);
              free(bufB);
              break;
          }
          break;

        //column major A transposed
        default:
          if(alpha == 1.0){
            bufA = (double*)A;
            ldbufa = lda;
          }else{
            bufA = (double*)malloc(M * K * sizeof(double));
            for(i = 0; i < M; i++){
              for(k = 0; k < K; k++){
                bufA[i * K + k] = A[i * lda + k] * alpha;
              }
            }
            ldbufa = K;
          }
          switch(TransB){

            //column major A transposed B not transposed
            case 'n':
            case 'N':
              for(i = 0; i < M; i += Y_BLOCK){
                for(j = 0; j < N; j += Y_BLOCK){
                  for(k = 0; k < K; k += X_BLOCK){
                    for(jj = j; jj < N && jj < j + Y_BLOCK; jj++){
                      for(ii = i; ii < M && ii < i + Y_BLOCK; ii++){
                        idxdBLAS_diddot(fold, MIN(X_BLOCK, K - k), bufA + ii * ldbufa + k, 1, B + jj * ldb + k, 1, C + (jj * ldc + ii) * idxd_dinum(fold));
                      }
                    }
                  }
                }
              }
              break;

            //column major A transposed B transposed
            default:
              bufB = (double*)malloc(XT_BLOCK * YT_BLOCK * sizeof(double));
              for(i = 0; i < M; i += Y_BLOCK){
                for(j = 0; j < N; j += YT_BLOCK){
                  for(k = 0; k < K; k += XT_BLOCK){
                    for(kk = k; kk < K && kk < k + XT_BLOCK; kk++){
                      for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                        bufB[(jj - j) * XT_BLOCK + (kk - k)] = B[kk * ldb + jj];
                      }
                    }
                    for(jj = j; jj < N && jj < j + YT_BLOCK; jj++){
                      for(ii = i; ii < M && ii < i + Y_BLOCK; ii++){
                        idxdBLAS_diddot(fold, MIN(XT_BLOCK, K - k), bufA + ii * ldbufa + k, 1, bufB + (jj - j) * XT_BLOCK, 1, C + (jj * ldc + ii) * idxd_dinum(fold));
                      }
                    }
                  }
                }
              }
              free(bufB);
              break;
          }
          if(alpha != 1.0){
            free(bufA);
          }
          break;
      }
      break;
  }
}
