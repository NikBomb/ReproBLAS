/*
 *  Created   13/10/25   H.D. Nguyen
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>

#include "../config.h"
#include "../common/common.h"
#include "idxdBLAS.h"

/*[[[cog
import cog
import generate
import dataTypes
import depositDotC
import vectorizations
from src.common import blockSize
from scripts import terminal

code_block = generate.CodeBlock()
vectorizations.conditionally_include_vectorizations(code_block)
cog.out(str(code_block))

cog.outl()

cog.out(generate.generate(blockSize.BlockSize("cmcdotc", "N_block_MAX", 32, terminal.get_siendurance(), terminal.get_siendurance(), ["bench_rcdotc_fold_{}".format(terminal.get_sidefaultfold())]), cog.inFile, args, params, mode))
]]]*/
//[[[end]]]

void idxdBLAS_cmcdotc(const int fold, const int N, const void *X, const int incX, const void *Y, const int incY, float *manZ, const int incmanZ, float *carZ, const int inccarZ){
  float amaxm[2];
  int i, j;
  int N_block = N_block_MAX;
  int deposits = 0;

  const float *x = (const float*)X;
  const float *y = (const float*)Y;

  for (i = 0; i < N; i += N_block) {
    N_block = MIN((N - i), N_block);

    idxdBLAS_camaxm_sub(N_block, x, incX, y, incY, amaxm);

    if (isinf(amaxm[0]) || isinf(manZ[0])){
      for (j = 0; j < N_block; j++){
        manZ[0] += x[j * 2 * incX] * y[j * 2 * incY] + x[j * 2 * incX + 1] * y[j * 2 * incY + 1];
      }
    }
    if (isinf(amaxm[1]) || isinf(manZ[1])){
      for (j = 0; j < N_block; j++){
        manZ[1] += x[j * 2 * incX] * y[j * 2 * incY + 1] - x[j * 2 * incX + 1] * y[j * 2 * incY];
      }
    }
    if (isnan(manZ[0]) && isnan(manZ[1])){
      return;
    } else if (isinf(manZ[0]) && isinf(manZ[1])){
      x += N_block * 2 * incX;
      y += N_block * 2 * incY;
      continue;
    }
    if (ISNANINFF(manZ[0])){
      amaxm[0] = manZ[0];
    }
    if (ISNANINFF(manZ[1])){
      amaxm[1] = manZ[1];
    }

    if (deposits + N_block > idxd_SIENDURANCE/2) {
      idxd_cmrenorm(fold, manZ, incmanZ, carZ, inccarZ);
      deposits = 0;
    }

    idxd_cmcupdate(fold, amaxm, manZ, incmanZ, carZ, inccarZ);

    /*[[[cog
    cog.out(generate.generate(depositDotC.DepositDotC(dataTypes.FloatComplex, "fold", "N_block", "x", "incX", "manZ", "incmanZ", "y", "incY"), cog.inFile, args, params, mode))
    ]]]*/
    //[[[end]]]

    if (isinf(amaxm[0])){
      manZ[0] = amaxm[0];
    }
    if (isinf(amaxm[1])){
      manZ[1] = amaxm[1];
    }

    deposits += N_block;
  }

  idxd_cmrenorm(fold, manZ, incmanZ, carZ, inccarZ);
}
