/*
 *  Created   13/10/25   H.D. Nguyen
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>

#include "../config.h"
#include "../common/common.h"
#include "idxdBLAS.h"

/*[[[cog
import cog
import generate
import dataTypes
import depositSSq
import vectorizations
from src.common import blockSize
from scripts import terminal

code_block = generate.CodeBlock()
vectorizations.conditionally_include_vectorizations(code_block)
cog.out(str(code_block))

cog.outl()

cog.out(generate.generate(blockSize.BlockSize("dmzssq", "N_block_MAX", 32, terminal.get_diendurance()//2, terminal.get_diendurance()//2, ["bench_rdzasum_fold_{}".format(terminal.get_didefaultfold())]), cog.inFile, args, params, mode))
]]]*/
//[[[end]]]

double idxdBLAS_dmzssq(const int fold, const int N, const void *X, const int incX, const double scaleY, double *manY, const int incmanY, double *carY, const int inccarY){
  double amax_tmp[2];
  double amax;
  double scl = 0.0;
  double new_scl;
  int i, j;
  int N_block = N_block_MAX;
  int deposits = 0;
  double_complex_indexed *ssq = idxd_zialloc(fold);
  idxd_zisetzero(fold, ssq);

  const double *x = (const double*)X;

  for (i = 0; i < N; i += N_block) {
    N_block = MIN((N - i), N_block);

    idxdBLAS_zamax_sub(N_block, x, incX, amax_tmp);
    amax = MAX(amax_tmp[0], amax_tmp[1]);

    if (isinf(amax) || isinf(manY[0])){
      for (j = 0; j < N_block; j++){
        manY[0] += fabs(x[j * 2 * incX]);
        manY[0] += fabs(x[j * 2 * incX + 1]);
      }
    }
    if (isnan(manY[0]) || isnan(ssq[0]) || isnan(ssq[1])){
      manY[0] += ssq[0] + ssq[1];
      free(ssq);
      return idxd_dscale(1.0);
    } else if (isinf(manY[0])){
      x += N_block * 2 * incX;
      continue;
    }

    if (deposits + N_block > idxd_DIENDURANCE) {
      idxd_zirenorm(fold, ssq);
      deposits = 0;
    }

    new_scl = idxd_dscale(amax);
    if (new_scl > scl) {
      if(scl > 0.0){
        idxd_zmdrescale(fold, new_scl, scl, ssq, 1, ssq + 2 * fold, 1);
      }
      scl = new_scl;
    }

    amax /= scl;
    amax = amax * amax;

    idxd_zidupdate(fold, amax, ssq);

    /*[[[cog
      cog.out(generate.generate(depositSSq.DepositSSq(dataTypes.DoubleComplex, "fold", "N_block", "x", "incX", "ssq", 1, "scl"), cog.inFile, args, params, mode))
      ]]]*/
    //[[[end]]]

    deposits += N_block;
  }

  idxd_zirenorm(fold, ssq);
  new_scl = idxd_dmdmaddsq(fold, scl, ssq, 2, ssq + 2 * fold, 2, scaleY, manY, incmanY, carY, inccarY);
  scl = idxd_dmdmaddsq(fold, scl, ssq + 1, 2, ssq + 2 * fold + 1, 2, new_scl, manY, incmanY, carY, inccarY);

  free(ssq);

  if (ISNANINF(manY[0])){
    return idxd_dscale(1.0);
  } else {
    return scl;
  }
}
