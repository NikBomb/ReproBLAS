\subsection{Add Float To Indexed}
  \label{sec:primitiveops_addfloattoindexed}
  Algorithm~\ref{alg:addfloattoindexed} allows the user to add a single floating
  point number to an indexed sum. By running this algorithm iteratively on each
  element of a vector, the user can make a naive local sum. However, a more
  efficient summation algorithm is presented in Section \ref{sec:primitiveops_sum}, making Algorithm \ref{alg:addfloattoindexed} more useful for small sums or sums where the summands are not gathered into a vector.
  This method is available in ReproBLAS as \texttt{idxd\_xixadd} in \texttt{idxd.h} (see Section \ref{sec:reproBLAS} for details).

  \begin{alg}
    Add floating point $x_n \in F$ to $K$-fold indexed sum $Y$
    \label{alg:addfloattoindexed}
    \begin{algorithmic}[1]
      \Require
        $Y$ is the indexed sum of $x_0, ..., x_{n - 1} \in F$. (If $n = 0$, this implies that all fields of $Y$ are 0 and $Y$ will be initialized in line \ref{alg:addfloattoindexed:update})
      \Function{Add Float To Indexed}{$K$, $x_n$, $Y$}
        \State \Call{Update}{$K$, $x_n$, $Y$} \label{alg:addfloattoindexed:update}
        \State \Call{Deposit}{$K$, $x_n$, $Y$}
        \State \Call{Renorm}{$K$, $Y$}
      \EndFunction
      \Ensure
        $Y$ is the indexed sum of $x_0, ..., x_{n}$.
    \end{algorithmic}
  \end{alg}

  The following theorem proves the ``Ensure'' claim at the end of Algorithm~\ref{alg:addfloattoindexed}.
  \begin{thm}
    If $Y$ is the $K$-fold indexed sum of $x_0, ..., x_{n - 1}$, then after
    running Algorithm~\ref{alg:addfloattoindexed} on $Y$ and some $x_n \in \F$,
    $Y$ is the indexed sum of $x_0, ..., x_n$.
    \label{thm:addfloattoindexed}
  \end{thm}

  \begin{proof}
    As $Y$ is the indexed sum of $x_0, ..., x_{n - 1}$, the requirements of \textproc{Update} (Algorithm \ref{alg:update}) are satisfied. Therefore, after \textproc{Update} completes, we have that the index of $Y$ is the greatest integer $I$ such that for all $j$, $0 \leq j \leq n$, $|x_j| < 2^{b_I}$ and $I \leq i_{\max}$. We also have that 
\[
\mathcal{Y}_k = \sum\limits_{j = 0}^{n - 1} d(x_j, I + k)
\]
  and
  \begin{equation}
          {Y_k}_P \in \begin{cases}[1.5  \epsilon^{-1} 2^{a_{I + k}}, 1.75  \epsilon^{-1} 2^{a_{I + k}}) \text{ if } I + k > 0 \\ [1.5 \cdot 2^{e_{\max}}, 1.75 \cdot 2^{e_{\max}})\text{ otherwise}\end{cases} \label{eq:addfloattoindexedupdatestep}
  \end{equation}
  (Unless ${Y_0}_P$ was \texttt{Inf}, \texttt{-Inf}, or \texttt{NaN} before the update operation, in which case $Y$ was unchanged and is still exceptional)

  Therefore, the requirements of \textproc{Deposit} (Algorithm \ref{alg:deposit}) are satisfied and after it is complete, we have that
  \begin{equation}
    \mathcal{Y}_k = \sum\limits_{j = 0}^{n} d(x_j, I + k)
    \label{eq:addfloattoindexedaccumvalue}
  \end{equation}
  (Unless ${Y_0}_P$ was \texttt{Inf}, \texttt{-Inf}, or \texttt{NaN} before the update operation, in which case ${Y_0}_P$ should reflect the correct value. Since the renormalization step does not act on exceptional indexed types, we are done in this case.)

  Finally, since \eqref{eq:addfloattoindexedupdatestep} held before the deposit operation, Theorem \ref{thm:renormfreq} holds and after the deposit (in Section \ref{sec:primitiveops_sum} we will use the fact that up to $2^{p - W - 2}$ deposits may be performed here as long as each new $x_j$ is such that $|x_j| < 2^{b_I}$), the requirements of \textproc{Renorm} (Algorithm \ref{alg:renorm}) hold and we have that once again
  \[
  {Y_k}_P \in \begin{cases}[1.5  \epsilon^{-1} 2^{a_{I + k}}, 1.75  \epsilon^{-1} 2^{a_{I + k}}) \text{ if } I + k > 0 \\ [1.5 \cdot 2^{e_{\max}}, 1.75 \cdot 2^{e_{\max}})\text{ otherwise}\end{cases}
  \]
  Since the renormalization step does not affect the values of the accumulators or the index of the indexed type, \eqref{eq:addfloattoindexedaccumvalue} still holds and all of the properties of the indexed sum are satisfied.
  \end{proof}

  A special usage of Algorithm \ref{alg:addfloattoindexed} is to convert a single floating point number to an indexed type. Converting a floating point number to an indexed type should produce, for
  transparency and reproducibility, the indexed sum of the single floating
  point number.
  The procedure is very simply summarized by Algorithm \ref{alg:conv2indexed}, and is available in ReproBLAS as \texttt{idxd\_xixconv} in \texttt{idxd.h} (see Section \ref{sec:reproBLAS} for details).

  \begin{samepage}
  \begin{alg}
    Convert floating point $x$ to a $K$-fold indexed type $Y$.
    \begin{algorithmic}[1]
      \Function{ConvertFloatToIndexed}{$K$, $x$, $Y$}
        \State $Y = 0$
        \State \Call{Add Float To Indexed}{$K$, $x$, $Y$}
      \EndFunction
      \Ensure
        $Y$ is the indexed sum of $x$.
    \end{algorithmic}
    \label{alg:conv2indexed}
  \end{alg}
  \end{samepage}
