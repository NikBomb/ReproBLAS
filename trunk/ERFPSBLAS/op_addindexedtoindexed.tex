\subsection{Add Indexed to Indexed}
    \label{sec:primitiveops_addindexedtoindexed}
    An operation to produce the sum of two indexed types is necessary to
    perform a reduction. For completeness we include the algorithm here,
    although apart from the simplified renormalization algorithm, it is
    equivalent to Algorithm $7$ in \cite{repsum}.
    This method is available in ReproBLAS as \texttt{idxd\_xixiadd} in \texttt{idxd.h} (see Section \ref{sec:reproBLAS} for details).

    \begin{samepage}
    \begin{alg}
      Given a $K$-fold indexed type $Y$ of index $I$ and a $K$-fold indexed
      type $Z$ of index $J$, add $Z$ to $Y$.
      \begin{algorithmic}[1]
        \Require
          \Statex $Y$ is the indexed sum of some $x_0, ..., x_{n - 1} \in F$.
          \Statex $Z$ is the indexed sum of some $x_n, ..., x_{n + m - 1} \in F$.
        \Function{AddIndexedToIndexed}{K, Y, Z}
          \If{${Y_0}_P = 0$}
            \State $Y = Z$
            \State \Return
          \EndIf
          \If{${Z_0}_P = 0$}
            \State \Return
          \EndIf
          \State $I$ = \Call{IIndex}{Y}
          \State $J$ = \Call{IIndex}{Z}
          \If{$J < I$}
            \State $R = Z$
            \State \Call{AddIndexedToIndexed}{K, $R$, $Y$}
            \State $Y = R$
            \State \Return
          \EndIf
          \For{$k = J-I$ \To $K-1$} \label{alg:addindexedtoindexed:beginfor}
            \If{$k = J = 0$}
              \State ${Y_{0}}_P = {Y_{0}}_P + ({Z_{0}}_P - 1.5 \cdot 2^{e_{\max}})$\label{alg:addindexedtoindexed:pri0}
            \Else
              \State ${Y_{k}}_P = {Y_{k}}_P + ({Z_{k + I-J}}_P - 1.5 \epsilon^{-1}  2^{a_{I+k}})$\label{alg:addindexedtoindexed:pri}
            \EndIf
            \State ${Y_{k}}_C = {Y_{k}}_C + {Z_{k + I - J}}_C$\label{alg:addindexedtoindexed:car}
          \EndFor
          \State \Call{Renorm}{K, $Y$}\label{alg:addindexedtoindexed:renorm}
        \EndFunction
        \Ensure
          \Statex $Y$ is set to the indexed sum of $x_0, ..., x_{n + m - 1}$.
          \Statex ${Y_k}_P \in [1.5  \epsilon^{-1} 2^{a_{\min(I, J) + k}}, 1.75  \epsilon^{-1} 2^{a_{\min(I, J) + k}})$
      \end{algorithmic}
      \label{alg:addindexedtoindexed}
    \end{alg}
    \end{samepage}

    \begin{thm}
      If the requirements of Algorithm~\ref{alg:addindexedtoindexed} are satisfied, then the ``Ensure'' claim holds.
      \label{thm:addindexedtoindexed}
    \end{thm}
    \begin{proof}
      If $Y$ or $Z$ are 0, then the algorithm correctly sets $Y$ to the value of $Z$ or $Y$ (respectively).

      If both $Y$ and $Z$ are exceptional, then Algorithm \ref{alg:iindex} will return $I = J = 0$. The first iteration of the loop of line \ref{alg:addindexedtoindexed:beginfor} will then set ${Y_{0}}_P$ to ${Y_{0}}_P + {Z_{0}}_P + 1.5 \cdot 2^{e_{\max}}$, which (since $1.5 \cdot 2^{e_{\max}}$ is finite) is equal to ${Y_{0}}_P + {Z_{0}}_P$, as desired.

      If only one of $Y$ or $Z$ is exceptional, then Algorithm \ref{alg:iindex} will return $I = 0$ or $J = 0$ (respectively). The first iteration of the loop of line \ref{alg:addindexedtoindexed:beginfor} will set ${Y_{0}}_P$ to the sum of the exceptional ${Y_0}_P$ or ${Z_0}_P$ (respectively) and some finite values. This sum is equal to the exceptional value. Therefore, if only one of $Y$ or $Z$ is exceptional, $Y$ is set to $Y$ or $Z$ (respectively), as desired.

      We now focus on the case where both $Y$ and $Z$ are finite.

      We must first prove that the addition in line \ref{alg:addindexedtoindexed:pri} is exact. As it is almost identical, we leave out the case where $I + k = 0$ and focus on the case where $I + k > 0$.
      Since $J$ is the index of $Z$, the index of ${Z_{k + I-J}}_P$ is
      $J + (k + I -J) = I + k$. It means that
      \(
        {Z_{k + I-J}}_P \in [1.5 \epsilon^{-1} 2^{a_{I+k}}, 1.75 \epsilon^{-1} 2^{a_{I+k}})
      \)
      and ${Z_{k + I-J}}_P \in 2^{a_{I+k}} \Z$.
      Therefore ${Z_{k + I-J}}_P - 1.5 \epsilon^{-1}  2^{a_{I+k}} \in 2^{a_{I+k}} \Z$
      and ${Z_{k + I-J}}_P - 1.5 \epsilon^{-1} \in [0, 0.25 \epsilon^{-1} 2^{a_{I+k}})$.
      This means ${Z_{k + I-J}}_P - 1.5 \epsilon^{-1}$ is representable and is
      exactly computed.
      Moreover, we have ${Y_{k}}_P \in 2^{a_{I+k}} \Z$ and
      \(
        {Y_{k}}_P \in [1.5 \epsilon^{-1} 2^{a_{I+k}}, 1.75 \epsilon^{-1} 2^{a_{I+k}})
      \).
      Therefore
      \(
        {Y_{k}}_P + ({Z_{k + I-J}}_P - 1.5 \epsilon^{-1}  2^{a_{I+k}})
          \in 2^{a_{I+k}} \Z,
      \)
      and
      \(
        {Y_{k}}_P + ({Z_{k + I-J}}_P - 1.5 \epsilon^{-1}  2^{a_{I+k}})
          \in [1.5 \epsilon^{-1} 2^{a_{I+k}}, 2 \epsilon^{-1} 2^{a_{I+k}})
      \).
      This means ${Y_{k}}_P + ({Z_{k + I-J}}_P - 1.5 \epsilon^{-1}  2^{a_{I+k}})$
      is representable and is exactly computed, and that the requirements of \textproc{Renorm} (Algorithm \ref{alg:renorm}) apply.

      We then have that after line \ref{alg:addindexedtoindexed:renorm}, \[
          {Y_k}_P \in \begin{cases}[1.5  \epsilon^{-1} 2^{a_{I + k}}, 1.75  \epsilon^{-1} 2^{a_{I + k}}) \text{ if } I + k > 0 \\ [1.5 \cdot 2^{e_{\max}}, 1.75 \cdot 2^{e_{\max}}) \text{ if } I + k = 0\end{cases}
      \]

      We assume that $n + m \leq (\epsilon^{-1} - 1)2^{p - W - 2}$ and therefore ${Y_{k}}_C + {Z_{k + I-J}}_C$ is exactly computed. We then have that $\mathcal{Y}_k = \sum\limits_{j = 0}^{m + n - 1} d(x_j, I + k)$.

      It is given that $I$ is the greatest integer such that $|x_j| < 2^{b_I}$ for all $j, 0 \leq j \leq n - 1$ and that $J$ is the greatest integer such that $|x_j| < 2^{b_I}$ for all $j, n \leq j \leq n + m - 1$. It is also given that $I, J \leq i_{\max}$
      Since $I < J$, $I$ is the greatest integer such that $|x_j| < 2^{b_I}$ for all $j, 0 \leq j \leq n + m - 1$ and $I \leq i_{\max}$.
    \end{proof}
