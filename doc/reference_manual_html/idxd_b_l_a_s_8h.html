<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>ReproBLAS: include/idxdBLAS.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ReproBLAS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">idxdBLAS.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="idxd_b_l_a_s_8h.html" title="idxdBLAS.h defines BLAS Methods that operate on indexed types. ">idxdBLAS.h</a> defines BLAS Methods that operate on indexed types.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="idxd_8h_source.html">idxd.h</a>&quot;</code><br />
<code>#include &quot;reproBLAS.h&quot;</code><br />
<code>#include &lt;complex.h&gt;</code><br />
</div>
<p><a href="idxd_b_l_a_s_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0890bde79799b60b02daa1d05f71bb9f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a0890bde79799b60b02daa1d05f71bb9f">idxdBLAS_samax</a> (const int N, const float *X, const int incX)</td></tr>
<tr class="memdesc:a0890bde79799b60b02daa1d05f71bb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum absolute value in vector of single precision.  <a href="#a0890bde79799b60b02daa1d05f71bb9f">More...</a><br /></td></tr>
<tr class="separator:a0890bde79799b60b02daa1d05f71bb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045be2d4cad59280123e0b0b3b0d74ce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a045be2d4cad59280123e0b0b3b0d74ce">idxdBLAS_damax</a> (const int N, const double *X, const int incX)</td></tr>
<tr class="memdesc:a045be2d4cad59280123e0b0b3b0d74ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum absolute value in vector of double precision.  <a href="#a045be2d4cad59280123e0b0b3b0d74ce">More...</a><br /></td></tr>
<tr class="separator:a045be2d4cad59280123e0b0b3b0d74ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861465be296f9fb78bab484ec37ab77e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a861465be296f9fb78bab484ec37ab77e">idxdBLAS_camax_sub</a> (const int N, const void *X, const int incX, void *amax)</td></tr>
<tr class="memdesc:a861465be296f9fb78bab484ec37ab77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum magnitude in vector of complex single precision.  <a href="#a861465be296f9fb78bab484ec37ab77e">More...</a><br /></td></tr>
<tr class="separator:a861465be296f9fb78bab484ec37ab77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b584a5383311a3476f71b029656ba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a24b584a5383311a3476f71b029656ba8">idxdBLAS_zamax_sub</a> (const int N, const void *X, const int incX, void *amax)</td></tr>
<tr class="memdesc:a24b584a5383311a3476f71b029656ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum magnitude in vector of complex double precision.  <a href="#a24b584a5383311a3476f71b029656ba8">More...</a><br /></td></tr>
<tr class="separator:a24b584a5383311a3476f71b029656ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61307f9cf113ab08af7c3acb7dd59e99"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a61307f9cf113ab08af7c3acb7dd59e99">idxdBLAS_samaxm</a> (const int N, const float *X, const int incX, const float *Y, const int incY)</td></tr>
<tr class="memdesc:a61307f9cf113ab08af7c3acb7dd59e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum absolute value pairwise product between vectors of single precision.  <a href="#a61307f9cf113ab08af7c3acb7dd59e99">More...</a><br /></td></tr>
<tr class="separator:a61307f9cf113ab08af7c3acb7dd59e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af617f5d688ce6d831fd65fd98f3d8f6a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#af617f5d688ce6d831fd65fd98f3d8f6a">idxdBLAS_damaxm</a> (const int N, const double *X, const int incX, const double *Y, const int incY)</td></tr>
<tr class="memdesc:af617f5d688ce6d831fd65fd98f3d8f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum absolute value pairwise product between vectors of double precision.  <a href="#af617f5d688ce6d831fd65fd98f3d8f6a">More...</a><br /></td></tr>
<tr class="separator:af617f5d688ce6d831fd65fd98f3d8f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9387a3316fee918102017db2f5e8326c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a9387a3316fee918102017db2f5e8326c">idxdBLAS_camaxm_sub</a> (const int N, const void *X, const int incX, const void *Y, const int incY, void *amaxm)</td></tr>
<tr class="memdesc:a9387a3316fee918102017db2f5e8326c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum magnitude pairwise product between vectors of complex single precision.  <a href="#a9387a3316fee918102017db2f5e8326c">More...</a><br /></td></tr>
<tr class="separator:a9387a3316fee918102017db2f5e8326c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56c512ecc78f581278e81b4d4be84c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#af56c512ecc78f581278e81b4d4be84c2">idxdBLAS_zamaxm_sub</a> (const int N, const void *X, const int incX, const void *Y, const int incY, void *amaxm)</td></tr>
<tr class="memdesc:af56c512ecc78f581278e81b4d4be84c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum magnitude pairwise product between vectors of complex double precision.  <a href="#af56c512ecc78f581278e81b4d4be84c2">More...</a><br /></td></tr>
<tr class="separator:af56c512ecc78f581278e81b4d4be84c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ed3a03522fbf8fd1cbc329b2a120fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a50ed3a03522fbf8fd1cbc329b2a120fd">idxdBLAS_didsum</a> (const int fold, const int N, const double *X, const int incX, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a50ed3a03522fbf8fd1cbc329b2a120fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed double precision Y the sum of double precision vector X.  <a href="#a50ed3a03522fbf8fd1cbc329b2a120fd">More...</a><br /></td></tr>
<tr class="separator:a50ed3a03522fbf8fd1cbc329b2a120fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f151db15ebc9ff479ff806da79fa46c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a0f151db15ebc9ff479ff806da79fa46c">idxdBLAS_dmdsum</a> (const int fold, const int N, const double *X, const int incX, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a0f151db15ebc9ff479ff806da79fa46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed double precision Y the sum of double precision vector X.  <a href="#a0f151db15ebc9ff479ff806da79fa46c">More...</a><br /></td></tr>
<tr class="separator:a0f151db15ebc9ff479ff806da79fa46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52d9e07b8001864b8e61e182f4905b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#aa52d9e07b8001864b8e61e182f4905b9">idxdBLAS_didasum</a> (const int fold, const int N, const double *X, const int incX, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:aa52d9e07b8001864b8e61e182f4905b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed double precision Y the absolute sum of double precision vector X.  <a href="#aa52d9e07b8001864b8e61e182f4905b9">More...</a><br /></td></tr>
<tr class="separator:aa52d9e07b8001864b8e61e182f4905b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56addb2dc4c7e4328cfa6623ee8f725a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a56addb2dc4c7e4328cfa6623ee8f725a">idxdBLAS_dmdasum</a> (const int fold, const int N, const double *X, const int incX, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a56addb2dc4c7e4328cfa6623ee8f725a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed double precision Y the absolute sum of double precision vector X.  <a href="#a56addb2dc4c7e4328cfa6623ee8f725a">More...</a><br /></td></tr>
<tr class="separator:a56addb2dc4c7e4328cfa6623ee8f725a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744236f5b23996346a3b82934143914e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a744236f5b23996346a3b82934143914e">idxdBLAS_didssq</a> (const int fold, const int N, const double *X, const int incX, const double scaleY, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a744236f5b23996346a3b82934143914e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to scaled indexed double precision Y the scaled sum of squares of elements of double precision vector X.  <a href="#a744236f5b23996346a3b82934143914e">More...</a><br /></td></tr>
<tr class="separator:a744236f5b23996346a3b82934143914e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a46667d7dac6fc0c49e2f84ec2e89a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a52a46667d7dac6fc0c49e2f84ec2e89a">idxdBLAS_dmdssq</a> (const int fold, const int N, const double *X, const int incX, const double scaleY, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a52a46667d7dac6fc0c49e2f84ec2e89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to scaled manually specified indexed double precision Y the scaled sum of squares of elements of double precision vector X.  <a href="#a52a46667d7dac6fc0c49e2f84ec2e89a">More...</a><br /></td></tr>
<tr class="separator:a52a46667d7dac6fc0c49e2f84ec2e89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37c7a4d09af2f35d63a187028879a65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#ad37c7a4d09af2f35d63a187028879a65">idxdBLAS_diddot</a> (const int fold, const int N, const double *X, const int incX, const double *Y, const int incY, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Z)</td></tr>
<tr class="memdesc:ad37c7a4d09af2f35d63a187028879a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed double precision Z the dot product of double precision vectors X and Y.  <a href="#ad37c7a4d09af2f35d63a187028879a65">More...</a><br /></td></tr>
<tr class="separator:ad37c7a4d09af2f35d63a187028879a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad239c08961f83b2ca207de4741909eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#ad239c08961f83b2ca207de4741909eb9">idxdBLAS_dmddot</a> (const int fold, const int N, const double *X, const int incX, const double *Y, const int incY, double *manZ, const int incmanZ, double *carZ, const int inccarZ)</td></tr>
<tr class="memdesc:ad239c08961f83b2ca207de4741909eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed double precision Z the dot product of double precision vectors X and Y.  <a href="#ad239c08961f83b2ca207de4741909eb9">More...</a><br /></td></tr>
<tr class="separator:ad239c08961f83b2ca207de4741909eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370c57c48af4ca2f9648e0c785cde079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a370c57c48af4ca2f9648e0c785cde079">idxdBLAS_zizsum</a> (const int fold, const int N, const void *X, const int incX, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a370c57c48af4ca2f9648e0c785cde079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed complex double precision Y the sum of complex double precision vector X.  <a href="#a370c57c48af4ca2f9648e0c785cde079">More...</a><br /></td></tr>
<tr class="separator:a370c57c48af4ca2f9648e0c785cde079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc4fb20761557a05d7d2af84d01e21b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#abfc4fb20761557a05d7d2af84d01e21b">idxdBLAS_zmzsum</a> (const int fold, const int N, const void *X, const int incX, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:abfc4fb20761557a05d7d2af84d01e21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed complex double precision Y the sum of complex double precision vector X.  <a href="#abfc4fb20761557a05d7d2af84d01e21b">More...</a><br /></td></tr>
<tr class="separator:abfc4fb20761557a05d7d2af84d01e21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101f184f3a793a818b4d258288a6ee12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a101f184f3a793a818b4d258288a6ee12">idxdBLAS_dizasum</a> (const int fold, const int N, const void *X, const int incX, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a101f184f3a793a818b4d258288a6ee12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed double precision Y the absolute sum of complex double precision vector X.  <a href="#a101f184f3a793a818b4d258288a6ee12">More...</a><br /></td></tr>
<tr class="separator:a101f184f3a793a818b4d258288a6ee12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2ff3b6e6d0f56ba0ae90507e23cf51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#aff2ff3b6e6d0f56ba0ae90507e23cf51">idxdBLAS_dmzasum</a> (const int fold, const int N, const void *X, const int incX, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:aff2ff3b6e6d0f56ba0ae90507e23cf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed double precision Y the absolute sum of complex double precision vector X.  <a href="#aff2ff3b6e6d0f56ba0ae90507e23cf51">More...</a><br /></td></tr>
<tr class="separator:aff2ff3b6e6d0f56ba0ae90507e23cf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029f677961766b0c7c2e3b65454b21d0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a029f677961766b0c7c2e3b65454b21d0">idxdBLAS_dizssq</a> (const int fold, const int N, const void *X, const int incX, const double scaleY, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a029f677961766b0c7c2e3b65454b21d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to scaled indexed double precision Y the scaled sum of squares of elements of complex double precision vector X.  <a href="#a029f677961766b0c7c2e3b65454b21d0">More...</a><br /></td></tr>
<tr class="separator:a029f677961766b0c7c2e3b65454b21d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccd438356b17673139a603abd687fc8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a7ccd438356b17673139a603abd687fc8">idxdBLAS_dmzssq</a> (const int fold, const int N, const void *X, const int incX, const double scaleY, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a7ccd438356b17673139a603abd687fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to scaled manually specified indexed double precision Y the scaled sum of squares of elements of complex double precision vector X.  <a href="#a7ccd438356b17673139a603abd687fc8">More...</a><br /></td></tr>
<tr class="separator:a7ccd438356b17673139a603abd687fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56819653ba73575c51e9af3327c0a835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a56819653ba73575c51e9af3327c0a835">idxdBLAS_zizdotu</a> (const int fold, const int N, const void *X, const int incX, const void *Y, const int incY, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Z)</td></tr>
<tr class="memdesc:a56819653ba73575c51e9af3327c0a835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed complex double precision Z the unconjugated dot product of complex double precision vectors X and Y.  <a href="#a56819653ba73575c51e9af3327c0a835">More...</a><br /></td></tr>
<tr class="separator:a56819653ba73575c51e9af3327c0a835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8dcabb76ce4665d4ceae0a56599da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a8b8dcabb76ce4665d4ceae0a56599da3">idxdBLAS_zmzdotu</a> (const int fold, const int N, const void *X, const int incX, const void *Y, const int incY, double *manZ, const int incmanZ, double *carZ, const int inccarZ)</td></tr>
<tr class="memdesc:a8b8dcabb76ce4665d4ceae0a56599da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed complex double precision Z the unconjugated dot product of complex double precision vectors X and Y.  <a href="#a8b8dcabb76ce4665d4ceae0a56599da3">More...</a><br /></td></tr>
<tr class="separator:a8b8dcabb76ce4665d4ceae0a56599da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dc764d287d79cbf31c157311084042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a79dc764d287d79cbf31c157311084042">idxdBLAS_zizdotc</a> (const int fold, const int N, const void *X, const int incX, const void *Y, const int incY, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Z)</td></tr>
<tr class="memdesc:a79dc764d287d79cbf31c157311084042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed complex double precision Z the conjugated dot product of complex double precision vectors X and Y.  <a href="#a79dc764d287d79cbf31c157311084042">More...</a><br /></td></tr>
<tr class="separator:a79dc764d287d79cbf31c157311084042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9544378dce738345fa7d25372edc4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#ae9544378dce738345fa7d25372edc4ad">idxdBLAS_zmzdotc</a> (const int fold, const int N, const void *X, const int incX, const void *Y, const int incY, double *manZ, const int incmanZ, double *carZ, const int inccarZ)</td></tr>
<tr class="memdesc:ae9544378dce738345fa7d25372edc4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed complex double precision Z the conjugated dot product of complex double precision vectors X and Y.  <a href="#ae9544378dce738345fa7d25372edc4ad">More...</a><br /></td></tr>
<tr class="separator:ae9544378dce738345fa7d25372edc4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eea0cb07b45a5224d376315c1e32819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a1eea0cb07b45a5224d376315c1e32819">idxdBLAS_sissum</a> (const int fold, const int N, const float *X, const int incX, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a1eea0cb07b45a5224d376315c1e32819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed single precision Y the sum of single precision vector X.  <a href="#a1eea0cb07b45a5224d376315c1e32819">More...</a><br /></td></tr>
<tr class="separator:a1eea0cb07b45a5224d376315c1e32819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72820ac6b0eee856407b5abbc5ac1e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a72820ac6b0eee856407b5abbc5ac1e2f">idxdBLAS_smssum</a> (const int fold, const int N, const float *X, const int incX, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a72820ac6b0eee856407b5abbc5ac1e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed single precision Y the sum of single precision vector X.  <a href="#a72820ac6b0eee856407b5abbc5ac1e2f">More...</a><br /></td></tr>
<tr class="separator:a72820ac6b0eee856407b5abbc5ac1e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768271acff435eb6b46f9b3c89592dff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a768271acff435eb6b46f9b3c89592dff">idxdBLAS_sisasum</a> (const int fold, const int N, const float *X, const int incX, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a768271acff435eb6b46f9b3c89592dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed single precision Y the absolute sum of single precision vector X.  <a href="#a768271acff435eb6b46f9b3c89592dff">More...</a><br /></td></tr>
<tr class="separator:a768271acff435eb6b46f9b3c89592dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41580610d95d298386111b201187e63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#ab41580610d95d298386111b201187e63">idxdBLAS_smsasum</a> (const int fold, const int N, const float *X, const int incX, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:ab41580610d95d298386111b201187e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed single precision Y the absolute sum of double precision vector X.  <a href="#ab41580610d95d298386111b201187e63">More...</a><br /></td></tr>
<tr class="separator:ab41580610d95d298386111b201187e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3752e126f80a39a3096167f6cf7c36"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#afa3752e126f80a39a3096167f6cf7c36">idxdBLAS_sisssq</a> (const int fold, const int N, const float *X, const int incX, const float scaleY, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:afa3752e126f80a39a3096167f6cf7c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to scaled indexed single precision Y the scaled sum of squares of elements of single precision vector X.  <a href="#afa3752e126f80a39a3096167f6cf7c36">More...</a><br /></td></tr>
<tr class="separator:afa3752e126f80a39a3096167f6cf7c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f826ddec1564c2e2d871ba0b12fd7c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#ae5f826ddec1564c2e2d871ba0b12fd7c">idxdBLAS_smsssq</a> (const int fold, const int N, const float *X, const int incX, const float scaleY, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:ae5f826ddec1564c2e2d871ba0b12fd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to scaled manually specified indexed single precision Y the scaled sum of squares of elements of single precision vector X.  <a href="#ae5f826ddec1564c2e2d871ba0b12fd7c">More...</a><br /></td></tr>
<tr class="separator:ae5f826ddec1564c2e2d871ba0b12fd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f15d5f97b0a3e71666327d196b5e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a45f15d5f97b0a3e71666327d196b5e16">idxdBLAS_sisdot</a> (const int fold, const int N, const float *X, const int incX, const float *Y, const int incY, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Z)</td></tr>
<tr class="memdesc:a45f15d5f97b0a3e71666327d196b5e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed single precision Z the dot product of single precision vectors X and Y.  <a href="#a45f15d5f97b0a3e71666327d196b5e16">More...</a><br /></td></tr>
<tr class="separator:a45f15d5f97b0a3e71666327d196b5e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4efa3e339e67b06195048d938dfd66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a5f4efa3e339e67b06195048d938dfd66">idxdBLAS_smsdot</a> (const int fold, const int N, const float *X, const int incX, const float *Y, const int incY, float *manZ, const int incmanZ, float *carZ, const int inccarZ)</td></tr>
<tr class="memdesc:a5f4efa3e339e67b06195048d938dfd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed single precision Z the dot product of single precision vectors X and Y.  <a href="#a5f4efa3e339e67b06195048d938dfd66">More...</a><br /></td></tr>
<tr class="separator:a5f4efa3e339e67b06195048d938dfd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24479231f1068e265d08828b7c996e53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a24479231f1068e265d08828b7c996e53">idxdBLAS_cicsum</a> (const int fold, const int N, const void *X, const int incX, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a24479231f1068e265d08828b7c996e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed complex single precision Y the sum of complex single precision vector X.  <a href="#a24479231f1068e265d08828b7c996e53">More...</a><br /></td></tr>
<tr class="separator:a24479231f1068e265d08828b7c996e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecb4643ac12bc2eeeef8781ec39497d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a9ecb4643ac12bc2eeeef8781ec39497d">idxdBLAS_cmcsum</a> (const int fold, const int N, const void *X, const int incX, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a9ecb4643ac12bc2eeeef8781ec39497d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed complex single precision Y the sum of complex single precision vector X.  <a href="#a9ecb4643ac12bc2eeeef8781ec39497d">More...</a><br /></td></tr>
<tr class="separator:a9ecb4643ac12bc2eeeef8781ec39497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e16c17f8d5dc646c11beb306adc165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#ab8e16c17f8d5dc646c11beb306adc165">idxdBLAS_sicasum</a> (const int fold, const int N, const void *X, const int incX, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:ab8e16c17f8d5dc646c11beb306adc165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed single precision Y the absolute sum of complex single precision vector X.  <a href="#ab8e16c17f8d5dc646c11beb306adc165">More...</a><br /></td></tr>
<tr class="separator:ab8e16c17f8d5dc646c11beb306adc165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d970e6b1e1652efd77e87614d6ff3d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a2d970e6b1e1652efd77e87614d6ff3d1">idxdBLAS_smcasum</a> (const int fold, const int N, const void *X, const int incX, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a2d970e6b1e1652efd77e87614d6ff3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed single precision Y the absolute sum of complex single precision vector X.  <a href="#a2d970e6b1e1652efd77e87614d6ff3d1">More...</a><br /></td></tr>
<tr class="separator:a2d970e6b1e1652efd77e87614d6ff3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c874432c8cdd0afac59e2b8d207672"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a47c874432c8cdd0afac59e2b8d207672">idxdBLAS_sicssq</a> (const int fold, const int N, const void *X, const int incX, const float scaleY, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a47c874432c8cdd0afac59e2b8d207672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to scaled indexed single precision Y the scaled sum of squares of elements of complex single precision vector X.  <a href="#a47c874432c8cdd0afac59e2b8d207672">More...</a><br /></td></tr>
<tr class="separator:a47c874432c8cdd0afac59e2b8d207672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a094e39b4b3196b722c459dcece981"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#ad7a094e39b4b3196b722c459dcece981">idxdBLAS_smcssq</a> (const int fold, const int N, const void *X, const int incX, const float scaleY, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:ad7a094e39b4b3196b722c459dcece981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to scaled manually specified indexed single precision Y the scaled sum of squares of elements of complex single precision vector X.  <a href="#ad7a094e39b4b3196b722c459dcece981">More...</a><br /></td></tr>
<tr class="separator:ad7a094e39b4b3196b722c459dcece981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e641d3ad18b5be2c60170e0c08616de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a9e641d3ad18b5be2c60170e0c08616de">idxdBLAS_cicdotu</a> (const int fold, const int N, const void *X, const int incX, const void *Y, const int incY, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Z)</td></tr>
<tr class="memdesc:a9e641d3ad18b5be2c60170e0c08616de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed complex single precision Z the unconjugated dot product of complex single precision vectors X and Y.  <a href="#a9e641d3ad18b5be2c60170e0c08616de">More...</a><br /></td></tr>
<tr class="separator:a9e641d3ad18b5be2c60170e0c08616de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82424c79a25e77c9b7a5cce9936599b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a82424c79a25e77c9b7a5cce9936599b0">idxdBLAS_cmcdotu</a> (const int fold, const int N, const void *X, const int incX, const void *Y, const int incY, float *manZ, const int incmanZ, float *carZ, const int inccarZ)</td></tr>
<tr class="memdesc:a82424c79a25e77c9b7a5cce9936599b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed complex single precision Z the unconjugated dot product of complex single precision vectors X and Y.  <a href="#a82424c79a25e77c9b7a5cce9936599b0">More...</a><br /></td></tr>
<tr class="separator:a82424c79a25e77c9b7a5cce9936599b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a37821841a97696696be6791d7bb16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a8a37821841a97696696be6791d7bb16d">idxdBLAS_cicdotc</a> (const int fold, const int N, const void *X, const int incX, const void *Y, const int incY, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Z)</td></tr>
<tr class="memdesc:a8a37821841a97696696be6791d7bb16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed complex single precision Z the conjugated dot product of complex single precision vectors X and Y.  <a href="#a8a37821841a97696696be6791d7bb16d">More...</a><br /></td></tr>
<tr class="separator:a8a37821841a97696696be6791d7bb16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac334c9d7244e3ba6581b11839f62fcc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#ac334c9d7244e3ba6581b11839f62fcc2">idxdBLAS_cmcdotc</a> (const int fold, const int N, const void *X, const int incX, const void *Y, const int incY, float *manZ, const int incmanZ, float *carZ, const int inccarZ)</td></tr>
<tr class="memdesc:ac334c9d7244e3ba6581b11839f62fcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to manually specified indexed complex single precision Z the conjugated dot product of complex single precision vectors X and Y.  <a href="#ac334c9d7244e3ba6581b11839f62fcc2">More...</a><br /></td></tr>
<tr class="separator:ac334c9d7244e3ba6581b11839f62fcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed77973a0a53a474041bf423a0da0a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#aaed77973a0a53a474041bf423a0da0a0">idxdBLAS_didgemv</a> (const int fold, const char Order, const char TransA, const int M, const int N, const double alpha, const double *A, const int lda, const double *X, const int incX, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y, const int incY)</td></tr>
<tr class="memdesc:aaed77973a0a53a474041bf423a0da0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed double precision vector Y the matrix-vector product of double precision matrix A and double precision vector X.  <a href="#aaed77973a0a53a474041bf423a0da0a0">More...</a><br /></td></tr>
<tr class="separator:aaed77973a0a53a474041bf423a0da0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1339f04716be87ac5fad8d74844bff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#aaa1339f04716be87ac5fad8d74844bff">idxdBLAS_didgemm</a> (const int fold, const char Order, const char TransA, const char TransB, const int M, const int N, const int K, const double alpha, const double *A, const int lda, const double *B, const int ldb, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *C, const int ldc)</td></tr>
<tr class="memdesc:aaa1339f04716be87ac5fad8d74844bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed double precision matrix C the matrix-matrix product of double precision matrices A and B.  <a href="#aaa1339f04716be87ac5fad8d74844bff">More...</a><br /></td></tr>
<tr class="separator:aaa1339f04716be87ac5fad8d74844bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada73ac0f7cb6da46cec547fa369ea3b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#ada73ac0f7cb6da46cec547fa369ea3b2">idxdBLAS_sisgemv</a> (const int fold, const char Order, const char TransA, const int M, const int N, const float alpha, const float *A, const int lda, const float *X, const int incX, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ada73ac0f7cb6da46cec547fa369ea3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed single precision vector Y the matrix-vector product of single precision matrix A and single precision vector X.  <a href="#ada73ac0f7cb6da46cec547fa369ea3b2">More...</a><br /></td></tr>
<tr class="separator:ada73ac0f7cb6da46cec547fa369ea3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a53748dd5270a1ec24ec005de400ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a23a53748dd5270a1ec24ec005de400ce">idxdBLAS_sisgemm</a> (const int fold, const char Order, const char TransA, const char TransB, const int M, const int N, const int K, const float alpha, const float *A, const int lda, const float *B, const int ldb, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *C, const int ldc)</td></tr>
<tr class="memdesc:a23a53748dd5270a1ec24ec005de400ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed single precision matrix C the matrix-matrix product of single precision matrices A and B.  <a href="#a23a53748dd5270a1ec24ec005de400ce">More...</a><br /></td></tr>
<tr class="separator:a23a53748dd5270a1ec24ec005de400ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af349049879d130677c9cb88ca29e27f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#af349049879d130677c9cb88ca29e27f5">idxdBLAS_zizgemv</a> (const int fold, const char Order, const char TransA, const int M, const int N, const void *alpha, const void *A, const int lda, const void *X, const int incX, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y, const int incY)</td></tr>
<tr class="memdesc:af349049879d130677c9cb88ca29e27f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed complex double precision vector Y the matrix-vector product of complex double precision matrix A and complex double precision vector X.  <a href="#af349049879d130677c9cb88ca29e27f5">More...</a><br /></td></tr>
<tr class="separator:af349049879d130677c9cb88ca29e27f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3251ed493305df151999252992cc1a72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a3251ed493305df151999252992cc1a72">idxdBLAS_zizgemm</a> (const int fold, const char Order, const char TransA, const char TransB, const int M, const int N, const int K, const void *alpha, const void *A, const int lda, const void *B, const int ldb, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *C, const int ldc)</td></tr>
<tr class="memdesc:a3251ed493305df151999252992cc1a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed complex double precision matrix C the matrix-matrix product of complex double precision matrices A and B.  <a href="#a3251ed493305df151999252992cc1a72">More...</a><br /></td></tr>
<tr class="separator:a3251ed493305df151999252992cc1a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84ecb4113826eb9cad5394ba46b87e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#ad84ecb4113826eb9cad5394ba46b87e6">idxdBLAS_cicgemv</a> (const int fold, const char Order, const char TransA, const int M, const int N, const void *alpha, const void *A, const int lda, const void *X, const int incX, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ad84ecb4113826eb9cad5394ba46b87e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed complex single precision vector Y the matrix-vector product of complex single precision matrix A and complex single precision vector X.  <a href="#ad84ecb4113826eb9cad5394ba46b87e6">More...</a><br /></td></tr>
<tr class="separator:ad84ecb4113826eb9cad5394ba46b87e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d16dd5e1d3a011d70a9ed62aebd7d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_b_l_a_s_8h.html#a95d16dd5e1d3a011d70a9ed62aebd7d1">idxdBLAS_cicgemm</a> (const int fold, const char Order, const char TransA, const char TransB, const int M, const int N, const int K, const void *alpha, const void *A, const int lda, const void *B, const int ldb, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *C, const int ldc)</td></tr>
<tr class="memdesc:a95d16dd5e1d3a011d70a9ed62aebd7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to indexed complex single precision matrix C the matrix-matrix product of complex single precision matrices A and B.  <a href="#a95d16dd5e1d3a011d70a9ed62aebd7d1">More...</a><br /></td></tr>
<tr class="separator:a95d16dd5e1d3a011d70a9ed62aebd7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="idxd_b_l_a_s_8h.html" title="idxdBLAS.h defines BLAS Methods that operate on indexed types. ">idxdBLAS.h</a> defines BLAS Methods that operate on indexed types. </p>
<p>This header is modeled after cblas.h, and as such functions are prefixed with character sets describing the data types they operate upon. For example, the function <code>dfoo</code> would perform the function <code>foo</code> on <code>double</code> possibly returning a <code>double</code>.</p>
<p>If two character sets are prefixed, the first set of characters describes the output and the second the input type. For example, the function <code>dzbar</code> would perform the function <code>bar</code> on <code>double</code> <code>complex</code> and return a <code>double</code>.</p>
<p>Such character sets are listed as follows:</p><ul>
<li>d - double (<code>double</code>)</li>
<li>z - complex double (<code>*void</code>)</li>
<li>s - float (<code>float</code>)</li>
<li>c - complex float (<code>*void</code>)</li>
<li>di - indexed double (<a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a>)</li>
<li>zi - indexed complex double (<a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a>)</li>
<li>si - indexed float (<a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a>)</li>
<li>ci - indexed complex float (<a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a>)</li>
<li>dm - manually specified indexed double (<code>double</code>, <code>double</code>)</li>
<li>zm - manually specified indexed complex double (<code>double</code>, <code>double</code>)</li>
<li>sm - manually specified indexed float (<code>float</code>, <code>float</code>)</li>
<li>cm - manually specified indexed complex float (<code>float</code>, <code>float</code>)</li>
</ul>
<p>Throughout the library, complex types are specified via <code>*void</code> pointers. These routines will sometimes be suffixed by sub, to represent that a function has been made into a subroutine. This allows programmers to use whatever complex types they are already using, as long as the memory pointed to is of the form of two adjacent floating point types, the first and second representing real and imaginary components of the complex number.</p>
<p>The goal of using indexed types is to obtain either more accurate or reproducible summation of floating point numbers. Indexed types are composed of several adjacent bins...</p>
<p>The parameter <code>fold</code> describes how many bins are used in the indexed types supplied to a subroutine. The maximum value for this parameter can be set in config.h. If you are unsure of what value to use for , we recommend 3. Note that the <code>fold</code> of indexed types must be the same for all indexed types that interact with each other. Operations on more than one indexed type assume all indexed types being operated upon have the same <code>fold</code>. Note that the <code>fold</code> of an indexed type may not be changed once the type has been allocated. A common use case would be to set the value of <code>fold</code> as a global macro in your code and supply it to all indexed functions that you use.</p>
<p>Power users of the library may find themselves wanting to manually specify the underlying primary and carry vectors of an indexed type themselves. If you do not know what these are, don't worry about the manually specified indexed types. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a861465be296f9fb78bab484ec37ab77e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_camax_sub </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>amax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find maximum magnitude in vector of complex single precision. </p>
<p>Returns the magnitude of the element of maximum magnitude in an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">amax</td><td>scalar return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a9387a3316fee918102017db2f5e8326c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_camaxm_sub </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>amaxm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find maximum magnitude pairwise product between vectors of complex single precision. </p>
<p>Returns the magnitude of the pairwise product of maximum magnitude between X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">amaxm</td><td>scalar return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a8a37821841a97696696be6791d7bb16d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_cicdotc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed complex single precision Z the conjugated dot product of complex single precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and conjugated Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">indexed</td><td>scalar Z</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a9e641d3ad18b5be2c60170e0c08616de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_cicdotu </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed complex single precision Z the unconjugated dot product of complex single precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">indexed</td><td>scalar Z</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a95d16dd5e1d3a011d70a9ed62aebd7d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_cicgemm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed complex single precision matrix C the matrix-matrix product of complex single precision matrices A and B. </p>
<p>Performs one of the matrix-matrix operations</p>
<p>C := alpha*op(A)*op(B) + C,</p>
<p>where op(X) is one of</p>
<p>op(X) = X or op(X) = X**T or op(X) = X**H,</p>
<p>alpha is a scalar, A and B are matrices with op(A) an M by K matrix and op(B) a K by N matrix, and C is an indexed M by N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">Order</td><td>a character specifying the matrix ordering ('r' or 'R' for row-major, 'c' or 'C' for column major) </td></tr>
    <tr><td class="paramname">TransA</td><td>a character specifying whether or not to transpose A before taking the matrix-matrix product ('n' or 'N' not to transpose, 't' or 'T' to transpose, 'c' or 'C' to conjugate transpose) </td></tr>
    <tr><td class="paramname">TransB</td><td>a character specifying whether or not to transpose B before taking the matrix-matrix product ('n' or 'N' not to transpose, 't' or 'T' to transpose, 'c' or 'C' to conjugate transpose) </td></tr>
    <tr><td class="paramname">M</td><td>number of rows of matrix op(A) and of the matrix C. </td></tr>
    <tr><td class="paramname">N</td><td>number of columns of matrix op(B) and of the matrix C. </td></tr>
    <tr><td class="paramname">K</td><td>number of columns of matrix op(A) and columns of the matrix op(B). </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar alpha </td></tr>
    <tr><td class="paramname">A</td><td>complex single precision matrix of dimension (ma, lda) in row-major or (lda, na) in column-major. (ma, na) is (M, K) if A is not transposed and (K, M) otherwise. </td></tr>
    <tr><td class="paramname">lda</td><td>the first dimension of A as declared in the calling program. lda must be at least na in row major or ma in column major. </td></tr>
    <tr><td class="paramname">B</td><td>complex single precision matrix of dimension (mb, ldb) in row-major or (ldb, nb) in column-major. (mb, nb) is (K, N) if B is not transposed and (N, K) otherwise. </td></tr>
    <tr><td class="paramname">ldb</td><td>the first dimension of B as declared in the calling program. ldb must be at least nb in row major or mb in column major. </td></tr>
    <tr><td class="paramname">C</td><td>indexed complex single precision matrix of dimension (M, ldc) in row-major or (ldc, N) in column-major. </td></tr>
    <tr><td class="paramname">ldc</td><td>the first dimension of C as declared in the calling program. ldc must be at least N in row major or M in column major.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ad84ecb4113826eb9cad5394ba46b87e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_cicgemv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed complex single precision vector Y the matrix-vector product of complex single precision matrix A and complex single precision vector X. </p>
<p>Performs one of the matrix-vector operations</p>
<p>y := alpha*A*x + beta*y or y := alpha*A**T*x + beta*y or y := alpha*A**H*x + beta*y,</p>
<p>where alpha and beta are scalars, x is a vector, y is an indexed vector, and A is an M by N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">Order</td><td>a character specifying the matrix ordering ('r' or 'R' for row-major, 'c' or 'C' for column major) </td></tr>
    <tr><td class="paramname">TransA</td><td>a character specifying whether or not to transpose A before taking the matrix-vector product ('n' or 'N' not to transpose, 't' or 'T' to transpose, 'c' or 'C' to conjugate transpose) </td></tr>
    <tr><td class="paramname">M</td><td>number of rows of matrix A </td></tr>
    <tr><td class="paramname">N</td><td>number of columns of matrix A </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar alpha </td></tr>
    <tr><td class="paramname">A</td><td>complex single precision matrix of dimension (M, lda) in row-major or (lda, N) in column-major </td></tr>
    <tr><td class="paramname">lda</td><td>the first dimension of A as declared in the calling program </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector of at least size N if not transposed or size M otherwise </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">beta</td><td>scalar beta </td></tr>
    <tr><td class="paramname">Y</td><td>indexed complex single precision vector Y of at least size M if not transposed or size N otherwise </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a24479231f1068e265d08828b7c996e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_cicsum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed complex single precision Y the sum of complex single precision vector X. </p>
<p>Add to Y the indexed sum of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">indexed</td><td>scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ac334c9d7244e3ba6581b11839f62fcc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_cmcdotc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>manZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed complex single precision Z the conjugated dot product of complex single precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and conjugated Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">priZ</td><td>Z's primary vector </td></tr>
    <tr><td class="paramname">incpriZ</td><td>stride within Z's primary vector (use every incpriZ'th element) </td></tr>
    <tr><td class="paramname">carZ</td><td>Z's carry vector </td></tr>
    <tr><td class="paramname">inccarZ</td><td>stride within Z's carry vector (use every inccarZ'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a82424c79a25e77c9b7a5cce9936599b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_cmcdotu </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>manZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed complex single precision Z the unconjugated dot product of complex single precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">priZ</td><td>Z's primary vector </td></tr>
    <tr><td class="paramname">incpriZ</td><td>stride within Z's primary vector (use every incpriZ'th element) </td></tr>
    <tr><td class="paramname">carZ</td><td>Z's carry vector </td></tr>
    <tr><td class="paramname">inccarZ</td><td>stride within Z's carry vector (use every inccarZ'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a9ecb4643ac12bc2eeeef8781ec39497d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_cmcsum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed complex single precision Y the sum of complex single precision vector X. </p>
<p>Add to Y the indexed sum of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a045be2d4cad59280123e0b0b3b0d74ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxdBLAS_damax </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find maximum absolute value in vector of double precision. </p>
<p>Returns the absolute value of the element of maximum absolute value in an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute maximum value of X</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="af617f5d688ce6d831fd65fd98f3d8f6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxdBLAS_damaxm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find maximum absolute value pairwise product between vectors of double precision. </p>
<p>Returns the absolute value of the pairwise product of maximum absolute value between X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute maximum value multiple of X and Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="aa52d9e07b8001864b8e61e182f4905b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_didasum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed double precision Y the absolute sum of double precision vector X. </p>
<p>Add to Y the indexed sum of absolute values of elements in X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ad37c7a4d09af2f35d63a187028879a65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_diddot </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed double precision Z the dot product of double precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">Z</td><td>indexed scalar Z</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="aaa1339f04716be87ac5fad8d74844bff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_didgemm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed double precision matrix C the matrix-matrix product of double precision matrices A and B. </p>
<p>Performs one of the matrix-matrix operations</p>
<p>C := alpha*op(A)*op(B) + C,</p>
<p>where op(X) is one of</p>
<p>op(X) = X or op(X) = X**T,</p>
<p>alpha is a scalar, A and B are matrices with op(A) an M by K matrix and op(B) a K by N matrix, and C is an indexed M by N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">Order</td><td>a character specifying the matrix ordering ('r' or 'R' for row-major, 'c' or 'C' for column major) </td></tr>
    <tr><td class="paramname">TransA</td><td>a character specifying whether or not to transpose A before taking the matrix-matrix product ('n' or 'N' not to transpose, 't' or 'T' or 'c' or 'C' to transpose) </td></tr>
    <tr><td class="paramname">TransB</td><td>a character specifying whether or not to transpose B before taking the matrix-matrix product ('n' or 'N' not to transpose, 't' or 'T' or 'c' or 'C' to transpose) </td></tr>
    <tr><td class="paramname">M</td><td>number of rows of matrix op(A) and of the matrix C. </td></tr>
    <tr><td class="paramname">N</td><td>number of columns of matrix op(B) and of the matrix C. </td></tr>
    <tr><td class="paramname">K</td><td>number of columns of matrix op(A) and columns of the matrix op(B). </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar alpha </td></tr>
    <tr><td class="paramname">A</td><td>double precision matrix of dimension (ma, lda) in row-major or (lda, na) in column-major. (ma, na) is (M, K) if A is not transposed and (K, M) otherwise. </td></tr>
    <tr><td class="paramname">lda</td><td>the first dimension of A as declared in the calling program. lda must be at least na in row major or ma in column major. </td></tr>
    <tr><td class="paramname">B</td><td>double precision matrix of dimension (mb, ldb) in row-major or (ldb, nb) in column-major. (mb, nb) is (K, N) if B is not transposed and (N, K) otherwise. </td></tr>
    <tr><td class="paramname">ldb</td><td>the first dimension of B as declared in the calling program. ldb must be at least nb in row major or mb in column major. </td></tr>
    <tr><td class="paramname">C</td><td>indexed double precision matrix of dimension (M, ldc) in row-major or (ldc, N) in column-major. </td></tr>
    <tr><td class="paramname">ldc</td><td>the first dimension of C as declared in the calling program. ldc must be at least N in row major or M in column major.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="aaed77973a0a53a474041bf423a0da0a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_didgemv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed double precision vector Y the matrix-vector product of double precision matrix A and double precision vector X. </p>
<p>Performs one of the matrix-vector operations</p>
<p>y := alpha*A*x + y or y := alpha*A**T*x + y,</p>
<p>where alpha is a scalar, x is a vector, y is an indexed vector, and A is an M by N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">Order</td><td>a character specifying the matrix ordering ('r' or 'R' for row-major, 'c' or 'C' for column major) </td></tr>
    <tr><td class="paramname">TransA</td><td>a character specifying whether or not to transpose A before taking the matrix-vector product ('n' or 'N' not to transpose, 't' or 'T' or 'c' or 'C' to transpose) </td></tr>
    <tr><td class="paramname">M</td><td>number of rows of matrix A </td></tr>
    <tr><td class="paramname">N</td><td>number of columns of matrix A </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar alpha </td></tr>
    <tr><td class="paramname">A</td><td>double precision matrix of dimension (M, lda) in row-major or (lda, N) in column-major </td></tr>
    <tr><td class="paramname">lda</td><td>the first dimension of A as declared in the calling program </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector of at least size N if not transposed or size M otherwise </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed double precision vector Y of at least size M if not transposed or size N otherwise </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a744236f5b23996346a3b82934143914e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxdBLAS_didssq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to scaled indexed double precision Y the scaled sum of squares of elements of double precision vector X. </p>
<p>Add to Y the scaled indexed sum of the squares of each element of X. The scaling of each square is performed using <a class="el" href="idxd_8h.html#aba28c49a5d1675e83ffe1180268f18f5" title="Get a reproducible double precision scale. ">idxd_dscale()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">scaleY</td><td>the scaling factor of Y </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new scaling factor of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a50ed3a03522fbf8fd1cbc329b2a120fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_didsum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed double precision Y the sum of double precision vector X. </p>
<p>Add to Y the indexed sum of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a101f184f3a793a818b4d258288a6ee12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_dizasum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed double precision Y the absolute sum of complex double precision vector X. </p>
<p>Add to Y the indexed sum of magnitudes of elements of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a029f677961766b0c7c2e3b65454b21d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxdBLAS_dizssq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to scaled indexed double precision Y the scaled sum of squares of elements of complex double precision vector X. </p>
<p>Add to Y the scaled indexed sum of the squares of each element of X. The scaling of each square is performed using <a class="el" href="idxd_8h.html#aba28c49a5d1675e83ffe1180268f18f5" title="Get a reproducible double precision scale. ">idxd_dscale()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">scaleY</td><td>the scaling factor of Y </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new scaling factor of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a56addb2dc4c7e4328cfa6623ee8f725a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_dmdasum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed double precision Y the absolute sum of double precision vector X. </p>
<p>Add to Y the indexed sum of absolute values of elements in X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ad239c08961f83b2ca207de4741909eb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_dmddot </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>manZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed double precision Z the dot product of double precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">priZ</td><td>Z's primary vector </td></tr>
    <tr><td class="paramname">incpriZ</td><td>stride within Z's primary vector (use every incpriZ'th element) </td></tr>
    <tr><td class="paramname">carZ</td><td>Z's carry vector </td></tr>
    <tr><td class="paramname">inccarZ</td><td>stride within Z's carry vector (use every inccarZ'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a52a46667d7dac6fc0c49e2f84ec2e89a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxdBLAS_dmdssq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to scaled manually specified indexed double precision Y the scaled sum of squares of elements of double precision vector X. </p>
<p>Add to Y the scaled indexed sum of the squares of each element of X. The scaling of each square is performed using <a class="el" href="idxd_8h.html#aba28c49a5d1675e83ffe1180268f18f5" title="Get a reproducible double precision scale. ">idxd_dscale()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">scaleY</td><td>the scaling factor of Y </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new scaling factor of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a0f151db15ebc9ff479ff806da79fa46c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_dmdsum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed double precision Y the sum of double precision vector X. </p>
<p>Set Y to the indexed sum of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="aff2ff3b6e6d0f56ba0ae90507e23cf51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_dmzasum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed double precision Y the absolute sum of complex double precision vector X. </p>
<p>Add to Y the indexed sum of magnitudes of elements of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a7ccd438356b17673139a603abd687fc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxdBLAS_dmzssq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to scaled manually specified indexed double precision Y the scaled sum of squares of elements of complex double precision vector X. </p>
<p>Add to Y the scaled indexed sum of the squares of each element of X. The scaling of each square is performed using <a class="el" href="idxd_8h.html#aba28c49a5d1675e83ffe1180268f18f5" title="Get a reproducible double precision scale. ">idxd_dscale()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">scaleY</td><td>the scaling factor of Y </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new scaling factor of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a0890bde79799b60b02daa1d05f71bb9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxdBLAS_samax </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find maximum absolute value in vector of single precision. </p>
<p>Returns the absolute value of the element of maximum absolute value in an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute maximum value of X</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a61307f9cf113ab08af7c3acb7dd59e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxdBLAS_samaxm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find maximum absolute value pairwise product between vectors of single precision. </p>
<p>Returns the absolute value of the pairwise product of maximum absolute value between X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute maximum value multiple of X and Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ab8e16c17f8d5dc646c11beb306adc165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_sicasum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed single precision Y the absolute sum of complex single precision vector X. </p>
<p>Add to Y the indexed sum of magnitudes of elements of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a47c874432c8cdd0afac59e2b8d207672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxdBLAS_sicssq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to scaled indexed single precision Y the scaled sum of squares of elements of complex single precision vector X. </p>
<p>Add to Y the scaled indexed sum of the squares of each element of X. The scaling of each square is performed using <a class="el" href="idxd_8h.html#af4249bdeace36d301f505ba286ea8934" title="Get a reproducible single precision scale. ">idxd_sscale()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">scaleY</td><td>the scaling factor of Y </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new scaling factor of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a768271acff435eb6b46f9b3c89592dff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_sisasum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed single precision Y the absolute sum of single precision vector X. </p>
<p>Add to Y the indexed sum of absolute values of elements in X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a45f15d5f97b0a3e71666327d196b5e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_sisdot </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed single precision Z the dot product of single precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">Z</td><td>indexed scalar Z</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a23a53748dd5270a1ec24ec005de400ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_sisgemm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed single precision matrix C the matrix-matrix product of single precision matrices A and B. </p>
<p>Performs one of the matrix-matrix operations</p>
<p>C := alpha*op(A)*op(B) + C,</p>
<p>where op(X) is one of</p>
<p>op(X) = X or op(X) = X**T,</p>
<p>alpha is a scalar, A and B are matrices with op(A) an M by K matrix and op(B) a K by N matrix, and C is an indexed M by N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">Order</td><td>a character specifying the matrix ordering ('r' or 'R' for row-major, 'c' or 'C' for column major) </td></tr>
    <tr><td class="paramname">TransA</td><td>a character specifying whether or not to transpose A before taking the matrix-matrix product ('n' or 'N' not to transpose, 't' or 'T' or 'c' or 'C' to transpose) </td></tr>
    <tr><td class="paramname">TransB</td><td>a character specifying whether or not to transpose B before taking the matrix-matrix product ('n' or 'N' not to transpose, 't' or 'T' or 'c' or 'C' to transpose) </td></tr>
    <tr><td class="paramname">M</td><td>number of rows of matrix op(A) and of the matrix C. </td></tr>
    <tr><td class="paramname">N</td><td>number of columns of matrix op(B) and of the matrix C. </td></tr>
    <tr><td class="paramname">K</td><td>number of columns of matrix op(A) and columns of the matrix op(B). </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar alpha </td></tr>
    <tr><td class="paramname">A</td><td>single precision matrix of dimension (ma, lda) in row-major or (lda, na) in column-major. (ma, na) is (M, K) if A is not transposed and (K, M) otherwise. </td></tr>
    <tr><td class="paramname">lda</td><td>the first dimension of A as declared in the calling program. lda must be at least na in row major or ma in column major. </td></tr>
    <tr><td class="paramname">B</td><td>single precision matrix of dimension (mb, ldb) in row-major or (ldb, nb) in column-major. (mb, nb) is (K, N) if B is not transposed and (N, K) otherwise. </td></tr>
    <tr><td class="paramname">ldb</td><td>the first dimension of B as declared in the calling program. ldb must be at least nb in row major or mb in column major. </td></tr>
    <tr><td class="paramname">C</td><td>indexed single precision matrix of dimension (M, ldc) in row-major or (ldc, N) in column-major. </td></tr>
    <tr><td class="paramname">ldc</td><td>the first dimension of C as declared in the calling program. ldc must be at least N in row major or M in column major.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ada73ac0f7cb6da46cec547fa369ea3b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_sisgemv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed single precision vector Y the matrix-vector product of single precision matrix A and single precision vector X. </p>
<p>Performs one of the matrix-vector operations</p>
<p>y := alpha*A*x + beta*y or y := alpha*A**T*x + beta*y,</p>
<p>where alpha and beta are scalars, x is a vector, y is an indexed vector, and A is an M by N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">Order</td><td>a character specifying the matrix ordering ('r' or 'R' for row-major, 'c' or 'C' for column major) </td></tr>
    <tr><td class="paramname">TransA</td><td>a character specifying whether or not to transpose A before taking the matrix-vector product ('n' or 'N' not to transpose, 't' or 'T' or 'c' or 'C' to transpose) </td></tr>
    <tr><td class="paramname">M</td><td>number of rows of matrix A </td></tr>
    <tr><td class="paramname">N</td><td>number of columns of matrix A </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar alpha </td></tr>
    <tr><td class="paramname">A</td><td>single precision matrix of dimension (M, lda) in row-major or (lda, N) in column-major </td></tr>
    <tr><td class="paramname">lda</td><td>the first dimension of A as declared in the calling program </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector of at least size N if not transposed or size M otherwise </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">beta</td><td>scalar beta </td></tr>
    <tr><td class="paramname">Y</td><td>indexed single precision vector Y of at least size M if not transposed or size N otherwise </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="afa3752e126f80a39a3096167f6cf7c36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxdBLAS_sisssq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to scaled indexed single precision Y the scaled sum of squares of elements of single precision vector X. </p>
<p>Add to Y the scaled indexed sum of the squares of each element of X. The scaling of each square is performed using <a class="el" href="idxd_8h.html#af4249bdeace36d301f505ba286ea8934" title="Get a reproducible single precision scale. ">idxd_sscale()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">scaleY</td><td>the scaling factor of Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new scaling factor of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a1eea0cb07b45a5224d376315c1e32819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_sissum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed single precision Y the sum of single precision vector X. </p>
<p>Add to Y the indexed sum of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a2d970e6b1e1652efd77e87614d6ff3d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_smcasum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed single precision Y the absolute sum of complex single precision vector X. </p>
<p>Add to Y the indexed sum of magnitudes of elements of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ad7a094e39b4b3196b722c459dcece981"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxdBLAS_smcssq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to scaled manually specified indexed single precision Y the scaled sum of squares of elements of complex single precision vector X. </p>
<p>Add to Y the scaled indexed sum of the squares of each element of X. The scaling of each square is performed using <a class="el" href="idxd_8h.html#af4249bdeace36d301f505ba286ea8934" title="Get a reproducible single precision scale. ">idxd_sscale()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">scaleY</td><td>the scaling factor of Y </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new scaling factor of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ab41580610d95d298386111b201187e63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_smsasum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed single precision Y the absolute sum of double precision vector X. </p>
<p>Add to Y to the indexed sum of absolute values of elements in X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a5f4efa3e339e67b06195048d938dfd66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_smsdot </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>manZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed single precision Z the dot product of single precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">priZ</td><td>Z's primary vector </td></tr>
    <tr><td class="paramname">incpriZ</td><td>stride within Z's primary vector (use every incpriZ'th element) </td></tr>
    <tr><td class="paramname">carZ</td><td>Z's carry vector </td></tr>
    <tr><td class="paramname">inccarZ</td><td>stride within Z's carry vector (use every inccarZ'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ae5f826ddec1564c2e2d871ba0b12fd7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxdBLAS_smsssq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to scaled manually specified indexed single precision Y the scaled sum of squares of elements of single precision vector X. </p>
<p>Add to Y the scaled indexed sum of the squares of each element of X. The scaling of each square is performed using <a class="el" href="idxd_8h.html#af4249bdeace36d301f505ba286ea8934" title="Get a reproducible single precision scale. ">idxd_sscale()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">scaleY</td><td>the scaling factor of Y </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new scaling factor of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a72820ac6b0eee856407b5abbc5ac1e2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_smssum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed single precision Y the sum of single precision vector X. </p>
<p>Add to Y the indexed sum of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>single precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a24b584a5383311a3476f71b029656ba8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_zamax_sub </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>amax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find maximum magnitude in vector of complex double precision. </p>
<p>Returns the magnitude of the element of maximum magnitude in an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">amax</td><td>scalar return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="af56c512ecc78f581278e81b4d4be84c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_zamaxm_sub </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>amaxm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find maximum magnitude pairwise product between vectors of complex double precision. </p>
<p>Returns the magnitude of the pairwise product of maximum magnitude between X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">amaxm</td><td>scalar return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a79dc764d287d79cbf31c157311084042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_zizdotc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed complex double precision Z the conjugated dot product of complex double precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and conjugated Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">scalar</td><td>return Z</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a56819653ba73575c51e9af3327c0a835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_zizdotu </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed complex double precision Z the unconjugated dot product of complex double precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">indexed</td><td>scalar Z</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a3251ed493305df151999252992cc1a72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_zizgemm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed complex double precision matrix C the matrix-matrix product of complex double precision matrices A and B. </p>
<p>Performs one of the matrix-matrix operations</p>
<p>C := alpha*op(A)*op(B) + C,</p>
<p>where op(X) is one of</p>
<p>op(X) = X or op(X) = X**T or op(X) = X**H,</p>
<p>alpha is a scalar, A and B are matrices with op(A) an M by K matrix and op(B) a K by N matrix, and C is an indexed M by N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">Order</td><td>a character specifying the matrix ordering ('r' or 'R' for row-major, 'c' or 'C' for column major) </td></tr>
    <tr><td class="paramname">TransA</td><td>a character specifying whether or not to transpose A before taking the matrix-matrix product ('n' or 'N' not to transpose, 't' or 'T' to transpose, 'c' or 'C' to conjugate transpose) </td></tr>
    <tr><td class="paramname">TransB</td><td>a character specifying whether or not to transpose B before taking the matrix-matrix product ('n' or 'N' not to transpose, 't' or 'T' to transpose, 'c' or 'C' to conjugate transpose) </td></tr>
    <tr><td class="paramname">M</td><td>number of rows of matrix op(A) and of the matrix C. </td></tr>
    <tr><td class="paramname">N</td><td>number of columns of matrix op(B) and of the matrix C. </td></tr>
    <tr><td class="paramname">K</td><td>number of columns of matrix op(A) and columns of the matrix op(B). </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar alpha </td></tr>
    <tr><td class="paramname">A</td><td>complex double precision matrix of dimension (ma, lda) in row-major or (lda, na) in column-major. (ma, na) is (M, K) if A is not transposed and (K, M) otherwise. </td></tr>
    <tr><td class="paramname">lda</td><td>the first dimension of A as declared in the calling program. lda must be at least na in row major or ma in column major. </td></tr>
    <tr><td class="paramname">B</td><td>complex double precision matrix of dimension (mb, ldb) in row-major or (ldb, nb) in column-major. (mb, nb) is (K, N) if B is not transposed and (N, K) otherwise. </td></tr>
    <tr><td class="paramname">ldb</td><td>the first dimension of B as declared in the calling program. ldb must be at least nb in row major or mb in column major. </td></tr>
    <tr><td class="paramname">C</td><td>indexed complex double precision matrix of dimension (M, ldc) in row-major or (ldc, N) in column-major. </td></tr>
    <tr><td class="paramname">ldc</td><td>the first dimension of C as declared in the calling program. ldc must be at least N in row major or M in column major.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="af349049879d130677c9cb88ca29e27f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_zizgemv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>TransA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed complex double precision vector Y the matrix-vector product of complex double precision matrix A and complex double precision vector X. </p>
<p>Performs one of the matrix-vector operations</p>
<p>y := alpha*A*x + beta*y or y := alpha*A**T*x + beta*y or y := alpha*A**H*x + beta*y,</p>
<p>where alpha and beta are scalars, x is a vector, y is an indexed vector, and A is an M by N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">Order</td><td>a character specifying the matrix ordering ('r' or 'R' for row-major, 'c' or 'C' for column major) </td></tr>
    <tr><td class="paramname">TransA</td><td>a character specifying whether or not to transpose A before taking the matrix-vector product ('n' or 'N' not to transpose, 't' or 'T' to transpose, 'c' or 'C' to conjugate transpose) </td></tr>
    <tr><td class="paramname">M</td><td>number of rows of matrix A </td></tr>
    <tr><td class="paramname">N</td><td>number of columns of matrix A </td></tr>
    <tr><td class="paramname">alpha</td><td>scalar alpha </td></tr>
    <tr><td class="paramname">A</td><td>complex double precision matrix of dimension (M, lda) in row-major or (lda, N) in column-major </td></tr>
    <tr><td class="paramname">lda</td><td>the first dimension of A as declared in the calling program </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector of at least size N if not transposed or size M otherwise </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">beta</td><td>scalar beta </td></tr>
    <tr><td class="paramname">Y</td><td>indexed complex double precision vector Y of at least size M if not transposed or size N otherwise </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a370c57c48af4ca2f9648e0c785cde079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_zizsum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to indexed complex double precision Y the sum of complex double precision vector X. </p>
<p>Add to Y the indexed sum of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">indexed</td><td>scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ae9544378dce738345fa7d25372edc4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_zmzdotc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>manZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed complex double precision Z the conjugated dot product of complex double precision vectors X and Y. </p>
<p>Add to Z the indexed sum of the pairwise products of X and conjugated Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">priZ</td><td>Z's primary vector </td></tr>
    <tr><td class="paramname">incpriZ</td><td>stride within Z's primary vector (use every incpriZ'th element) </td></tr>
    <tr><td class="paramname">carZ</td><td>Z's carry vector </td></tr>
    <tr><td class="paramname">inccarZ</td><td>stride within Z's carry vector (use every inccarZ'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8dcabb76ce4665d4ceae0a56599da3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_zmzdotu </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>manZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed complex double precision Z the unconjugated dot product of complex double precision vectors X and Y. </p>
<p>Add to Z to the indexed sum of the pairwise products of X and Y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element) </td></tr>
    <tr><td class="paramname">priZ</td><td>Z's primary vector </td></tr>
    <tr><td class="paramname">incpriZ</td><td>stride within Z's primary vector (use every incpriZ'th element) </td></tr>
    <tr><td class="paramname">carZ</td><td>Z's carry vector </td></tr>
    <tr><td class="paramname">inccarZ</td><td>stride within Z's carry vector (use every inccarZ'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="abfc4fb20761557a05d7d2af84d01e21b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxdBLAS_zmzsum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>manY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incmanY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to manually specified indexed complex double precision Y the sum of complex double precision vector X. </p>
<p>Add to Y the indexed sum of X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>complex double precision vector </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15 Jan 2016 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 18 2016 21:33:12 for ReproBLAS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
