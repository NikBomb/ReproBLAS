<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>ReproBLAS: include/idxd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ReproBLAS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">idxd.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="idxd_8h.html" title="idxd.h defines the indexed types and the lower level functions associated with their use...">idxd.h</a> defines the indexed types and the lower level functions associated with their use.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;float.h&gt;</code><br />
</div>
<p><a href="idxd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a599505844cb962d59e19656425c138e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a599505844cb962d59e19656425c138e4">DIWIDTH</a>&#160;&#160;&#160;40</td></tr>
<tr class="memdesc:a599505844cb962d59e19656425c138e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed double precision bin width.  <a href="#a599505844cb962d59e19656425c138e4">More...</a><br /></td></tr>
<tr class="separator:a599505844cb962d59e19656425c138e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab413e780857154cb96be6cef85757a6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ab413e780857154cb96be6cef85757a6b">SIWIDTH</a>&#160;&#160;&#160;13</td></tr>
<tr class="memdesc:ab413e780857154cb96be6cef85757a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed single precision bin width.  <a href="#ab413e780857154cb96be6cef85757a6b">More...</a><br /></td></tr>
<tr class="separator:ab413e780857154cb96be6cef85757a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6724376962c17b824208b67d49089b05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a6724376962c17b824208b67d49089b05">idxd_DIMAXINDEX</a>&#160;&#160;&#160;(((DBL_MAX_EXP - DBL_MIN_EXP + DBL_MANT_DIG - 1)/<a class="el" href="idxd_8h.html#a599505844cb962d59e19656425c138e4">DIWIDTH</a>) - 1)</td></tr>
<tr class="memdesc:a6724376962c17b824208b67d49089b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed double precision maximum index.  <a href="#a6724376962c17b824208b67d49089b05">More...</a><br /></td></tr>
<tr class="separator:a6724376962c17b824208b67d49089b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a44f683987188a73a727c6505ee7905"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a3a44f683987188a73a727c6505ee7905">idxd_SIMAXINDEX</a>&#160;&#160;&#160;(((FLT_MAX_EXP - FLT_MIN_EXP + FLT_MANT_DIG - 1)/<a class="el" href="idxd_8h.html#ab413e780857154cb96be6cef85757a6b">SIWIDTH</a>) - 1)</td></tr>
<tr class="memdesc:a3a44f683987188a73a727c6505ee7905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed single precision maximum index.  <a href="#a3a44f683987188a73a727c6505ee7905">More...</a><br /></td></tr>
<tr class="separator:a3a44f683987188a73a727c6505ee7905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7782edd0de1008d39f4f9d92816d09b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a7782edd0de1008d39f4f9d92816d09b3">idxd_DIMAXFOLD</a>&#160;&#160;&#160;(<a class="el" href="idxd_8h.html#a6724376962c17b824208b67d49089b05">idxd_DIMAXINDEX</a> + 1)</td></tr>
<tr class="memdesc:a7782edd0de1008d39f4f9d92816d09b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum double precision fold supported by the library.  <a href="#a7782edd0de1008d39f4f9d92816d09b3">More...</a><br /></td></tr>
<tr class="separator:a7782edd0de1008d39f4f9d92816d09b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8f62d952980e30d30a562688e72e8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a2d8f62d952980e30d30a562688e72e8a">idxd_SIMAXFOLD</a>&#160;&#160;&#160;(<a class="el" href="idxd_8h.html#a3a44f683987188a73a727c6505ee7905">idxd_SIMAXINDEX</a> + 1)</td></tr>
<tr class="memdesc:a2d8f62d952980e30d30a562688e72e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum single precision fold supported by the library.  <a href="#a2d8f62d952980e30d30a562688e72e8a">More...</a><br /></td></tr>
<tr class="separator:a2d8f62d952980e30d30a562688e72e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af954e9bac7c6a6aa4cd03449a7a22a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a2af954e9bac7c6a6aa4cd03449a7a22a">idxd_DIENDURANCE</a>&#160;&#160;&#160;(1 &lt;&lt; (DBL_MANT_DIG - <a class="el" href="idxd_8h.html#a599505844cb962d59e19656425c138e4">DIWIDTH</a> - 2))</td></tr>
<tr class="memdesc:a2af954e9bac7c6a6aa4cd03449a7a22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed double precision deposit endurance.  <a href="#a2af954e9bac7c6a6aa4cd03449a7a22a">More...</a><br /></td></tr>
<tr class="separator:a2af954e9bac7c6a6aa4cd03449a7a22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14129e0c6c6bca93e0ed7c521897f794"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a14129e0c6c6bca93e0ed7c521897f794">idxd_SIENDURANCE</a>&#160;&#160;&#160;(1 &lt;&lt; (FLT_MANT_DIG - <a class="el" href="idxd_8h.html#ab413e780857154cb96be6cef85757a6b">SIWIDTH</a> - 2))</td></tr>
<tr class="memdesc:a14129e0c6c6bca93e0ed7c521897f794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed single precision deposit endurance.  <a href="#a14129e0c6c6bca93e0ed7c521897f794">More...</a><br /></td></tr>
<tr class="separator:a14129e0c6c6bca93e0ed7c521897f794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46dd78091caab74e25a9faa5199ed94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ab46dd78091caab74e25a9faa5199ed94">idxd_DICAPACITY</a>&#160;&#160;&#160;(<a class="el" href="idxd_8h.html#a2af954e9bac7c6a6aa4cd03449a7a22a">idxd_DIENDURANCE</a>*(1.0/DBL_EPSILON - 1.0))</td></tr>
<tr class="memdesc:ab46dd78091caab74e25a9faa5199ed94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed double precision capacity.  <a href="#ab46dd78091caab74e25a9faa5199ed94">More...</a><br /></td></tr>
<tr class="separator:ab46dd78091caab74e25a9faa5199ed94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ee6f4d2be2e37ab6bc76f17f582edf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a40ee6f4d2be2e37ab6bc76f17f582edf">idxd_SICAPACITY</a>&#160;&#160;&#160;(<a class="el" href="idxd_8h.html#a14129e0c6c6bca93e0ed7c521897f794">idxd_SIENDURANCE</a>*(1.0/FLT_EPSILON - 1.0))</td></tr>
<tr class="memdesc:a40ee6f4d2be2e37ab6bc76f17f582edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed single precision capacity.  <a href="#a40ee6f4d2be2e37ab6bc76f17f582edf">More...</a><br /></td></tr>
<tr class="separator:a40ee6f4d2be2e37ab6bc76f17f582edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ea8fbab57dae125c1f34eb35eee883"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a09ea8fbab57dae125c1f34eb35eee883">idxd_DMCOMPRESSION</a>&#160;&#160;&#160;(1.0/(1 &lt;&lt; (DBL_MANT_DIG - <a class="el" href="idxd_8h.html#a599505844cb962d59e19656425c138e4">DIWIDTH</a> + 1)))</td></tr>
<tr class="memdesc:a09ea8fbab57dae125c1f34eb35eee883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed double precision compression factor.  <a href="#a09ea8fbab57dae125c1f34eb35eee883">More...</a><br /></td></tr>
<tr class="separator:a09ea8fbab57dae125c1f34eb35eee883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af198fd6d0c0c989ab612587d3ab0c20a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#af198fd6d0c0c989ab612587d3ab0c20a">idxd_SMCOMPRESSION</a>&#160;&#160;&#160;(1.0/(1 &lt;&lt; (FLT_MANT_DIG - <a class="el" href="idxd_8h.html#ab413e780857154cb96be6cef85757a6b">SIWIDTH</a> + 1)))</td></tr>
<tr class="memdesc:af198fd6d0c0c989ab612587d3ab0c20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed single precision compression factor.  <a href="#af198fd6d0c0c989ab612587d3ab0c20a">More...</a><br /></td></tr>
<tr class="separator:af198fd6d0c0c989ab612587d3ab0c20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040339c081037d4757f512efd6ccb474"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a040339c081037d4757f512efd6ccb474">idxd_DMEXPANSION</a>&#160;&#160;&#160;(1.0*(1 &lt;&lt; (DBL_MANT_DIG - <a class="el" href="idxd_8h.html#a599505844cb962d59e19656425c138e4">DIWIDTH</a> + 1)))</td></tr>
<tr class="memdesc:a040339c081037d4757f512efd6ccb474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed double precision expansion factor.  <a href="#a040339c081037d4757f512efd6ccb474">More...</a><br /></td></tr>
<tr class="separator:a040339c081037d4757f512efd6ccb474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef77262410180d40f358dee51da820b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#adef77262410180d40f358dee51da820b">idxd_SMEXPANSION</a>&#160;&#160;&#160;(1.0*(1 &lt;&lt; (FLT_MANT_DIG - <a class="el" href="idxd_8h.html#ab413e780857154cb96be6cef85757a6b">SIWIDTH</a> + 1)))</td></tr>
<tr class="memdesc:adef77262410180d40f358dee51da820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed single precision expansion factor.  <a href="#adef77262410180d40f358dee51da820b">More...</a><br /></td></tr>
<tr class="separator:adef77262410180d40f358dee51da820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4f97de021a0bed1b84317670c9abd1bb"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a></td></tr>
<tr class="memdesc:a4f97de021a0bed1b84317670c9abd1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexed double datatype.  <a href="#a4f97de021a0bed1b84317670c9abd1bb">More...</a><br /></td></tr>
<tr class="separator:a4f97de021a0bed1b84317670c9abd1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2eabe291f8e4804c5d19c036a62292"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a></td></tr>
<tr class="memdesc:a1f2eabe291f8e4804c5d19c036a62292"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexed complex double datatype.  <a href="#a1f2eabe291f8e4804c5d19c036a62292">More...</a><br /></td></tr>
<tr class="separator:a1f2eabe291f8e4804c5d19c036a62292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c164750f0c6d25d7e5e2e15b463965"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a></td></tr>
<tr class="memdesc:ad8c164750f0c6d25d7e5e2e15b463965"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexed float datatype.  <a href="#ad8c164750f0c6d25d7e5e2e15b463965">More...</a><br /></td></tr>
<tr class="separator:ad8c164750f0c6d25d7e5e2e15b463965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fb6b6c787120ead562dd4558003b73"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a></td></tr>
<tr class="memdesc:a87fb6b6c787120ead562dd4558003b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexed complex float datatype.  <a href="#a87fb6b6c787120ead562dd4558003b73">More...</a><br /></td></tr>
<tr class="separator:a87fb6b6c787120ead562dd4558003b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a428c9122898b3a39eca0d17f3e91e748"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a428c9122898b3a39eca0d17f3e91e748">idxd_disize</a> (const int fold)</td></tr>
<tr class="memdesc:a428c9122898b3a39eca0d17f3e91e748"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed double precision size  <a href="#a428c9122898b3a39eca0d17f3e91e748">More...</a><br /></td></tr>
<tr class="separator:a428c9122898b3a39eca0d17f3e91e748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d61841683c2970758a02fa90b06029d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a3d61841683c2970758a02fa90b06029d">idxd_zisize</a> (const int fold)</td></tr>
<tr class="memdesc:a3d61841683c2970758a02fa90b06029d"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex double precision size  <a href="#a3d61841683c2970758a02fa90b06029d">More...</a><br /></td></tr>
<tr class="separator:a3d61841683c2970758a02fa90b06029d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672552f7bbb7ddcf07408022d71abbbc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a672552f7bbb7ddcf07408022d71abbbc">idxd_sisize</a> (const int fold)</td></tr>
<tr class="memdesc:a672552f7bbb7ddcf07408022d71abbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed single precision size  <a href="#a672552f7bbb7ddcf07408022d71abbbc">More...</a><br /></td></tr>
<tr class="separator:a672552f7bbb7ddcf07408022d71abbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f6c0bbc21af5b56f15f361c25af231"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#af0f6c0bbc21af5b56f15f361c25af231">idxd_cisize</a> (const int fold)</td></tr>
<tr class="memdesc:af0f6c0bbc21af5b56f15f361c25af231"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex single precision size  <a href="#af0f6c0bbc21af5b56f15f361c25af231">More...</a><br /></td></tr>
<tr class="separator:af0f6c0bbc21af5b56f15f361c25af231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373445fc971b41afb130f5c82e180d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a373445fc971b41afb130f5c82e180d2b">idxd_dialloc</a> (const int fold)</td></tr>
<tr class="memdesc:a373445fc971b41afb130f5c82e180d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed double precision allocation  <a href="#a373445fc971b41afb130f5c82e180d2b">More...</a><br /></td></tr>
<tr class="separator:a373445fc971b41afb130f5c82e180d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7767605ef63728d7c6c1e36a3bf01e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ac7767605ef63728d7c6c1e36a3bf01e6">idxd_zialloc</a> (const int fold)</td></tr>
<tr class="memdesc:ac7767605ef63728d7c6c1e36a3bf01e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex double precision allocation  <a href="#ac7767605ef63728d7c6c1e36a3bf01e6">More...</a><br /></td></tr>
<tr class="separator:ac7767605ef63728d7c6c1e36a3bf01e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c1c90f794bc307a762456965335192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ac6c1c90f794bc307a762456965335192">idxd_sialloc</a> (const int fold)</td></tr>
<tr class="memdesc:ac6c1c90f794bc307a762456965335192"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed single precision allocation  <a href="#ac6c1c90f794bc307a762456965335192">More...</a><br /></td></tr>
<tr class="separator:ac6c1c90f794bc307a762456965335192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573d283ce7d7d5002fc438b53776d4b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a573d283ce7d7d5002fc438b53776d4b7">idxd_cialloc</a> (const int fold)</td></tr>
<tr class="memdesc:a573d283ce7d7d5002fc438b53776d4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex single precision allocation  <a href="#a573d283ce7d7d5002fc438b53776d4b7">More...</a><br /></td></tr>
<tr class="separator:a573d283ce7d7d5002fc438b53776d4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662306c0da0bfeb36d1168bc905fb49d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a662306c0da0bfeb36d1168bc905fb49d">idxd_dinum</a> (const int fold)</td></tr>
<tr class="memdesc:a662306c0da0bfeb36d1168bc905fb49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed double precision size  <a href="#a662306c0da0bfeb36d1168bc905fb49d">More...</a><br /></td></tr>
<tr class="separator:a662306c0da0bfeb36d1168bc905fb49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1659471f0c0c4258eab0eef398630c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aa1659471f0c0c4258eab0eef398630c0">idxd_zinum</a> (const int fold)</td></tr>
<tr class="memdesc:aa1659471f0c0c4258eab0eef398630c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex double precision size  <a href="#aa1659471f0c0c4258eab0eef398630c0">More...</a><br /></td></tr>
<tr class="separator:aa1659471f0c0c4258eab0eef398630c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab178e152425d62e3f603482ea2fc4066"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ab178e152425d62e3f603482ea2fc4066">idxd_sinum</a> (const int fold)</td></tr>
<tr class="memdesc:ab178e152425d62e3f603482ea2fc4066"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed single precision size  <a href="#ab178e152425d62e3f603482ea2fc4066">More...</a><br /></td></tr>
<tr class="separator:ab178e152425d62e3f603482ea2fc4066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47985298aba1e5280026cad2a41867ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a47985298aba1e5280026cad2a41867ff">idxd_cinum</a> (const int fold)</td></tr>
<tr class="memdesc:a47985298aba1e5280026cad2a41867ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex single precision size  <a href="#a47985298aba1e5280026cad2a41867ff">More...</a><br /></td></tr>
<tr class="separator:a47985298aba1e5280026cad2a41867ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6230d9705a69e883a78d20f130d03b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a3f6230d9705a69e883a78d20f130d03b">idxd_dibound</a> (const int fold, const int N, const double X, const double S)</td></tr>
<tr class="memdesc:a3f6230d9705a69e883a78d20f130d03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indexed double precision summation error bound.  <a href="#a3f6230d9705a69e883a78d20f130d03b">More...</a><br /></td></tr>
<tr class="separator:a3f6230d9705a69e883a78d20f130d03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28085e1a4ae5f3ef0e4807a54c74d05"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ad28085e1a4ae5f3ef0e4807a54c74d05">idxd_sibound</a> (const int fold, const int N, const float X, const float S)</td></tr>
<tr class="memdesc:ad28085e1a4ae5f3ef0e4807a54c74d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indexed single precision summation error bound.  <a href="#ad28085e1a4ae5f3ef0e4807a54c74d05">More...</a><br /></td></tr>
<tr class="separator:ad28085e1a4ae5f3ef0e4807a54c74d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efaee4a926a77d35ac26b732f231437"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a3efaee4a926a77d35ac26b732f231437">idxd_dmbins</a> (const int X)</td></tr>
<tr class="memdesc:a3efaee4a926a77d35ac26b732f231437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indexed double precision reference bins.  <a href="#a3efaee4a926a77d35ac26b732f231437">More...</a><br /></td></tr>
<tr class="separator:a3efaee4a926a77d35ac26b732f231437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a96748531b80145eefd78e9d75d77d5"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a7a96748531b80145eefd78e9d75d77d5">idxd_smbins</a> (const int X)</td></tr>
<tr class="memdesc:a7a96748531b80145eefd78e9d75d77d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indexed single precision reference bins.  <a href="#a7a96748531b80145eefd78e9d75d77d5">More...</a><br /></td></tr>
<tr class="separator:a7a96748531b80145eefd78e9d75d77d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c0a9d1aec80728dc3a92db9fd91a90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ab6c0a9d1aec80728dc3a92db9fd91a90">idxd_dindex</a> (const double X)</td></tr>
<tr class="memdesc:ab6c0a9d1aec80728dc3a92db9fd91a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of double precision.  <a href="#ab6c0a9d1aec80728dc3a92db9fd91a90">More...</a><br /></td></tr>
<tr class="separator:ab6c0a9d1aec80728dc3a92db9fd91a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017fbf0dcfda755ccdf0f03ba722297b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a017fbf0dcfda755ccdf0f03ba722297b">idxd_dmindex</a> (const double *priX)</td></tr>
<tr class="memdesc:a017fbf0dcfda755ccdf0f03ba722297b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of manually specified indexed double precision.  <a href="#a017fbf0dcfda755ccdf0f03ba722297b">More...</a><br /></td></tr>
<tr class="separator:a017fbf0dcfda755ccdf0f03ba722297b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65832bb3dcb75a212687296214a15044"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a65832bb3dcb75a212687296214a15044">idxd_dmindex0</a> (const double *priX)</td></tr>
<tr class="memdesc:a65832bb3dcb75a212687296214a15044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if index of manually specified indexed double precision is 0.  <a href="#a65832bb3dcb75a212687296214a15044">More...</a><br /></td></tr>
<tr class="separator:a65832bb3dcb75a212687296214a15044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb10b31103aeae1cacd16facbace1a73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#abb10b31103aeae1cacd16facbace1a73">idxd_sindex</a> (const float X)</td></tr>
<tr class="memdesc:abb10b31103aeae1cacd16facbace1a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of single precision.  <a href="#abb10b31103aeae1cacd16facbace1a73">More...</a><br /></td></tr>
<tr class="separator:abb10b31103aeae1cacd16facbace1a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ff47f72d68e5bae81bd1a32b11e852"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a55ff47f72d68e5bae81bd1a32b11e852">idxd_smindex</a> (const float *priX)</td></tr>
<tr class="memdesc:a55ff47f72d68e5bae81bd1a32b11e852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of manually specified indexed single precision.  <a href="#a55ff47f72d68e5bae81bd1a32b11e852">More...</a><br /></td></tr>
<tr class="separator:a55ff47f72d68e5bae81bd1a32b11e852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c09c40b4876d1f2a00e26aef10638ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a4c09c40b4876d1f2a00e26aef10638ec">idxd_smindex0</a> (const float *priX)</td></tr>
<tr class="memdesc:a4c09c40b4876d1f2a00e26aef10638ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if index of manually specified indexed single precision is 0.  <a href="#a4c09c40b4876d1f2a00e26aef10638ec">More...</a><br /></td></tr>
<tr class="separator:a4c09c40b4876d1f2a00e26aef10638ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add857b0c710679522a54fa2ce5827cc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#add857b0c710679522a54fa2ce5827cc7">idxd_dmdenorm</a> (const int fold, const double *priX)</td></tr>
<tr class="memdesc:add857b0c710679522a54fa2ce5827cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if indexed type has denormal bits.  <a href="#add857b0c710679522a54fa2ce5827cc7">More...</a><br /></td></tr>
<tr class="separator:add857b0c710679522a54fa2ce5827cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c60873880a1669cbcc44140b6cfc81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ad3c60873880a1669cbcc44140b6cfc81">idxd_zmdenorm</a> (const int fold, const double *priX)</td></tr>
<tr class="memdesc:ad3c60873880a1669cbcc44140b6cfc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if indexed type has denormal bits.  <a href="#ad3c60873880a1669cbcc44140b6cfc81">More...</a><br /></td></tr>
<tr class="separator:ad3c60873880a1669cbcc44140b6cfc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae159635cd8a5ad1ec8ad4a2ea8db7234"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ae159635cd8a5ad1ec8ad4a2ea8db7234">idxd_smdenorm</a> (const int fold, const float *priX)</td></tr>
<tr class="memdesc:ae159635cd8a5ad1ec8ad4a2ea8db7234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if indexed type has denormal bits.  <a href="#ae159635cd8a5ad1ec8ad4a2ea8db7234">More...</a><br /></td></tr>
<tr class="separator:ae159635cd8a5ad1ec8ad4a2ea8db7234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c30e29e3b9c9904b0876d0253e93472"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a6c30e29e3b9c9904b0876d0253e93472">idxd_cmdenorm</a> (const int fold, const float *priX)</td></tr>
<tr class="memdesc:a6c30e29e3b9c9904b0876d0253e93472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if indexed type has denormal bits.  <a href="#a6c30e29e3b9c9904b0876d0253e93472">More...</a><br /></td></tr>
<tr class="separator:a6c30e29e3b9c9904b0876d0253e93472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2913b460745f4c6813cbee68f5439512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a2913b460745f4c6813cbee68f5439512">idxd_diprint</a> (const int fold, const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X)</td></tr>
<tr class="memdesc:a2913b460745f4c6813cbee68f5439512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print indexed double precision.  <a href="#a2913b460745f4c6813cbee68f5439512">More...</a><br /></td></tr>
<tr class="separator:a2913b460745f4c6813cbee68f5439512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9e62f16c2e8f7091bc3714c73f351e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a6a9e62f16c2e8f7091bc3714c73f351e">idxd_dmprint</a> (const int fold, const double *priX, const int incpriX, const double *carX, const int inccarX)</td></tr>
<tr class="memdesc:a6a9e62f16c2e8f7091bc3714c73f351e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print manually specified indexed double precision.  <a href="#a6a9e62f16c2e8f7091bc3714c73f351e">More...</a><br /></td></tr>
<tr class="separator:a6a9e62f16c2e8f7091bc3714c73f351e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15c73871451e36cf45b2a91a42d7f8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#af15c73871451e36cf45b2a91a42d7f8b">idxd_ziprint</a> (const int fold, const <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:af15c73871451e36cf45b2a91a42d7f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print indexed complex double precision.  <a href="#af15c73871451e36cf45b2a91a42d7f8b">More...</a><br /></td></tr>
<tr class="separator:af15c73871451e36cf45b2a91a42d7f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843b5e70d333c1b99c0acb163c687c91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a843b5e70d333c1b99c0acb163c687c91">idxd_zmprint</a> (const int fold, const double *priX, const int incpriX, const double *carX, const int inccarX)</td></tr>
<tr class="memdesc:a843b5e70d333c1b99c0acb163c687c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print manually specified indexed complex double precision.  <a href="#a843b5e70d333c1b99c0acb163c687c91">More...</a><br /></td></tr>
<tr class="separator:a843b5e70d333c1b99c0acb163c687c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6de8e64eeb09f73133a48c0ff73791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a5c6de8e64eeb09f73133a48c0ff73791">idxd_siprint</a> (const int fold, const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X)</td></tr>
<tr class="memdesc:a5c6de8e64eeb09f73133a48c0ff73791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print indexed single precision.  <a href="#a5c6de8e64eeb09f73133a48c0ff73791">More...</a><br /></td></tr>
<tr class="separator:a5c6de8e64eeb09f73133a48c0ff73791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55520000509d1e00635bc2c9c2f53ef4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a55520000509d1e00635bc2c9c2f53ef4">idxd_smprint</a> (const int fold, const float *priX, const int incpriX, const float *carX, const int inccarX)</td></tr>
<tr class="memdesc:a55520000509d1e00635bc2c9c2f53ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print manually specified indexed single precision.  <a href="#a55520000509d1e00635bc2c9c2f53ef4">More...</a><br /></td></tr>
<tr class="separator:a55520000509d1e00635bc2c9c2f53ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34e3a3b0acd6a6a083afcc1ae8e2419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#af34e3a3b0acd6a6a083afcc1ae8e2419">idxd_ciprint</a> (const int fold, const <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:af34e3a3b0acd6a6a083afcc1ae8e2419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print indexed complex single precision.  <a href="#af34e3a3b0acd6a6a083afcc1ae8e2419">More...</a><br /></td></tr>
<tr class="separator:af34e3a3b0acd6a6a083afcc1ae8e2419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c76fa19cf8639bb68aa3b738dd97f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a50c76fa19cf8639bb68aa3b738dd97f1">idxd_cmprint</a> (const int fold, const float *priX, const int incpriX, const float *carX, const int inccarX)</td></tr>
<tr class="memdesc:a50c76fa19cf8639bb68aa3b738dd97f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print manually specified indexed complex single precision.  <a href="#a50c76fa19cf8639bb68aa3b738dd97f1">More...</a><br /></td></tr>
<tr class="separator:a50c76fa19cf8639bb68aa3b738dd97f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019f31b952aafdc6842ea969b932d51d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a019f31b952aafdc6842ea969b932d51d">idxd_didiset</a> (const int fold, const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a019f31b952aafdc6842ea969b932d51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed double precision (Y = X)  <a href="#a019f31b952aafdc6842ea969b932d51d">More...</a><br /></td></tr>
<tr class="separator:a019f31b952aafdc6842ea969b932d51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed20d0034e34898e99683539276f75e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aed20d0034e34898e99683539276f75e6">idxd_dmdmset</a> (const int fold, const double *priX, const int incpriX, const double *carX, const int inccarX, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:aed20d0034e34898e99683539276f75e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manually specified indexed double precision (Y = X)  <a href="#aed20d0034e34898e99683539276f75e6">More...</a><br /></td></tr>
<tr class="separator:aed20d0034e34898e99683539276f75e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b63b32950e129d6374f36745888340b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a1b63b32950e129d6374f36745888340b">idxd_ziziset</a> (const int fold, const <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a1b63b32950e129d6374f36745888340b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed complex double precision (Y = X)  <a href="#a1b63b32950e129d6374f36745888340b">More...</a><br /></td></tr>
<tr class="separator:a1b63b32950e129d6374f36745888340b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08247a9a4c47a967314d66fa90f9ba8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a08247a9a4c47a967314d66fa90f9ba8c">idxd_zmzmset</a> (const int fold, const double *priX, const int incpriX, const double *carX, const int inccarX, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a08247a9a4c47a967314d66fa90f9ba8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manually specified indexed complex double precision (Y = X)  <a href="#a08247a9a4c47a967314d66fa90f9ba8c">More...</a><br /></td></tr>
<tr class="separator:a08247a9a4c47a967314d66fa90f9ba8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b756b69e38153b165814f0666e3be5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a98b756b69e38153b165814f0666e3be5">idxd_zidiset</a> (const int fold, const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a98b756b69e38153b165814f0666e3be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed complex double precision to indexed double precision (Y = X)  <a href="#a98b756b69e38153b165814f0666e3be5">More...</a><br /></td></tr>
<tr class="separator:a98b756b69e38153b165814f0666e3be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dde2d65a3cb527bbed4da0a40af1be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a49dde2d65a3cb527bbed4da0a40af1be">idxd_zmdmset</a> (const int fold, const double *priX, const int incpriX, const double *carX, const int inccarX, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a49dde2d65a3cb527bbed4da0a40af1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manually specified indexed complex double precision to manually specified indexed double precision (Y = X)  <a href="#a49dde2d65a3cb527bbed4da0a40af1be">More...</a><br /></td></tr>
<tr class="separator:a49dde2d65a3cb527bbed4da0a40af1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeade7d3c8e93af5d01a79ac0683b6d49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aeade7d3c8e93af5d01a79ac0683b6d49">idxd_sisiset</a> (const int fold, const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:aeade7d3c8e93af5d01a79ac0683b6d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed single precision (Y = X)  <a href="#aeade7d3c8e93af5d01a79ac0683b6d49">More...</a><br /></td></tr>
<tr class="separator:aeade7d3c8e93af5d01a79ac0683b6d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda5194d0b54726bcaa6b2b662dae3d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#acda5194d0b54726bcaa6b2b662dae3d0">idxd_smsmset</a> (const int fold, const float *priX, const int incpriX, const float *carX, const int inccarX, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:acda5194d0b54726bcaa6b2b662dae3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manually specified indexed single precision (Y = X)  <a href="#acda5194d0b54726bcaa6b2b662dae3d0">More...</a><br /></td></tr>
<tr class="separator:acda5194d0b54726bcaa6b2b662dae3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7208b07dc416f742157ec4ba74e0ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a5f7208b07dc416f742157ec4ba74e0ea">idxd_ciciset</a> (const int fold, const <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a5f7208b07dc416f742157ec4ba74e0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed complex single precision (Y = X)  <a href="#a5f7208b07dc416f742157ec4ba74e0ea">More...</a><br /></td></tr>
<tr class="separator:a5f7208b07dc416f742157ec4ba74e0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3654aecd6e60bfb120c0427b18a8a28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a3654aecd6e60bfb120c0427b18a8a28c">idxd_cmcmset</a> (const int fold, const float *priX, const int incpriX, const float *carX, const int inccarX, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a3654aecd6e60bfb120c0427b18a8a28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manually specified indexed complex single precision (Y = X)  <a href="#a3654aecd6e60bfb120c0427b18a8a28c">More...</a><br /></td></tr>
<tr class="separator:a3654aecd6e60bfb120c0427b18a8a28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddc9510fbc471b65ef28b2e715b2403"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a4ddc9510fbc471b65ef28b2e715b2403">idxd_cisiset</a> (const int fold, const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a4ddc9510fbc471b65ef28b2e715b2403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed complex single precision to indexed single precision (Y = X)  <a href="#a4ddc9510fbc471b65ef28b2e715b2403">More...</a><br /></td></tr>
<tr class="separator:a4ddc9510fbc471b65ef28b2e715b2403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497aee26fd15710f21f8dcb65e05de7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a497aee26fd15710f21f8dcb65e05de7e">idxd_cmsmset</a> (const int fold, const float *priX, const int incpriX, const float *carX, const int inccarX, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a497aee26fd15710f21f8dcb65e05de7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manually specified indexed complex single precision to manually specified indexed single precision (Y = X)  <a href="#a497aee26fd15710f21f8dcb65e05de7e">More...</a><br /></td></tr>
<tr class="separator:a497aee26fd15710f21f8dcb65e05de7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6e4b6df4e3ff2a80ec0b41503d40f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a3e6e4b6df4e3ff2a80ec0b41503d40f8">idxd_disetzero</a> (const int fold, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X)</td></tr>
<tr class="memdesc:a3e6e4b6df4e3ff2a80ec0b41503d40f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed double precision to 0 (X = 0)  <a href="#a3e6e4b6df4e3ff2a80ec0b41503d40f8">More...</a><br /></td></tr>
<tr class="separator:a3e6e4b6df4e3ff2a80ec0b41503d40f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31653ec1c03b945ba8e775e100d97e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#af31653ec1c03b945ba8e775e100d97e5">idxd_dmsetzero</a> (const int fold, double *priX, const int incpriX, double *carX, const int inccarX)</td></tr>
<tr class="memdesc:af31653ec1c03b945ba8e775e100d97e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manually specified indexed double precision to 0 (X = 0)  <a href="#af31653ec1c03b945ba8e775e100d97e5">More...</a><br /></td></tr>
<tr class="separator:af31653ec1c03b945ba8e775e100d97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d14c660b728de39b52e872a5b6b7eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a2d14c660b728de39b52e872a5b6b7eed">idxd_zisetzero</a> (const int fold, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:a2d14c660b728de39b52e872a5b6b7eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed double precision to 0 (X = 0)  <a href="#a2d14c660b728de39b52e872a5b6b7eed">More...</a><br /></td></tr>
<tr class="separator:a2d14c660b728de39b52e872a5b6b7eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42d11afb782fa1b4a39deffbcab0fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#af42d11afb782fa1b4a39deffbcab0fef">idxd_zmsetzero</a> (const int fold, double *priX, const int incpriX, double *carX, const int inccarX)</td></tr>
<tr class="memdesc:af42d11afb782fa1b4a39deffbcab0fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manually specified indexed complex double precision to 0 (X = 0)  <a href="#af42d11afb782fa1b4a39deffbcab0fef">More...</a><br /></td></tr>
<tr class="separator:af42d11afb782fa1b4a39deffbcab0fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6dd2e1bbdd10fc41e2833f2dc4666c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a2a6dd2e1bbdd10fc41e2833f2dc4666c">idxd_sisetzero</a> (const int fold, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X)</td></tr>
<tr class="memdesc:a2a6dd2e1bbdd10fc41e2833f2dc4666c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed single precision to 0 (X = 0)  <a href="#a2a6dd2e1bbdd10fc41e2833f2dc4666c">More...</a><br /></td></tr>
<tr class="separator:a2a6dd2e1bbdd10fc41e2833f2dc4666c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d6077f9fc5069f03f3ef5c83896485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aa6d6077f9fc5069f03f3ef5c83896485">idxd_smsetzero</a> (const int fold, float *priX, const int incpriX, float *carX, const int inccarX)</td></tr>
<tr class="memdesc:aa6d6077f9fc5069f03f3ef5c83896485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manually specified indexed single precision to 0 (X = 0)  <a href="#aa6d6077f9fc5069f03f3ef5c83896485">More...</a><br /></td></tr>
<tr class="separator:aa6d6077f9fc5069f03f3ef5c83896485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d7b2b35b0d8df395b4f4576da1a78f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a33d7b2b35b0d8df395b4f4576da1a78f">idxd_cisetzero</a> (const int fold, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:a33d7b2b35b0d8df395b4f4576da1a78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed single precision to 0 (X = 0)  <a href="#a33d7b2b35b0d8df395b4f4576da1a78f">More...</a><br /></td></tr>
<tr class="separator:a33d7b2b35b0d8df395b4f4576da1a78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2861e73195c1311ef61385815220f645"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a2861e73195c1311ef61385815220f645">idxd_cmsetzero</a> (const int fold, float *priX, const int incpriX, float *carX, const int inccarX)</td></tr>
<tr class="memdesc:a2861e73195c1311ef61385815220f645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manually specified indexed complex single precision to 0 (X = 0)  <a href="#a2861e73195c1311ef61385815220f645">More...</a><br /></td></tr>
<tr class="separator:a2861e73195c1311ef61385815220f645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db2bf533e4a4937a690707b80072f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a8db2bf533e4a4937a690707b80072f80">idxd_didiadd</a> (const int fold, const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a8db2bf533e4a4937a690707b80072f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed double precision (Y += X)  <a href="#a8db2bf533e4a4937a690707b80072f80">More...</a><br /></td></tr>
<tr class="separator:a8db2bf533e4a4937a690707b80072f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f6124ffc2c6c68a463ccf6932725ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a19f6124ffc2c6c68a463ccf6932725ee">idxd_dmdmadd</a> (const int fold, const double *priX, const int incpriX, const double *carX, const int inccarX, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a19f6124ffc2c6c68a463ccf6932725ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add manually specified indexed double precision (Y += X)  <a href="#a19f6124ffc2c6c68a463ccf6932725ee">More...</a><br /></td></tr>
<tr class="separator:a19f6124ffc2c6c68a463ccf6932725ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6973a57392d8378a60a25b8320866678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a6973a57392d8378a60a25b8320866678">idxd_ziziadd</a> (const int fold, const <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a6973a57392d8378a60a25b8320866678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed complex double precision (Y += X)  <a href="#a6973a57392d8378a60a25b8320866678">More...</a><br /></td></tr>
<tr class="separator:a6973a57392d8378a60a25b8320866678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4dd4b9afdabb8d3a17b782ca54a9cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aba4dd4b9afdabb8d3a17b782ca54a9cf">idxd_zmzmadd</a> (const int fold, const double *priX, const int incpriX, const double *carX, const int inccarX, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:aba4dd4b9afdabb8d3a17b782ca54a9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add manually specified indexed complex double precision (Y += X)  <a href="#aba4dd4b9afdabb8d3a17b782ca54a9cf">More...</a><br /></td></tr>
<tr class="separator:aba4dd4b9afdabb8d3a17b782ca54a9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d74ea23b4d608661f460c73a92c7da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a32d74ea23b4d608661f460c73a92c7da">idxd_sisiadd</a> (const int fold, const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a32d74ea23b4d608661f460c73a92c7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed single precision (Y += X)  <a href="#a32d74ea23b4d608661f460c73a92c7da">More...</a><br /></td></tr>
<tr class="separator:a32d74ea23b4d608661f460c73a92c7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2375e0b2166f73e76d324baad474cc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ac2375e0b2166f73e76d324baad474cc2">idxd_smsmadd</a> (const int fold, const float *priX, const int incpriX, const float *carX, const int inccarX, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:ac2375e0b2166f73e76d324baad474cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add manually specified indexed single precision (Y += X)  <a href="#ac2375e0b2166f73e76d324baad474cc2">More...</a><br /></td></tr>
<tr class="separator:ac2375e0b2166f73e76d324baad474cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ab897eb5a50febd5caae0f34e273ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aa8ab897eb5a50febd5caae0f34e273ca">idxd_ciciadd</a> (const int fold, const <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:aa8ab897eb5a50febd5caae0f34e273ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed complex single precision (Y += X)  <a href="#aa8ab897eb5a50febd5caae0f34e273ca">More...</a><br /></td></tr>
<tr class="separator:aa8ab897eb5a50febd5caae0f34e273ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb767eb2ec2b444497b1262e48a74817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#abb767eb2ec2b444497b1262e48a74817">idxd_cmcmadd</a> (const int fold, const float *priX, const int incpriX, const float *carX, const int inccarX, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:abb767eb2ec2b444497b1262e48a74817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add manually specified indexed complex single precision (Y += X)  <a href="#abb767eb2ec2b444497b1262e48a74817">More...</a><br /></td></tr>
<tr class="separator:abb767eb2ec2b444497b1262e48a74817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a75855c6d2eab261d9877210208bc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ac3a75855c6d2eab261d9877210208bc4">idxd_didiaddv</a> (const int fold, const int N, const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X, const int incX, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ac3a75855c6d2eab261d9877210208bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed double precision vectors (Y += X)  <a href="#ac3a75855c6d2eab261d9877210208bc4">More...</a><br /></td></tr>
<tr class="separator:ac3a75855c6d2eab261d9877210208bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2983a74e36f820a2e227deadcdd5ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#add2983a74e36f820a2e227deadcdd5ab">idxd_ziziaddv</a> (const int fold, const int N, const <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X, const int incX, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y, const int incY)</td></tr>
<tr class="memdesc:add2983a74e36f820a2e227deadcdd5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed complex double precision vectors (Y += X)  <a href="#add2983a74e36f820a2e227deadcdd5ab">More...</a><br /></td></tr>
<tr class="separator:add2983a74e36f820a2e227deadcdd5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efa718f061f359b25edc5b43c2a1442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a5efa718f061f359b25edc5b43c2a1442">idxd_sisiaddv</a> (const int fold, const int N, const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X, const int incX, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y, const int incY)</td></tr>
<tr class="memdesc:a5efa718f061f359b25edc5b43c2a1442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed single precision vectors (Y += X)  <a href="#a5efa718f061f359b25edc5b43c2a1442">More...</a><br /></td></tr>
<tr class="separator:a5efa718f061f359b25edc5b43c2a1442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4435c3a6d19f1fb18f8520f627d3d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#acd4435c3a6d19f1fb18f8520f627d3d4">idxd_ciciaddv</a> (const int fold, const int N, const <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X, const int incX, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y, const int incY)</td></tr>
<tr class="memdesc:acd4435c3a6d19f1fb18f8520f627d3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed complex single precision vectors (Y += X)  <a href="#acd4435c3a6d19f1fb18f8520f627d3d4">More...</a><br /></td></tr>
<tr class="separator:acd4435c3a6d19f1fb18f8520f627d3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5639711cf1a2e50ea13050b56129410c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a5639711cf1a2e50ea13050b56129410c">idxd_didadd</a> (const int fold, const double X, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a5639711cf1a2e50ea13050b56129410c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add double precision to indexed double precision (Y += X)  <a href="#a5639711cf1a2e50ea13050b56129410c">More...</a><br /></td></tr>
<tr class="separator:a5639711cf1a2e50ea13050b56129410c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16abbb3f961f89f70100426f14f62f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a16abbb3f961f89f70100426f14f62f5e">idxd_dmdadd</a> (const int fold, const double X, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a16abbb3f961f89f70100426f14f62f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add double precision to manually specified indexed double precision (Y += X)  <a href="#a16abbb3f961f89f70100426f14f62f5e">More...</a><br /></td></tr>
<tr class="separator:a16abbb3f961f89f70100426f14f62f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc8583ba1ea0d05c6e221bf8ea10f22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a6fc8583ba1ea0d05c6e221bf8ea10f22">idxd_zizadd</a> (const int fold, const void *X, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a6fc8583ba1ea0d05c6e221bf8ea10f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex double precision to indexed complex double precision (Y += X)  <a href="#a6fc8583ba1ea0d05c6e221bf8ea10f22">More...</a><br /></td></tr>
<tr class="separator:a6fc8583ba1ea0d05c6e221bf8ea10f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94b572fd9ccdb45f2e1be7f2ff4d41a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ae94b572fd9ccdb45f2e1be7f2ff4d41a">idxd_zmzadd</a> (const int fold, const void *X, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:ae94b572fd9ccdb45f2e1be7f2ff4d41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex double precision to manually specified indexed complex double precision (Y += X)  <a href="#ae94b572fd9ccdb45f2e1be7f2ff4d41a">More...</a><br /></td></tr>
<tr class="separator:ae94b572fd9ccdb45f2e1be7f2ff4d41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5786a8172e2ec67fb969918a9ae3ba5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#af5786a8172e2ec67fb969918a9ae3ba5">idxd_sisadd</a> (const int fold, const float X, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:af5786a8172e2ec67fb969918a9ae3ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add single precision to indexed single precision (Y += X)  <a href="#af5786a8172e2ec67fb969918a9ae3ba5">More...</a><br /></td></tr>
<tr class="separator:af5786a8172e2ec67fb969918a9ae3ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263c280bfb3b5d121dc0b5dab966ba0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a263c280bfb3b5d121dc0b5dab966ba0d">idxd_smsadd</a> (const int fold, const float X, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a263c280bfb3b5d121dc0b5dab966ba0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add single precision to manually specified indexed single precision (Y += X)  <a href="#a263c280bfb3b5d121dc0b5dab966ba0d">More...</a><br /></td></tr>
<tr class="separator:a263c280bfb3b5d121dc0b5dab966ba0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6d61ea6fec11ef022e8abbbfac4f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ade6d61ea6fec11ef022e8abbbfac4f9d">idxd_cicadd</a> (const int fold, const void *X, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:ade6d61ea6fec11ef022e8abbbfac4f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex single precision to indexed complex single precision (Y += X)  <a href="#ade6d61ea6fec11ef022e8abbbfac4f9d">More...</a><br /></td></tr>
<tr class="separator:ade6d61ea6fec11ef022e8abbbfac4f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa97c38da4493377959c6125ecee96bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aaa97c38da4493377959c6125ecee96bf">idxd_cmcadd</a> (const int fold, const void *X, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:aaa97c38da4493377959c6125ecee96bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex single precision to manually specified indexed complex single precision (Y += X)  <a href="#aaa97c38da4493377959c6125ecee96bf">More...</a><br /></td></tr>
<tr class="separator:aaa97c38da4493377959c6125ecee96bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90f93ca0edfccc04ec93b081059545e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ae90f93ca0edfccc04ec93b081059545e">idxd_didupdate</a> (const int fold, const double X, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:ae90f93ca0edfccc04ec93b081059545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed double precision with double precision (X -&gt; Y)  <a href="#ae90f93ca0edfccc04ec93b081059545e">More...</a><br /></td></tr>
<tr class="separator:ae90f93ca0edfccc04ec93b081059545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a0410fc952da965df084d15914e4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ac1a0410fc952da965df084d15914e4e5">idxd_dmdupdate</a> (const int fold, const double X, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:ac1a0410fc952da965df084d15914e4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update manually specified indexed double precision with double precision (X -&gt; Y)  <a href="#ac1a0410fc952da965df084d15914e4e5">More...</a><br /></td></tr>
<tr class="separator:ac1a0410fc952da965df084d15914e4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ce378c13a14814ec314404df63f37d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a96ce378c13a14814ec314404df63f37d">idxd_zizupdate</a> (const int fold, const void *X, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a96ce378c13a14814ec314404df63f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed complex double precision with complex double precision (X -&gt; Y)  <a href="#a96ce378c13a14814ec314404df63f37d">More...</a><br /></td></tr>
<tr class="separator:a96ce378c13a14814ec314404df63f37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fda122da6662aef9cfbf4465ffeeace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a1fda122da6662aef9cfbf4465ffeeace">idxd_zmzupdate</a> (const int fold, const void *X, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a1fda122da6662aef9cfbf4465ffeeace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update manually specified indexed complex double precision with complex double precision (X -&gt; Y)  <a href="#a1fda122da6662aef9cfbf4465ffeeace">More...</a><br /></td></tr>
<tr class="separator:a1fda122da6662aef9cfbf4465ffeeace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace68ff888aaba35fa3ee446ef25a27b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ace68ff888aaba35fa3ee446ef25a27b7">idxd_zidupdate</a> (const int fold, const double X, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:ace68ff888aaba35fa3ee446ef25a27b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed complex double precision with double precision (X -&gt; Y)  <a href="#ace68ff888aaba35fa3ee446ef25a27b7">More...</a><br /></td></tr>
<tr class="separator:ace68ff888aaba35fa3ee446ef25a27b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac359e7b5cee2e61bf3d66b0d5ae67579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ac359e7b5cee2e61bf3d66b0d5ae67579">idxd_zmdupdate</a> (const int fold, const double X, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:ac359e7b5cee2e61bf3d66b0d5ae67579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update manually specified indexed complex double precision with double precision (X -&gt; Y)  <a href="#ac359e7b5cee2e61bf3d66b0d5ae67579">More...</a><br /></td></tr>
<tr class="separator:ac359e7b5cee2e61bf3d66b0d5ae67579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a96a78dfa299c7e19f04389f484eb5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a9a96a78dfa299c7e19f04389f484eb5c">idxd_sisupdate</a> (const int fold, const float X, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a9a96a78dfa299c7e19f04389f484eb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed single precision with single precision (X -&gt; Y)  <a href="#a9a96a78dfa299c7e19f04389f484eb5c">More...</a><br /></td></tr>
<tr class="separator:a9a96a78dfa299c7e19f04389f484eb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aa888bef93b429b6e80783f0ce109f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#af1aa888bef93b429b6e80783f0ce109f">idxd_smsupdate</a> (const int fold, const float X, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:af1aa888bef93b429b6e80783f0ce109f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update manually specified indexed single precision with single precision (X -&gt; Y)  <a href="#af1aa888bef93b429b6e80783f0ce109f">More...</a><br /></td></tr>
<tr class="separator:af1aa888bef93b429b6e80783f0ce109f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf870de8f6c9378ee57fc2617d6c51ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aaf870de8f6c9378ee57fc2617d6c51ca">idxd_cicupdate</a> (const int fold, const void *X, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:aaf870de8f6c9378ee57fc2617d6c51ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed complex single precision with complex single precision (X -&gt; Y)  <a href="#aaf870de8f6c9378ee57fc2617d6c51ca">More...</a><br /></td></tr>
<tr class="separator:aaf870de8f6c9378ee57fc2617d6c51ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f39b6e3fb9beaa23f21d0fc669ac58b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a3f39b6e3fb9beaa23f21d0fc669ac58b">idxd_cmcupdate</a> (const int fold, const void *X, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a3f39b6e3fb9beaa23f21d0fc669ac58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update manually specified indexed complex single precision with complex single precision (X -&gt; Y)  <a href="#a3f39b6e3fb9beaa23f21d0fc669ac58b">More...</a><br /></td></tr>
<tr class="separator:a3f39b6e3fb9beaa23f21d0fc669ac58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6f5822eec69a7c093829f110df5f38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a0a6f5822eec69a7c093829f110df5f38">idxd_cisupdate</a> (const int fold, const float X, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a0a6f5822eec69a7c093829f110df5f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed complex single precision with single precision (X -&gt; Y)  <a href="#a0a6f5822eec69a7c093829f110df5f38">More...</a><br /></td></tr>
<tr class="separator:a0a6f5822eec69a7c093829f110df5f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf2f2f849a2587091822a770baf6f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#addf2f2f849a2587091822a770baf6f9d">idxd_cmsupdate</a> (const int fold, const float X, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:addf2f2f849a2587091822a770baf6f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update manually specified indexed complex single precision with single precision (X -&gt; Y)  <a href="#addf2f2f849a2587091822a770baf6f9d">More...</a><br /></td></tr>
<tr class="separator:addf2f2f849a2587091822a770baf6f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a04918d2bdb8df86e75afcf17885d90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a7a04918d2bdb8df86e75afcf17885d90">idxd_diddeposit</a> (const int fold, const double X, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a7a04918d2bdb8df86e75afcf17885d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add double precision to suitably indexed indexed double precision (Y += X)  <a href="#a7a04918d2bdb8df86e75afcf17885d90">More...</a><br /></td></tr>
<tr class="separator:a7a04918d2bdb8df86e75afcf17885d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634dba0fdbe11da2ed9c3e39ebe20f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a634dba0fdbe11da2ed9c3e39ebe20f5b">idxd_dmddeposit</a> (const int fold, const double X, double *priY, const int incpriY)</td></tr>
<tr class="memdesc:a634dba0fdbe11da2ed9c3e39ebe20f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add double precision to suitably indexed manually specified indexed double precision (Y += X)  <a href="#a634dba0fdbe11da2ed9c3e39ebe20f5b">More...</a><br /></td></tr>
<tr class="separator:a634dba0fdbe11da2ed9c3e39ebe20f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165ff19e68bf6fe24a782e7eb0c09a09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a165ff19e68bf6fe24a782e7eb0c09a09">idxd_zizdeposit</a> (const int fold, const void *X, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a165ff19e68bf6fe24a782e7eb0c09a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex double precision to suitably indexed manually specified indexed complex double precision (Y += X)  <a href="#a165ff19e68bf6fe24a782e7eb0c09a09">More...</a><br /></td></tr>
<tr class="separator:a165ff19e68bf6fe24a782e7eb0c09a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dfc1c52012649396fdbb801a332811"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a46dfc1c52012649396fdbb801a332811">idxd_zmzdeposit</a> (const int fold, const void *X, double *priY, const int incpriY)</td></tr>
<tr class="memdesc:a46dfc1c52012649396fdbb801a332811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex double precision to suitably indexed manually specified indexed complex double precision (Y += X)  <a href="#a46dfc1c52012649396fdbb801a332811">More...</a><br /></td></tr>
<tr class="separator:a46dfc1c52012649396fdbb801a332811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883968ce72d776a634f49d879b4a6fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a883968ce72d776a634f49d879b4a6fa2">idxd_sisdeposit</a> (const int fold, const float X, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a883968ce72d776a634f49d879b4a6fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add single precision to suitably indexed indexed single precision (Y += X)  <a href="#a883968ce72d776a634f49d879b4a6fa2">More...</a><br /></td></tr>
<tr class="separator:a883968ce72d776a634f49d879b4a6fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bbc98b8fbea440f49a59b0670f8467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a36bbc98b8fbea440f49a59b0670f8467">idxd_smsdeposit</a> (const int fold, const float X, float *priY, const int incpriY)</td></tr>
<tr class="memdesc:a36bbc98b8fbea440f49a59b0670f8467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add single precision to suitably indexed manually specified indexed single precision (Y += X)  <a href="#a36bbc98b8fbea440f49a59b0670f8467">More...</a><br /></td></tr>
<tr class="separator:a36bbc98b8fbea440f49a59b0670f8467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe7625671ad85791637c5fc8722eb2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a6fe7625671ad85791637c5fc8722eb2c">idxd_cicdeposit</a> (const int fold, const void *X, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a6fe7625671ad85791637c5fc8722eb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex single precision to suitably indexed manually specified indexed complex single precision (Y += X)  <a href="#a6fe7625671ad85791637c5fc8722eb2c">More...</a><br /></td></tr>
<tr class="separator:a6fe7625671ad85791637c5fc8722eb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b66f8fb6c81368f28df2b9422c396a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ab6b66f8fb6c81368f28df2b9422c396a">idxd_cmcdeposit</a> (const int fold, const void *X, float *priY, const int incpriY)</td></tr>
<tr class="memdesc:ab6b66f8fb6c81368f28df2b9422c396a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex single precision to suitably indexed manually specified indexed complex single precision (Y += X)  <a href="#ab6b66f8fb6c81368f28df2b9422c396a">More...</a><br /></td></tr>
<tr class="separator:ab6b66f8fb6c81368f28df2b9422c396a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d5329660f2474d5756dd42e8fef349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a36d5329660f2474d5756dd42e8fef349">idxd_direnorm</a> (const int fold, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X)</td></tr>
<tr class="memdesc:a36d5329660f2474d5756dd42e8fef349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize indexed double precision.  <a href="#a36d5329660f2474d5756dd42e8fef349">More...</a><br /></td></tr>
<tr class="separator:a36d5329660f2474d5756dd42e8fef349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d5d374cfcb1a3f4107d5714a2056c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a15d5d374cfcb1a3f4107d5714a2056c3">idxd_dmrenorm</a> (const int fold, double *priX, const int incpriX, double *carX, const int inccarX)</td></tr>
<tr class="memdesc:a15d5d374cfcb1a3f4107d5714a2056c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize manually specified indexed double precision.  <a href="#a15d5d374cfcb1a3f4107d5714a2056c3">More...</a><br /></td></tr>
<tr class="separator:a15d5d374cfcb1a3f4107d5714a2056c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eb52319f94a09aabf31dc1e3c03132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a36eb52319f94a09aabf31dc1e3c03132">idxd_zirenorm</a> (const int fold, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:a36eb52319f94a09aabf31dc1e3c03132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize indexed complex double precision.  <a href="#a36eb52319f94a09aabf31dc1e3c03132">More...</a><br /></td></tr>
<tr class="separator:a36eb52319f94a09aabf31dc1e3c03132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2afbb6d853caef22fb899c66a2cc375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ad2afbb6d853caef22fb899c66a2cc375">idxd_zmrenorm</a> (const int fold, double *priX, const int incpriX, double *carX, const int inccarX)</td></tr>
<tr class="memdesc:ad2afbb6d853caef22fb899c66a2cc375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize manually specified indexed complex double precision.  <a href="#ad2afbb6d853caef22fb899c66a2cc375">More...</a><br /></td></tr>
<tr class="separator:ad2afbb6d853caef22fb899c66a2cc375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9867402e91e4191665df1cda4ef74a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ab9867402e91e4191665df1cda4ef74a9">idxd_sirenorm</a> (const int fold, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X)</td></tr>
<tr class="memdesc:ab9867402e91e4191665df1cda4ef74a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize indexed single precision.  <a href="#ab9867402e91e4191665df1cda4ef74a9">More...</a><br /></td></tr>
<tr class="separator:ab9867402e91e4191665df1cda4ef74a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046df958cbf9d161457c5252c834bc16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a046df958cbf9d161457c5252c834bc16">idxd_smrenorm</a> (const int fold, float *priX, const int incpriX, float *carX, const int inccarX)</td></tr>
<tr class="memdesc:a046df958cbf9d161457c5252c834bc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize manually specified indexed single precision.  <a href="#a046df958cbf9d161457c5252c834bc16">More...</a><br /></td></tr>
<tr class="separator:a046df958cbf9d161457c5252c834bc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20725a8d34ae7f8d555a0f6f77b7ebef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a20725a8d34ae7f8d555a0f6f77b7ebef">idxd_cirenorm</a> (const int fold, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:a20725a8d34ae7f8d555a0f6f77b7ebef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize indexed complex single precision.  <a href="#a20725a8d34ae7f8d555a0f6f77b7ebef">More...</a><br /></td></tr>
<tr class="separator:a20725a8d34ae7f8d555a0f6f77b7ebef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7250069ea897c58a9db6190be0f380cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a7250069ea897c58a9db6190be0f380cd">idxd_cmrenorm</a> (const int fold, float *priX, const int incpriX, float *carX, const int inccarX)</td></tr>
<tr class="memdesc:a7250069ea897c58a9db6190be0f380cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize manually specified indexed complex single precision.  <a href="#a7250069ea897c58a9db6190be0f380cd">More...</a><br /></td></tr>
<tr class="separator:a7250069ea897c58a9db6190be0f380cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd5d24db3c103604097abba10c02139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a1fd5d24db3c103604097abba10c02139">idxd_didconv</a> (const int fold, const double X, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a1fd5d24db3c103604097abba10c02139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert double precision to indexed double precision (X -&gt; Y)  <a href="#a1fd5d24db3c103604097abba10c02139">More...</a><br /></td></tr>
<tr class="separator:a1fd5d24db3c103604097abba10c02139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39645e6340a181082b7c1dc077a68ba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a39645e6340a181082b7c1dc077a68ba2">idxd_dmdconv</a> (const int fold, const double X, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a39645e6340a181082b7c1dc077a68ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert double precision to manually specified indexed double precision (X -&gt; Y)  <a href="#a39645e6340a181082b7c1dc077a68ba2">More...</a><br /></td></tr>
<tr class="separator:a39645e6340a181082b7c1dc077a68ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01a44c1b3de5b594e54d4571fc980d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ae01a44c1b3de5b594e54d4571fc980d3">idxd_zizconv</a> (const int fold, const void *X, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:ae01a44c1b3de5b594e54d4571fc980d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert complex double precision to indexed complex double precision (X -&gt; Y)  <a href="#ae01a44c1b3de5b594e54d4571fc980d3">More...</a><br /></td></tr>
<tr class="separator:ae01a44c1b3de5b594e54d4571fc980d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d511561b5c4d6d99b4c7c5667e88f66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a0d511561b5c4d6d99b4c7c5667e88f66">idxd_zmzconv</a> (const int fold, const void *X, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a0d511561b5c4d6d99b4c7c5667e88f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert complex double precision to manually specified indexed complex double precision (X -&gt; Y)  <a href="#a0d511561b5c4d6d99b4c7c5667e88f66">More...</a><br /></td></tr>
<tr class="separator:a0d511561b5c4d6d99b4c7c5667e88f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b3ab9208bfeabe0be5e41bd8b45348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a65b3ab9208bfeabe0be5e41bd8b45348">idxd_sisconv</a> (const int fold, const float X, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a65b3ab9208bfeabe0be5e41bd8b45348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert single precision to indexed single precision (X -&gt; Y)  <a href="#a65b3ab9208bfeabe0be5e41bd8b45348">More...</a><br /></td></tr>
<tr class="separator:a65b3ab9208bfeabe0be5e41bd8b45348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7408dc6c2f2ecb71781958c08a48f0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aa7408dc6c2f2ecb71781958c08a48f0b">idxd_smsconv</a> (const int fold, const float X, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:aa7408dc6c2f2ecb71781958c08a48f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert single precision to manually specified indexed single precision (X -&gt; Y)  <a href="#aa7408dc6c2f2ecb71781958c08a48f0b">More...</a><br /></td></tr>
<tr class="separator:aa7408dc6c2f2ecb71781958c08a48f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1263f2c7c12a6958be9785ffb7736283"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a1263f2c7c12a6958be9785ffb7736283">idxd_cicconv</a> (const int fold, const void *X, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a1263f2c7c12a6958be9785ffb7736283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert complex single precision to indexed complex single precision (X -&gt; Y)  <a href="#a1263f2c7c12a6958be9785ffb7736283">More...</a><br /></td></tr>
<tr class="separator:a1263f2c7c12a6958be9785ffb7736283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab673b9395a0850cee9935ac50f5037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a7ab673b9395a0850cee9935ac50f5037">idxd_cmcconv</a> (const int fold, const void *X, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a7ab673b9395a0850cee9935ac50f5037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert complex single precision to manually specified indexed complex single precision (X -&gt; Y)  <a href="#a7ab673b9395a0850cee9935ac50f5037">More...</a><br /></td></tr>
<tr class="separator:a7ab673b9395a0850cee9935ac50f5037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0899ffa8584be2cdb4d49037bf65ff0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ac0899ffa8584be2cdb4d49037bf65ff0">idxd_ddiconv</a> (const int fold, const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X)</td></tr>
<tr class="memdesc:ac0899ffa8584be2cdb4d49037bf65ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert indexed double precision to double precision (X -&gt; Y)  <a href="#ac0899ffa8584be2cdb4d49037bf65ff0">More...</a><br /></td></tr>
<tr class="separator:ac0899ffa8584be2cdb4d49037bf65ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d9abc752559b5ec7b785fc533a37d8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a54d9abc752559b5ec7b785fc533a37d8">idxd_ddmconv</a> (const int fold, const double *priX, const int incpriX, const double *carX, const int inccarX)</td></tr>
<tr class="memdesc:a54d9abc752559b5ec7b785fc533a37d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert manually specified indexed double precision to double precision (X -&gt; Y)  <a href="#a54d9abc752559b5ec7b785fc533a37d8">More...</a><br /></td></tr>
<tr class="separator:a54d9abc752559b5ec7b785fc533a37d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97eda1a34da202579e4fc46b6ef7fbce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a97eda1a34da202579e4fc46b6ef7fbce">idxd_zziconv_sub</a> (const int fold, const <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X, void *conv)</td></tr>
<tr class="memdesc:a97eda1a34da202579e4fc46b6ef7fbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert indexed complex double precision to complex double precision (X -&gt; Y)  <a href="#a97eda1a34da202579e4fc46b6ef7fbce">More...</a><br /></td></tr>
<tr class="separator:a97eda1a34da202579e4fc46b6ef7fbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3336a5925a0e1e8623abb7bae02c09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a0e3336a5925a0e1e8623abb7bae02c09">idxd_zzmconv_sub</a> (const int fold, const double *priX, const int incpriX, const double *carX, const int inccarX, void *conv)</td></tr>
<tr class="memdesc:a0e3336a5925a0e1e8623abb7bae02c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert manually specified indexed complex double precision to complex double precision (X -&gt; Y)  <a href="#a0e3336a5925a0e1e8623abb7bae02c09">More...</a><br /></td></tr>
<tr class="separator:a0e3336a5925a0e1e8623abb7bae02c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada02fcf4a98d3549ac51edfd04cb8a1e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ada02fcf4a98d3549ac51edfd04cb8a1e">idxd_ssiconv</a> (const int fold, const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X)</td></tr>
<tr class="memdesc:ada02fcf4a98d3549ac51edfd04cb8a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert indexed single precision to single precision (X -&gt; Y)  <a href="#ada02fcf4a98d3549ac51edfd04cb8a1e">More...</a><br /></td></tr>
<tr class="separator:ada02fcf4a98d3549ac51edfd04cb8a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76e290e0ca73305718dadb08010cd6e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aa76e290e0ca73305718dadb08010cd6e">idxd_ssmconv</a> (const int fold, const float *priX, const int incpriX, const float *carX, const int inccarX)</td></tr>
<tr class="memdesc:aa76e290e0ca73305718dadb08010cd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert manually specified indexed single precision to single precision (X -&gt; Y)  <a href="#aa76e290e0ca73305718dadb08010cd6e">More...</a><br /></td></tr>
<tr class="separator:aa76e290e0ca73305718dadb08010cd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8f06d819bbe7a98ed680a40f16bb26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a1a8f06d819bbe7a98ed680a40f16bb26">idxd_cciconv_sub</a> (const int fold, const <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X, void *conv)</td></tr>
<tr class="memdesc:a1a8f06d819bbe7a98ed680a40f16bb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert indexed complex single precision to complex single precision (X -&gt; Y)  <a href="#a1a8f06d819bbe7a98ed680a40f16bb26">More...</a><br /></td></tr>
<tr class="separator:a1a8f06d819bbe7a98ed680a40f16bb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae901c3272e63d182751a9ee1c95792e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ae901c3272e63d182751a9ee1c95792e6">idxd_ccmconv_sub</a> (const int fold, const float *priX, const int incpriX, const float *carX, const int inccarX, void *conv)</td></tr>
<tr class="memdesc:ae901c3272e63d182751a9ee1c95792e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert manually specified indexed complex single precision to complex single precision (X -&gt; Y)  <a href="#ae901c3272e63d182751a9ee1c95792e6">More...</a><br /></td></tr>
<tr class="separator:ae901c3272e63d182751a9ee1c95792e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9899210d9345ed7c2eaa7d6769e7ec44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a9899210d9345ed7c2eaa7d6769e7ec44">idxd_dinegate</a> (const int fold, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X)</td></tr>
<tr class="memdesc:a9899210d9345ed7c2eaa7d6769e7ec44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate indexed double precision (X = -X)  <a href="#a9899210d9345ed7c2eaa7d6769e7ec44">More...</a><br /></td></tr>
<tr class="separator:a9899210d9345ed7c2eaa7d6769e7ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419207cff24c2ee976af7202d4713c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a419207cff24c2ee976af7202d4713c3a">idxd_dmnegate</a> (const int fold, double *priX, const int incpriX, double *carX, const int inccarX)</td></tr>
<tr class="memdesc:a419207cff24c2ee976af7202d4713c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate manually specified indexed double precision (X = -X)  <a href="#a419207cff24c2ee976af7202d4713c3a">More...</a><br /></td></tr>
<tr class="separator:a419207cff24c2ee976af7202d4713c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e97862521ffc231620ccf10f3593e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a4a4e97862521ffc231620ccf10f3593e">idxd_zinegate</a> (const int fold, <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:a4a4e97862521ffc231620ccf10f3593e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate indexed complex double precision (X = -X)  <a href="#a4a4e97862521ffc231620ccf10f3593e">More...</a><br /></td></tr>
<tr class="separator:a4a4e97862521ffc231620ccf10f3593e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be38d6e7edd3e60786749c5eac3742a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a5be38d6e7edd3e60786749c5eac3742a">idxd_zmnegate</a> (const int fold, double *priX, const int incpriX, double *carX, const int inccarX)</td></tr>
<tr class="memdesc:a5be38d6e7edd3e60786749c5eac3742a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate manually specified indexed complex double precision (X = -X)  <a href="#a5be38d6e7edd3e60786749c5eac3742a">More...</a><br /></td></tr>
<tr class="separator:a5be38d6e7edd3e60786749c5eac3742a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af4b53963da2d72ae3ee0285d5959a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a5af4b53963da2d72ae3ee0285d5959a9">idxd_sinegate</a> (const int fold, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X)</td></tr>
<tr class="memdesc:a5af4b53963da2d72ae3ee0285d5959a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate indexed single precision (X = -X)  <a href="#a5af4b53963da2d72ae3ee0285d5959a9">More...</a><br /></td></tr>
<tr class="separator:a5af4b53963da2d72ae3ee0285d5959a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412fa9a0722af31bec56afb4184824b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a412fa9a0722af31bec56afb4184824b0">idxd_smnegate</a> (const int fold, float *priX, const int incpriX, float *carX, const int inccarX)</td></tr>
<tr class="memdesc:a412fa9a0722af31bec56afb4184824b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate manually specified indexed single precision (X = -X)  <a href="#a412fa9a0722af31bec56afb4184824b0">More...</a><br /></td></tr>
<tr class="separator:a412fa9a0722af31bec56afb4184824b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdd13f358a2076f861b2278e23f321f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#abbdd13f358a2076f861b2278e23f321f">idxd_cinegate</a> (const int fold, <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:abbdd13f358a2076f861b2278e23f321f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate indexed complex single precision (X = -X)  <a href="#abbdd13f358a2076f861b2278e23f321f">More...</a><br /></td></tr>
<tr class="separator:abbdd13f358a2076f861b2278e23f321f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f02e15620286f59f647e565a67843d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a7f02e15620286f59f647e565a67843d5">idxd_cmnegate</a> (const int fold, float *priX, const int incpriX, float *carX, const int inccarX)</td></tr>
<tr class="memdesc:a7f02e15620286f59f647e565a67843d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate manually specified indexed complex single precision (X = -X)  <a href="#a7f02e15620286f59f647e565a67843d5">More...</a><br /></td></tr>
<tr class="separator:a7f02e15620286f59f647e565a67843d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba28c49a5d1675e83ffe1180268f18f5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#aba28c49a5d1675e83ffe1180268f18f5">idxd_dscale</a> (const double X)</td></tr>
<tr class="memdesc:aba28c49a5d1675e83ffe1180268f18f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reproducible double precision scale.  <a href="#aba28c49a5d1675e83ffe1180268f18f5">More...</a><br /></td></tr>
<tr class="separator:aba28c49a5d1675e83ffe1180268f18f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4249bdeace36d301f505ba286ea8934"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#af4249bdeace36d301f505ba286ea8934">idxd_sscale</a> (const float X)</td></tr>
<tr class="memdesc:af4249bdeace36d301f505ba286ea8934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reproducible single precision scale.  <a href="#af4249bdeace36d301f505ba286ea8934">More...</a><br /></td></tr>
<tr class="separator:af4249bdeace36d301f505ba286ea8934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561772cee333b169e181d82f4d8f21e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a561772cee333b169e181d82f4d8f21e8">idxd_dmdrescale</a> (const int fold, const double X, const double scaleY, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a561772cee333b169e181d82f4d8f21e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">rescale manually specified indexed double precision sum of squares  <a href="#a561772cee333b169e181d82f4d8f21e8">More...</a><br /></td></tr>
<tr class="separator:a561772cee333b169e181d82f4d8f21e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c5505e52f051a2dc2f87c0c7a311b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a37c5505e52f051a2dc2f87c0c7a311b9">idxd_zmdrescale</a> (const int fold, const double X, const double scaleY, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:a37c5505e52f051a2dc2f87c0c7a311b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">rescale manually specified indexed complex double precision sum of squares  <a href="#a37c5505e52f051a2dc2f87c0c7a311b9">More...</a><br /></td></tr>
<tr class="separator:a37c5505e52f051a2dc2f87c0c7a311b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5ecc561ae9b8432bd5cd8ab67e610d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a5f5ecc561ae9b8432bd5cd8ab67e610d">idxd_smsrescale</a> (const int fold, const float X, const float scaleY, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a5f5ecc561ae9b8432bd5cd8ab67e610d"><td class="mdescLeft">&#160;</td><td class="mdescRight">rescale manually specified indexed single precision sum of squares  <a href="#a5f5ecc561ae9b8432bd5cd8ab67e610d">More...</a><br /></td></tr>
<tr class="separator:a5f5ecc561ae9b8432bd5cd8ab67e610d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d533a13b47b7df961cf82bb180b7832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a4d533a13b47b7df961cf82bb180b7832">idxd_cmsrescale</a> (const int fold, const float X, const float scaleY, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a4d533a13b47b7df961cf82bb180b7832"><td class="mdescLeft">&#160;</td><td class="mdescRight">rescale manually specified indexed complex single precision sum of squares  <a href="#a4d533a13b47b7df961cf82bb180b7832">More...</a><br /></td></tr>
<tr class="separator:a4d533a13b47b7df961cf82bb180b7832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ee453ac4aae02c0c1ab7614bf953aa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ad0ee453ac4aae02c0c1ab7614bf953aa">idxd_dmdmaddsq</a> (const int fold, const double scaleX, const double *priX, const int incpriX, const double *carX, const int inccarX, const double scaleY, double *priY, const int incpriY, double *carY, const int inccarY)</td></tr>
<tr class="memdesc:ad0ee453ac4aae02c0c1ab7614bf953aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add manually specified indexed double precision scaled sums of squares (Y += X)  <a href="#ad0ee453ac4aae02c0c1ab7614bf953aa">More...</a><br /></td></tr>
<tr class="separator:ad0ee453ac4aae02c0c1ab7614bf953aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167fe74d85c6abf232de7f48ae86a987"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a167fe74d85c6abf232de7f48ae86a987">idxd_didiaddsq</a> (const int fold, const double scaleX, const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X, const double scaleY, <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a167fe74d85c6abf232de7f48ae86a987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed double precision scaled sums of squares (Y += X)  <a href="#a167fe74d85c6abf232de7f48ae86a987">More...</a><br /></td></tr>
<tr class="separator:a167fe74d85c6abf232de7f48ae86a987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243570e32f955273a394c21967f41ef1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#a243570e32f955273a394c21967f41ef1">idxd_smsmaddsq</a> (const int fold, const float scaleX, const float *priX, const int incpriX, const float *carX, const int inccarX, const float scaleY, float *priY, const int incpriY, float *carY, const int inccarY)</td></tr>
<tr class="memdesc:a243570e32f955273a394c21967f41ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add manually specified indexed single precision scaled sums of squares (Y += X)  <a href="#a243570e32f955273a394c21967f41ef1">More...</a><br /></td></tr>
<tr class="separator:a243570e32f955273a394c21967f41ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46c405073a2e6a15b7829acde6a0b3f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ae46c405073a2e6a15b7829acde6a0b3f">idxd_sisiaddsq</a> (const int fold, const float scaleX, const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X, const float scaleY, <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:ae46c405073a2e6a15b7829acde6a0b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed single precision scaled sums of squares (Y += X)  <a href="#ae46c405073a2e6a15b7829acde6a0b3f">More...</a><br /></td></tr>
<tr class="separator:ae46c405073a2e6a15b7829acde6a0b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaa289c80c10d3aa4c3edfee459adff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#adeaa289c80c10d3aa4c3edfee459adff">idxd_ufp</a> (const double X)</td></tr>
<tr class="memdesc:adeaa289c80c10d3aa4c3edfee459adff"><td class="mdescLeft">&#160;</td><td class="mdescRight">unit in the first place  <a href="#adeaa289c80c10d3aa4c3edfee459adff">More...</a><br /></td></tr>
<tr class="separator:adeaa289c80c10d3aa4c3edfee459adff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6abd91ad25b9c85d9d4abd70829f132"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="idxd_8h.html#ab6abd91ad25b9c85d9d4abd70829f132">idxd_ufpf</a> (const float X)</td></tr>
<tr class="memdesc:ab6abd91ad25b9c85d9d4abd70829f132"><td class="mdescLeft">&#160;</td><td class="mdescRight">unit in the first place  <a href="#ab6abd91ad25b9c85d9d4abd70829f132">More...</a><br /></td></tr>
<tr class="separator:ab6abd91ad25b9c85d9d4abd70829f132"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="idxd_8h.html" title="idxd.h defines the indexed types and the lower level functions associated with their use...">idxd.h</a> defines the indexed types and the lower level functions associated with their use. </p>
<p>This header is modeled after cblas.h, and as such functions are prefixed with character sets describing the data types they operate upon. For example, the function <code>dfoo</code> would perform the function <code>foo</code> on <code>double</code> possibly returning a <code>double</code>.</p>
<p>If two character sets are prefixed, the first set of characters describes the output and the second the input type. For example, the function <code>dzbar</code> would perform the function <code>bar</code> on <code>double</code> <code>complex</code> and return a <code>double</code>.</p>
<p>Such character sets are listed as follows:</p><ul>
<li>d - double (<code>double</code>)</li>
<li>z - complex double (<code>*void</code>)</li>
<li>s - float (<code>float</code>)</li>
<li>c - complex float (<code>*void</code>)</li>
<li>di - indexed double (<a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a>)</li>
<li>zi - indexed complex double (<a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a>)</li>
<li>si - indexed float (<a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a>)</li>
<li>ci - indexed complex float (<a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a>)</li>
<li>dm - manually specified indexed double (<code>double</code>, <code>double</code>)</li>
<li>zm - manually specified indexed complex double (<code>double</code>, <code>double</code>)</li>
<li>sm - manually specified indexed float (<code>float</code>, <code>float</code>)</li>
<li>cm - manually specified indexed complex float (<code>float</code>, <code>float</code>)</li>
</ul>
<p>Throughout the library, complex types are specified via <code>*void</code> pointers. These routines will sometimes be suffixed by sub, to represent that a function has been made into a subroutine. This allows programmers to use whatever complex types they are already using, as long as the memory pointed to is of the form of two adjacent floating point types, the first and second representing real and imaginary components of the complex number.</p>
<p>The goal of using indexed types is to obtain either more accurate or reproducible summation of floating point numbers. Indexed types are composed of several adjacent bins...</p>
<p>The parameter <code>fold</code> describes how many bins are used in the indexed types supplied to a subroutine. The maximum value for this parameter can be set in config.h. If you are unsure of what value to use for , we recommend 3. Note that the <code>fold</code> of indexed types must be the same for all indexed types that interact with each other. Operations on more than one indexed type assume all indexed types being operated upon have the same <code>fold</code>. Note that the <code>fold</code> of an indexed type may not be changed once the type has been allocated. A common use case would be to set the value of <code>fold</code> as a global macro in your code and supply it to all indexed functions that you use.</p>
<p>Power users of the library may find themselves wanting to manually specify the underlying primary and carry vectors of an indexed type themselves. If you do not know what these are, don't worry about the manually specified indexed types. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a599505844cb962d59e19656425c138e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DIWIDTH&#160;&#160;&#160;40</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed double precision bin width. </p>
<p>bin width (in bits)</p>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ab46dd78091caab74e25a9faa5199ed94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_DICAPACITY&#160;&#160;&#160;(<a class="el" href="idxd_8h.html#a2af954e9bac7c6a6aa4cd03449a7a22a">idxd_DIENDURANCE</a>*(1.0/DBL_EPSILON - 1.0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed double precision capacity. </p>
<p>The maximum number of double precision numbers that can be summed using indexed double precision. Applies also to indexed complex double precision.</p>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a2af954e9bac7c6a6aa4cd03449a7a22a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_DIENDURANCE&#160;&#160;&#160;(1 &lt;&lt; (DBL_MANT_DIG - <a class="el" href="idxd_8h.html#a599505844cb962d59e19656425c138e4">DIWIDTH</a> - 2))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed double precision deposit endurance. </p>
<p>The number of deposits that can be performed before a renorm is necessary. Applies also to indexed complex double precision.</p>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a7782edd0de1008d39f4f9d92816d09b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_DIMAXFOLD&#160;&#160;&#160;(<a class="el" href="idxd_8h.html#a6724376962c17b824208b67d49089b05">idxd_DIMAXINDEX</a> + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum double precision fold supported by the library. </p>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>14 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a6724376962c17b824208b67d49089b05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_DIMAXINDEX&#160;&#160;&#160;(((DBL_MAX_EXP - DBL_MIN_EXP + DBL_MANT_DIG - 1)/<a class="el" href="idxd_8h.html#a599505844cb962d59e19656425c138e4">DIWIDTH</a>) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed double precision maximum index. </p>
<p>maximum index (inclusive)</p>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a09ea8fbab57dae125c1f34eb35eee883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_DMCOMPRESSION&#160;&#160;&#160;(1.0/(1 &lt;&lt; (DBL_MANT_DIG - <a class="el" href="idxd_8h.html#a599505844cb962d59e19656425c138e4">DIWIDTH</a> + 1)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed double precision compression factor. </p>
<p>This factor is used to scale down inputs before deposition into the bin of highest index</p>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a040339c081037d4757f512efd6ccb474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_DMEXPANSION&#160;&#160;&#160;(1.0*(1 &lt;&lt; (DBL_MANT_DIG - <a class="el" href="idxd_8h.html#a599505844cb962d59e19656425c138e4">DIWIDTH</a> + 1)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed double precision expansion factor. </p>
<p>This factor is used to scale up inputs after deposition into the bin of highest index</p>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a40ee6f4d2be2e37ab6bc76f17f582edf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_SICAPACITY&#160;&#160;&#160;(<a class="el" href="idxd_8h.html#a14129e0c6c6bca93e0ed7c521897f794">idxd_SIENDURANCE</a>*(1.0/FLT_EPSILON - 1.0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed single precision capacity. </p>
<p>The maximum number of single precision numbers that can be summed using indexed single precision. Applies also to indexed complex double precision.</p>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a14129e0c6c6bca93e0ed7c521897f794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_SIENDURANCE&#160;&#160;&#160;(1 &lt;&lt; (FLT_MANT_DIG - <a class="el" href="idxd_8h.html#ab413e780857154cb96be6cef85757a6b">SIWIDTH</a> - 2))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed single precision deposit endurance. </p>
<p>The number of deposits that can be performed before a renorm is necessary. Applies also to indexed complex single precision.</p>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a2d8f62d952980e30d30a562688e72e8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_SIMAXFOLD&#160;&#160;&#160;(<a class="el" href="idxd_8h.html#a3a44f683987188a73a727c6505ee7905">idxd_SIMAXINDEX</a> + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum single precision fold supported by the library. </p>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>14 Jan 2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a3a44f683987188a73a727c6505ee7905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_SIMAXINDEX&#160;&#160;&#160;(((FLT_MAX_EXP - FLT_MIN_EXP + FLT_MANT_DIG - 1)/<a class="el" href="idxd_8h.html#ab413e780857154cb96be6cef85757a6b">SIWIDTH</a>) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed single precision maximum index. </p>
<p>maximum index (inclusive)</p>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af198fd6d0c0c989ab612587d3ab0c20a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_SMCOMPRESSION&#160;&#160;&#160;(1.0/(1 &lt;&lt; (FLT_MANT_DIG - <a class="el" href="idxd_8h.html#ab413e780857154cb96be6cef85757a6b">SIWIDTH</a> + 1)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed single precision compression factor. </p>
<p>This factor is used to scale down inputs before deposition into the bin of highest index</p>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="adef77262410180d40f358dee51da820b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define idxd_SMEXPANSION&#160;&#160;&#160;(1.0*(1 &lt;&lt; (FLT_MANT_DIG - <a class="el" href="idxd_8h.html#ab413e780857154cb96be6cef85757a6b">SIWIDTH</a> + 1)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed single precision expansion factor. </p>
<p>This factor is used to scale up inputs after deposition into the bin of highest index</p>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ab413e780857154cb96be6cef85757a6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIWIDTH&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed single precision bin width. </p>
<p>bin width (in bits)</p>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a1f2eabe291f8e4804c5d19c036a62292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indexed complex double datatype. </p>
<p>To allocate a <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a>, call <a class="el" href="idxd_8h.html#ac7767605ef63728d7c6c1e36a3bf01e6" title="indexed complex double precision allocation ">idxd_zialloc()</a></p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a> is, under the hood, an array of <code>double</code>. Therefore, if you have defined an array of <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a>, you must index it by multiplying the index into the array by the number of underlying <code>double</code> that make up the <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a>. This number can be obtained by a call to <a class="el" href="idxd_8h.html#aa1659471f0c0c4258eab0eef398630c0" title="indexed complex double precision size ">idxd_zinum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f97de021a0bed1b84317670c9abd1bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indexed double datatype. </p>
<p>To allocate a <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a>, call <a class="el" href="idxd_8h.html#a373445fc971b41afb130f5c82e180d2b" title="indexed double precision allocation ">idxd_dialloc()</a></p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a> is, under the hood, an array of <code>double</code>. Therefore, if you have defined an array of <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a>, you must index it by multiplying the index into the array by the number of underlying <code>double</code> that make up the <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a>. This number can be obtained by a call to <a class="el" href="idxd_8h.html#a662306c0da0bfeb36d1168bc905fb49d" title="indexed double precision size ">idxd_dinum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a87fb6b6c787120ead562dd4558003b73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indexed complex float datatype. </p>
<p>To allocate a <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a>, call <a class="el" href="idxd_8h.html#a573d283ce7d7d5002fc438b53776d4b7" title="indexed complex single precision allocation ">idxd_cialloc()</a></p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a> is, under the hood, an array of <code>float</code>. Therefore, if you have defined an array of <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a>, you must index it by multiplying the index into the array by the number of underlying <code>float</code> that make up the <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a>. This number can be obtained by a call to <a class="el" href="idxd_8h.html#a47985298aba1e5280026cad2a41867ff" title="indexed complex single precision size ">idxd_cinum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8c164750f0c6d25d7e5e2e15b463965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indexed float datatype. </p>
<p>To allocate a <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a>, call <a class="el" href="idxd_8h.html#ac6c1c90f794bc307a762456965335192" title="indexed single precision allocation ">idxd_sialloc()</a></p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a> is, under the hood, an array of <code>float</code>. Therefore, if you have defined an array of <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a>, you must index it by multiplying the index into the array by the number of underlying <code>float</code> that make up the <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a>. This number can be obtained by a call to <a class="el" href="idxd_8h.html#ab178e152425d62e3f603482ea2fc4066" title="indexed single precision size ">idxd_sinum()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1a8f06d819bbe7a98ed680a40f16bb26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cciconv_sub </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>conv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert indexed complex single precision to complex single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">conv</td><td>scalar return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ae901c3272e63d182751a9ee1c95792e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_ccmconv_sub </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>conv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert manually specified indexed complex single precision to complex single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">conv</td><td>scalar return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a573d283ce7d7d5002fc438b53776d4b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a>* idxd_cialloc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex single precision allocation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a freshly allocated indexed type. (free with <code>free()</code>)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ade6d61ea6fec11ef022e8abbbfac4f9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cicadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex single precision to indexed complex single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a1263f2c7c12a6958be9785ffb7736283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cicconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert complex single precision to indexed complex single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6fe7625671ad85791637c5fc8722eb2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cicdeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex single precision to suitably indexed manually specified indexed complex single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="idxd_8h.html#aaf870de8f6c9378ee57fc2617d6c51ca" title="Update indexed complex single precision with complex single precision (X -> Y) ">idxd_cicupdate()</a> on Y with the maximum absolute value of all future elements you wish to deposit in Y, you can call <a class="el" href="idxd_8h.html#a6fe7625671ad85791637c5fc8722eb2c" title="Add complex single precision to suitably indexed manually specified indexed complex single precision ...">idxd_cicdeposit()</a> to deposit a maximum of <a class="el" href="idxd_8h.html#a14129e0c6c6bca93e0ed7c521897f794" title="Indexed single precision deposit endurance. ">idxd_SIENDURANCE</a> elements into Y before renormalizing Y with <a class="el" href="idxd_8h.html#a20725a8d34ae7f8d555a0f6f77b7ebef" title="Renormalize indexed complex single precision. ">idxd_cirenorm()</a>. After any number of successive calls of <a class="el" href="idxd_8h.html#a6fe7625671ad85791637c5fc8722eb2c" title="Add complex single precision to suitably indexed manually specified indexed complex single precision ...">idxd_cicdeposit()</a> on Y, you must renormalize Y with <a class="el" href="idxd_8h.html#a20725a8d34ae7f8d555a0f6f77b7ebef" title="Renormalize indexed complex single precision. ">idxd_cirenorm()</a> before using any other function on Y.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aa8ab897eb5a50febd5caae0f34e273ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_ciciadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed complex single precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="acd4435c3a6d19f1fb18f8520f627d3d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_ciciaddv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed complex single precision vectors (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>indexed vector X </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed vector Y </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5f7208b07dc416f742157ec4ba74e0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_ciciset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed complex single precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aaf870de8f6c9378ee57fc2617d6c51ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cicupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed complex single precision with complex single precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value of real and imaginary components less than absolute value of real and imaginary components of X respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="abbdd13f358a2076f861b2278e23f321f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cinegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate indexed complex single precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a47985298aba1e5280026cad2a41867ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_cinum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex single precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in <code>float</code>) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af34e3a3b0acd6a6a083afcc1ae8e2419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_ciprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print indexed complex single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a20725a8d34ae7f8d555a0f6f77b7ebef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cirenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize indexed complex single precision. </p>
<p>Renormalization keeps the primary vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a33d7b2b35b0d8df395b4f4576da1a78f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cisetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed single precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a4ddc9510fbc471b65ef28b2e715b2403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cisiset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed complex single precision to indexed single precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af0f6c0bbc21af5b56f15f361c25af231"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t idxd_cisize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex single precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a0a6f5822eec69a7c093829f110df5f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cisupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed complex single precision with single precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aaa97c38da4493377959c6125ecee96bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmcadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex single precision to manually specified indexed complex single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a7ab673b9395a0850cee9935ac50f5037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmcconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert complex single precision to manually specified indexed complex single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ab6b66f8fb6c81368f28df2b9422c396a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmcdeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex single precision to suitably indexed manually specified indexed complex single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="idxd_8h.html#a3f39b6e3fb9beaa23f21d0fc669ac58b" title="Update manually specified indexed complex single precision with complex single precision (X -> Y) ...">idxd_cmcupdate()</a> on Y with the maximum absolute value of all future elements you wish to deposit in Y, you can call <a class="el" href="idxd_8h.html#ab6b66f8fb6c81368f28df2b9422c396a" title="Add complex single precision to suitably indexed manually specified indexed complex single precision ...">idxd_cmcdeposit()</a> to deposit a maximum of <a class="el" href="idxd_8h.html#a14129e0c6c6bca93e0ed7c521897f794" title="Indexed single precision deposit endurance. ">idxd_SIENDURANCE</a> elements into Y before renormalizing Y with <a class="el" href="idxd_8h.html#a7250069ea897c58a9db6190be0f380cd" title="Renormalize manually specified indexed complex single precision. ">idxd_cmrenorm()</a>. After any number of successive calls of <a class="el" href="idxd_8h.html#ab6b66f8fb6c81368f28df2b9422c396a" title="Add complex single precision to suitably indexed manually specified indexed complex single precision ...">idxd_cmcdeposit()</a> on Y, you must renormalize Y with <a class="el" href="idxd_8h.html#a7250069ea897c58a9db6190be0f380cd" title="Renormalize manually specified indexed complex single precision. ">idxd_cmrenorm()</a> before using any other function on Y.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="abb767eb2ec2b444497b1262e48a74817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmcmadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add manually specified indexed complex single precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a3654aecd6e60bfb120c0427b18a8a28c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmcmset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manually specified indexed complex single precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a3f39b6e3fb9beaa23f21d0fc669ac58b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmcupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update manually specified indexed complex single precision with complex single precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value of real and imaginary components less than absolute value of real and imaginary components of X respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6c30e29e3b9c9904b0876d0253e93472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_cmdenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if indexed type has denormal bits. </p>
<p>A quick check to determine if calculations involving X cannot be performed with "denormals are zero"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 if x has denormal bits, 0 otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a7f02e15620286f59f647e565a67843d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmnegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate manually specified indexed complex single precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a50c76fa19cf8639bb68aa3b738dd97f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print manually specified indexed complex single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a7250069ea897c58a9db6190be0f380cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmrenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize manually specified indexed complex single precision. </p>
<p>Renormalization keeps the primary vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a2861e73195c1311ef61385815220f645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmsetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manually specified indexed complex single precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a497aee26fd15710f21f8dcb65e05de7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmsmset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manually specified indexed complex single precision to manually specified indexed single precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a4d533a13b47b7df961cf82bb180b7832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmsrescale </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rescale manually specified indexed complex single precision sum of squares </p>
<p>Rescale an indexed complex single precision sum of squares Y to Y' such that Y / (scaleY * scaleY) == Y' / (X * X) and #idxd_smindex(Y) == <a class="el" href="idxd_8h.html#abb10b31103aeae1cacd16facbace1a73" title="Get index of single precision. ">idxd_sindex</a>(1.0)</p>
<p>Note that Y is assumed to have an index at least the index of 1.0, and that X &gt;= scaleY</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>Y's new scaleY (X == #idxd_sscale(Y) for some <code>float</code> Y) (X &gt;= scaleY) </td></tr>
    <tr><td class="paramname">scaleY</td><td>Y's current scaleY (scaleY == #idxd_sscale(Y) for some <code>float</code> Y) (X &gt;= scaleY) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector (#idxd_smindex(Y) &gt;= <a class="el" href="idxd_8h.html#abb10b31103aeae1cacd16facbace1a73" title="Get index of single precision. ">idxd_sindex</a>(1.0)) </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="addf2f2f849a2587091822a770baf6f9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_cmsupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update manually specified indexed complex single precision with single precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac0899ffa8584be2cdb4d49037bf65ff0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxd_ddiconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert indexed double precision to double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a54d9abc752559b5ec7b785fc533a37d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxd_ddmconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert manually specified indexed double precision to double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>31 Jul 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a373445fc971b41afb130f5c82e180d2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a>* idxd_dialloc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed double precision allocation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a freshly allocated indexed type. (free with <code>free()</code>)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a3f6230d9705a69e883a78d20f130d03b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxd_dibound </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indexed double precision summation error bound. </p>
<p>This is a bound on the absolute error of a summation using indexed types</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>the number of double precision floating point summands </td></tr>
    <tr><td class="paramname">X</td><td>the summand of maximum absolute value </td></tr>
    <tr><td class="paramname">S</td><td>the value of the sum computed using indexed types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error bound</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>31 Jul 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5639711cf1a2e50ea13050b56129410c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_didadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add double precision to indexed double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a1fd5d24db3c103604097abba10c02139"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_didconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert double precision to indexed double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a7a04918d2bdb8df86e75afcf17885d90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_diddeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add double precision to suitably indexed indexed double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="idxd_8h.html#ae90f93ca0edfccc04ec93b081059545e" title="Update indexed double precision with double precision (X -> Y) ">idxd_didupdate()</a> on Y with the maximum absolute value of all future elements you wish to deposit in Y, you can call <a class="el" href="idxd_8h.html#a7a04918d2bdb8df86e75afcf17885d90" title="Add double precision to suitably indexed indexed double precision (Y += X) ">idxd_diddeposit()</a> to deposit a maximum of <a class="el" href="idxd_8h.html#a2af954e9bac7c6a6aa4cd03449a7a22a" title="Indexed double precision deposit endurance. ">idxd_DIENDURANCE</a> elements into Y before renormalizing Y with <a class="el" href="idxd_8h.html#a36d5329660f2474d5756dd42e8fef349" title="Renormalize indexed double precision. ">idxd_direnorm()</a>. After any number of successive calls of <a class="el" href="idxd_8h.html#a7a04918d2bdb8df86e75afcf17885d90" title="Add double precision to suitably indexed indexed double precision (Y += X) ">idxd_diddeposit()</a> on Y, you must renormalize Y with <a class="el" href="idxd_8h.html#a36d5329660f2474d5756dd42e8fef349" title="Renormalize indexed double precision. ">idxd_direnorm()</a> before using any other function on Y.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a8db2bf533e4a4937a690707b80072f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_didiadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed double precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a167fe74d85c6abf232de7f48ae86a987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxd_didiaddsq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed double precision scaled sums of squares (Y += X) </p>
<p>Performs the operation Y += X, where X and Y represent scaled sums of squares.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">scaleX</td><td>scale of X (scaleX == #idxd_dscale(Z) for some <code>double</code> Z) </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">scaleY</td><td>scale of Y (scaleY == #idxd_dscale(Z) for some <code>double</code> Z) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated scale of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2 Dec 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac3a75855c6d2eab261d9877210208bc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_didiaddv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed double precision vectors (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>indexed vector X </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed vector Y </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a019f31b952aafdc6842ea969b932d51d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_didiset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed double precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ae90f93ca0edfccc04ec93b081059545e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_didupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed double precision with double precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ab6c0a9d1aec80728dc3a92db9fd91a90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_dindex </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index of double precision. </p>
<p>The index of a non-indexed type is the smallest index an indexed type would need to have to sum it reproducibly. Higher indicies correspond to smaller bins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X's index</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a9899210d9345ed7c2eaa7d6769e7ec44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dinegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate indexed double precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a662306c0da0bfeb36d1168bc905fb49d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_dinum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed double precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in <code>double</code>) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a2913b460745f4c6813cbee68f5439512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_diprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print indexed double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a36d5329660f2474d5756dd42e8fef349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_direnorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize indexed double precision. </p>
<p>Renormalization keeps the primary vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a3e6e4b6df4e3ff2a80ec0b41503d40f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_disetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed double precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a428c9122898b3a39eca0d17f3e91e748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t idxd_disize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed double precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a3efaee4a926a77d35ac26b732f231437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* idxd_dmbins </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indexed double precision reference bins. </p>
<p>returns a pointer to the bins corresponding to the given index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to constant double precision bins of index X</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a16abbb3f961f89f70100426f14f62f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmdadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add double precision to manually specified indexed double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a39645e6340a181082b7c1dc077a68ba2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmdconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert double precision to manually specified indexed double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>30 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a634dba0fdbe11da2ed9c3e39ebe20f5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmddeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add double precision to suitably indexed manually specified indexed double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="idxd_8h.html#ac1a0410fc952da965df084d15914e4e5" title="Update manually specified indexed double precision with double precision (X -> Y) ...">idxd_dmdupdate()</a> on Y with the maximum absolute value of all future elements you wish to deposit in Y, you can call <a class="el" href="idxd_8h.html#a634dba0fdbe11da2ed9c3e39ebe20f5b" title="Add double precision to suitably indexed manually specified indexed double precision (Y += X) ...">idxd_dmddeposit()</a> to deposit a maximum of <a class="el" href="idxd_8h.html#a2af954e9bac7c6a6aa4cd03449a7a22a" title="Indexed double precision deposit endurance. ">idxd_DIENDURANCE</a> elements into Y before renormalizing Y with <a class="el" href="idxd_8h.html#a15d5d374cfcb1a3f4107d5714a2056c3" title="Renormalize manually specified indexed double precision. ">idxd_dmrenorm()</a>. After any number of successive calls of <a class="el" href="idxd_8h.html#a634dba0fdbe11da2ed9c3e39ebe20f5b" title="Add double precision to suitably indexed manually specified indexed double precision (Y += X) ...">idxd_dmddeposit()</a> on Y, you must renormalize Y with <a class="el" href="idxd_8h.html#a15d5d374cfcb1a3f4107d5714a2056c3" title="Renormalize manually specified indexed double precision. ">idxd_dmrenorm()</a> before using any other function on Y.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="add857b0c710679522a54fa2ce5827cc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_dmdenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if indexed type has denormal bits. </p>
<p>A quick check to determine if calculations involving X cannot be performed with "denormals are zero"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 if x has denormal bits, 0 otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a19f6124ffc2c6c68a463ccf6932725ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmdmadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add manually specified indexed double precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ad0ee453ac4aae02c0c1ab7614bf953aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxd_dmdmaddsq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add manually specified indexed double precision scaled sums of squares (Y += X) </p>
<p>Performs the operation Y += X, where X and Y represent scaled sums of squares.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">scaleX</td><td>scale of X (scaleX == #idxd_dscale(Z) for some <code>double</code> Z) </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">scaleY</td><td>scale of Y (scaleY == #idxd_dscale(Z) for some <code>double</code> Z) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated scale of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>1 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aed20d0034e34898e99683539276f75e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmdmset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manually specified indexed double precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a561772cee333b169e181d82f4d8f21e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmdrescale </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rescale manually specified indexed double precision sum of squares </p>
<p>Rescale an indexed double precision sum of squares Y to Y' such that Y / (scaleY * scaleY) == Y' / (X * X)</p>
<p>Note that Y is assumed to have an index at least the index of 1.0, and that X &gt;= scaleY</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>Y's new scaleY (X == #idxd_dscale(Y) for some <code>double</code> Y) (X &gt;= scaleY) </td></tr>
    <tr><td class="paramname">scaleY</td><td>Y's current scaleY (scaleY == #idxd_dscale(Y) for some <code>double</code> Y) (X &gt;= scaleY) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector (#idxd_dmindex(Y) &gt;= <a class="el" href="idxd_8h.html#ab6c0a9d1aec80728dc3a92db9fd91a90" title="Get index of double precision. ">idxd_dindex</a>(1.0)) </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac1a0410fc952da965df084d15914e4e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmdupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update manually specified indexed double precision with double precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>5 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a017fbf0dcfda755ccdf0f03ba722297b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_dmindex </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index of manually specified indexed double precision. </p>
<p>The index of an indexed type is the bin that it corresponds to. Higher indicies correspond to smaller bins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X's index</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23 Sep 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a65832bb3dcb75a212687296214a15044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_dmindex0 </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if index of manually specified indexed double precision is 0. </p>
<p>A quick check to determine if the index is 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 if x has index 0, 0 otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a419207cff24c2ee976af7202d4713c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmnegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate manually specified indexed double precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6a9e62f16c2e8f7091bc3714c73f351e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print manually specified indexed double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a15d5d374cfcb1a3f4107d5714a2056c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmrenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize manually specified indexed double precision. </p>
<p>Renormalization keeps the primary vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23 Sep 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af31653ec1c03b945ba8e775e100d97e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_dmsetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manually specified indexed double precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aba28c49a5d1675e83ffe1180268f18f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxd_dscale </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reproducible double precision scale. </p>
<p>For a given X, the smallest Y such that #idxd_dindex(X) == #idxd_dindex(Y)</p>
<p>Perhaps the most useful property of this number is that, 1.0 &lt;= X/Y &lt; 2^<a class="el" href="idxd_8h.html#a599505844cb962d59e19656425c138e4" title="Indexed double precision bin width. ">DIWIDTH</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>double precision number to be scaled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reproducible scaling factor</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac6c1c90f794bc307a762456965335192"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a>* idxd_sialloc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed single precision allocation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a freshly allocated indexed type. (free with <code>free()</code>)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ad28085e1a4ae5f3ef0e4807a54c74d05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxd_sibound </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indexed single precision summation error bound. </p>
<p>This is a bound on the absolute error of a summation using indexed types</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>the number of single precision floating point summands </td></tr>
    <tr><td class="paramname">X</td><td>the summand of maximum absolute value </td></tr>
    <tr><td class="paramname">S</td><td>the value of the sum computed using indexed types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error bound</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>31 Jul 2015</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="abb10b31103aeae1cacd16facbace1a73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_sindex </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index of single precision. </p>
<p>The index of a non-indexed type is the smallest index an indexed type would need to have to sum it reproducibly. Higher indicies correspond to smaller bins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X's index</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5af4b53963da2d72ae3ee0285d5959a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_sinegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate indexed single precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ab178e152425d62e3f603482ea2fc4066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_sinum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed single precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in <code>float</code>) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5c6de8e64eeb09f73133a48c0ff73791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_siprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print indexed single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ab9867402e91e4191665df1cda4ef74a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_sirenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize indexed single precision. </p>
<p>Renormalization keeps the primary vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af5786a8172e2ec67fb969918a9ae3ba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_sisadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add single precision to indexed single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a65b3ab9208bfeabe0be5e41bd8b45348"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_sisconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert single precision to indexed single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a883968ce72d776a634f49d879b4a6fa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_sisdeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add single precision to suitably indexed indexed single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="idxd_8h.html#a9a96a78dfa299c7e19f04389f484eb5c" title="Update indexed single precision with single precision (X -> Y) ">idxd_sisupdate()</a> on Y with the maximum absolute value of all future elements you wish to deposit in Y, you can call <a class="el" href="idxd_8h.html#a883968ce72d776a634f49d879b4a6fa2" title="Add single precision to suitably indexed indexed single precision (Y += X) ">idxd_sisdeposit()</a> to deposit a maximum of <a class="el" href="idxd_8h.html#a14129e0c6c6bca93e0ed7c521897f794" title="Indexed single precision deposit endurance. ">idxd_SIENDURANCE</a> elements into Y before renormalizing Y with <a class="el" href="idxd_8h.html#ab9867402e91e4191665df1cda4ef74a9" title="Renormalize indexed single precision. ">idxd_sirenorm()</a>. After any number of successive calls of <a class="el" href="idxd_8h.html#a883968ce72d776a634f49d879b4a6fa2" title="Add single precision to suitably indexed indexed single precision (Y += X) ">idxd_sisdeposit()</a> on Y, you must renormalize Y with <a class="el" href="idxd_8h.html#ab9867402e91e4191665df1cda4ef74a9" title="Renormalize indexed single precision. ">idxd_sirenorm()</a> before using any other function on Y.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a2a6dd2e1bbdd10fc41e2833f2dc4666c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_sisetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed single precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a32d74ea23b4d608661f460c73a92c7da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_sisiadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed single precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ae46c405073a2e6a15b7829acde6a0b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxd_sisiaddsq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed single precision scaled sums of squares (Y += X) </p>
<p>Performs the operation Y += X, where X and Y represent scaled sums of squares.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">scaleX</td><td>scale of X (scaleX == #idxd_sscale(Z) for some <code>float</code> Z) </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">scaleY</td><td>scale of Y (scaleY == #idxd_sscale(Z) for some <code>float</code> Z) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated scale of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2 Dec 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5efa718f061f359b25edc5b43c2a1442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_sisiaddv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed single precision vectors (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>indexed vector X </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed vector Y </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aeade7d3c8e93af5d01a79ac0683b6d49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_sisiset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed single precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a672552f7bbb7ddcf07408022d71abbbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t idxd_sisize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed single precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a9a96a78dfa299c7e19f04389f484eb5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_sisupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed single precision with single precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a7a96748531b80145eefd78e9d75d77d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float* idxd_smbins </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indexed single precision reference bins. </p>
<p>returns a pointer to the bins corresponding to the given index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to constant single precision bins of index X</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ae159635cd8a5ad1ec8ad4a2ea8db7234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_smdenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if indexed type has denormal bits. </p>
<p>A quick check to determine if calculations involving X cannot be performed with "denormals are zero"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 if x has denormal bits, 0 otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a55ff47f72d68e5bae81bd1a32b11e852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_smindex </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index of manually specified indexed single precision. </p>
<p>The index of an indexed type is the bin that it corresponds to. Higher indicies correspond to smaller bins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X's index</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23 Sep 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a4c09c40b4876d1f2a00e26aef10638ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_smindex0 </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if index of manually specified indexed single precision is 0. </p>
<p>A quick check to determine if the index is 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 if x has index 0, 0 otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a412fa9a0722af31bec56afb4184824b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smnegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate manually specified indexed single precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a55520000509d1e00635bc2c9c2f53ef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print manually specified indexed single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a046df958cbf9d161457c5252c834bc16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smrenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize manually specified indexed single precision. </p>
<p>Renormalization keeps the primary vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23 Sep 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a263c280bfb3b5d121dc0b5dab966ba0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smsadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add single precision to manually specified indexed single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aa7408dc6c2f2ecb71781958c08a48f0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smsconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert single precision to manually specified indexed single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>30 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a36bbc98b8fbea440f49a59b0670f8467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smsdeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add single precision to suitably indexed manually specified indexed single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="idxd_8h.html#af1aa888bef93b429b6e80783f0ce109f" title="Update manually specified indexed single precision with single precision (X -> Y) ...">idxd_smsupdate()</a> on Y with the maximum absolute value of all future elements you wish to deposit in Y, you can call <a class="el" href="idxd_8h.html#a36bbc98b8fbea440f49a59b0670f8467" title="Add single precision to suitably indexed manually specified indexed single precision (Y += X) ...">idxd_smsdeposit()</a> to deposit a maximum of <a class="el" href="idxd_8h.html#a14129e0c6c6bca93e0ed7c521897f794" title="Indexed single precision deposit endurance. ">idxd_SIENDURANCE</a> elements into Y before renormalizing Y with <a class="el" href="idxd_8h.html#a046df958cbf9d161457c5252c834bc16" title="Renormalize manually specified indexed single precision. ">idxd_smrenorm()</a>. After any number of successive calls of <a class="el" href="idxd_8h.html#a36bbc98b8fbea440f49a59b0670f8467" title="Add single precision to suitably indexed manually specified indexed single precision (Y += X) ...">idxd_smsdeposit()</a> on Y, you must renormalize Y with <a class="el" href="idxd_8h.html#a046df958cbf9d161457c5252c834bc16" title="Renormalize manually specified indexed single precision. ">idxd_smrenorm()</a> before using any other function on Y.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aa6d6077f9fc5069f03f3ef5c83896485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smsetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manually specified indexed single precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac2375e0b2166f73e76d324baad474cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smsmadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add manually specified indexed single precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a243570e32f955273a394c21967f41ef1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxd_smsmaddsq </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add manually specified indexed single precision scaled sums of squares (Y += X) </p>
<p>Performs the operation Y += X, where X and Y represent scaled sums of squares.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">scaleX</td><td>scale of X (scaleX == #idxd_sscale(Z) for some <code>float</code> Z) </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">scaleY</td><td>scale of Y (scaleY == #idxd_sscale(Z) for some <code>double</code> Z) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated scale of Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>1 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="acda5194d0b54726bcaa6b2b662dae3d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smsmset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manually specified indexed single precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5f5ecc561ae9b8432bd5cd8ab67e610d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smsrescale </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rescale manually specified indexed single precision sum of squares </p>
<p>Rescale an indexed single precision sum of squares Y to Y' such that Y / (scaleY * scaleY) == Y' / (X * X)</p>
<p>Note that Y is assumed to have an index at least the index of 1.0, and that X &gt;= scaleY</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>Y's new scaleY (X == #idxd_sscale(Y) for some <code>float</code> Y) (X &gt;= scaleY) </td></tr>
    <tr><td class="paramname">scaleY</td><td>Y's current scaleY (scaleY == #idxd_sscale(Y) for some <code>float</code> Y) (X &gt;= scaleY) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector (#idxd_smindex(Y) &gt;= <a class="el" href="idxd_8h.html#abb10b31103aeae1cacd16facbace1a73" title="Get index of single precision. ">idxd_sindex</a>(1.0)) </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>1 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af1aa888bef93b429b6e80783f0ce109f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_smsupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update manually specified indexed single precision with single precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>5 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af4249bdeace36d301f505ba286ea8934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxd_sscale </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reproducible single precision scale. </p>
<p>For a given X, the smallest Y such that #idxd_sindex(X) == #idxd_sindex(Y)</p>
<p>Perhaps the most useful property of this number is that if the bin epsilon of X's bin is normalized, 1.0 &lt;= X * (1.0/Y) &lt; 2^<a class="el" href="idxd_8h.html#ab413e780857154cb96be6cef85757a6b" title="Indexed single precision bin width. ">SIWIDTH</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>single precision number to be scaled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reproducible scaling factor</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ada02fcf4a98d3549ac51edfd04cb8a1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxd_ssiconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert indexed single precision to single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aa76e290e0ca73305718dadb08010cd6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxd_ssmconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert manually specified indexed single precision to single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="adeaa289c80c10d3aa4c3edfee459adff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idxd_ufp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unit in the first place </p>
<p>This method returns just the implicit 1 in the mantissa of a <code>double</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unit in the first place</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ab6abd91ad25b9c85d9d4abd70829f132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float idxd_ufpf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unit in the first place </p>
<p>This method returns just the implicit 1 in the mantissa of a <code>float</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unit in the first place</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac7767605ef63728d7c6c1e36a3bf01e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a>* idxd_zialloc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex double precision allocation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a freshly allocated indexed type. (free with <code>free()</code>)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a98b756b69e38153b165814f0666e3be5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zidiset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed complex double precision to indexed double precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ace68ff888aaba35fa3ee446ef25a27b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zidupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed complex double precision with double precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a4a4e97862521ffc231620ccf10f3593e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zinegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate indexed complex double precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aa1659471f0c0c4258eab0eef398630c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_zinum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex double precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in <code>double</code>) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af15c73871451e36cf45b2a91a42d7f8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_ziprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print indexed complex double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a36eb52319f94a09aabf31dc1e3c03132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zirenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize indexed complex double precision. </p>
<p>Renormalization keeps the primary vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a2d14c660b728de39b52e872a5b6b7eed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zisetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed double precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a3d61841683c2970758a02fa90b06029d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t idxd_zisize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex double precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6fc8583ba1ea0d05c6e221bf8ea10f22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zizadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex double precision to indexed complex double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ae01a44c1b3de5b594e54d4571fc980d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zizconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert complex double precision to indexed complex double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a165ff19e68bf6fe24a782e7eb0c09a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zizdeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex double precision to suitably indexed manually specified indexed complex double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="idxd_8h.html#a96ce378c13a14814ec314404df63f37d" title="Update indexed complex double precision with complex double precision (X -> Y) ">idxd_zizupdate()</a> on Y with the maximum absolute value of all future elements you wish to deposit in Y, you can call <a class="el" href="idxd_8h.html#a165ff19e68bf6fe24a782e7eb0c09a09" title="Add complex double precision to suitably indexed manually specified indexed complex double precision ...">idxd_zizdeposit()</a> to deposit a maximum of <a class="el" href="idxd_8h.html#a2af954e9bac7c6a6aa4cd03449a7a22a" title="Indexed double precision deposit endurance. ">idxd_DIENDURANCE</a> elements into Y before renormalizing Y with <a class="el" href="idxd_8h.html#a36eb52319f94a09aabf31dc1e3c03132" title="Renormalize indexed complex double precision. ">idxd_zirenorm()</a>. After any number of successive calls of <a class="el" href="idxd_8h.html#a165ff19e68bf6fe24a782e7eb0c09a09" title="Add complex double precision to suitably indexed manually specified indexed complex double precision ...">idxd_zizdeposit()</a> on Y, you must renormalize Y with <a class="el" href="idxd_8h.html#a36eb52319f94a09aabf31dc1e3c03132" title="Renormalize indexed complex double precision. ">idxd_zirenorm()</a> before using any other function on Y.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6973a57392d8378a60a25b8320866678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_ziziadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed complex double precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="add2983a74e36f820a2e227deadcdd5ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_ziziaddv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed complex double precision vectors (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>vector length </td></tr>
    <tr><td class="paramname">X</td><td>indexed vector X </td></tr>
    <tr><td class="paramname">incX</td><td>X vector stride (use every incX'th element) </td></tr>
    <tr><td class="paramname">Y</td><td>indexed vector Y </td></tr>
    <tr><td class="paramname">incY</td><td>Y vector stride (use every incY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a1b63b32950e129d6374f36745888340b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_ziziset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed complex double precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a96ce378c13a14814ec314404df63f37d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zizupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed complex double precision with complex double precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value of real and imaginary components less than absolute value of real and imaginary components of X respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ad3c60873880a1669cbcc44140b6cfc81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idxd_zmdenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if indexed type has denormal bits. </p>
<p>A quick check to determine if calculations involving X cannot be performed with "denormals are zero"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 if x has denormal bits, 0 otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a49dde2d65a3cb527bbed4da0a40af1be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmdmset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manually specified indexed complex double precision to manually specified indexed double precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a37c5505e52f051a2dc2f87c0c7a311b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmdrescale </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rescale manually specified indexed complex double precision sum of squares </p>
<p>Rescale an indexed complex double precision sum of squares Y to Y' such that Y / (scaleY * scaleY) == Y' / (X * X) and #idxd_dmindex(Y) == <a class="el" href="idxd_8h.html#ab6c0a9d1aec80728dc3a92db9fd91a90" title="Get index of double precision. ">idxd_dindex</a>(1.0)</p>
<p>Note that Y is assumed to have an index at least the the index of 1.0, and that X &gt;= scaleY</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>Y's new scaleY (X == #idxd_dscale(Y) for some <code>double</code> Y) (X &gt;= scaleY) </td></tr>
    <tr><td class="paramname">scaleY</td><td>Y's current scaleY (scaleY == #idxd_dscale(Y) for some <code>double</code> Y) (X &gt;= scaleY) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector (#idxd_dmindex(Y) &gt;= <a class="el" href="idxd_8h.html#ab6c0a9d1aec80728dc3a92db9fd91a90" title="Get index of double precision. ">idxd_dindex</a>(1.0)) </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>1 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac359e7b5cee2e61bf3d66b0d5ae67579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmdupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update manually specified indexed complex double precision with double precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5be38d6e7edd3e60786749c5eac3742a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmnegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate manually specified indexed complex double precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a843b5e70d333c1b99c0acb163c687c91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print manually specified indexed complex double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ad2afbb6d853caef22fb899c66a2cc375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmrenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize manually specified indexed complex double precision. </p>
<p>Renormalization keeps the primary vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af42d11afb782fa1b4a39deffbcab0fef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmsetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manually specified indexed complex double precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ae94b572fd9ccdb45f2e1be7f2ff4d41a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmzadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex double precision to manually specified indexed complex double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a0d511561b5c4d6d99b4c7c5667e88f66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmzconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert complex double precision to manually specified indexed complex double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a46dfc1c52012649396fdbb801a332811"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmzdeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex double precision to suitably indexed manually specified indexed complex double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="idxd_8h.html#a1fda122da6662aef9cfbf4465ffeeace" title="Update manually specified indexed complex double precision with complex double precision (X -> Y) ...">idxd_zmzupdate()</a> on Y with the maximum absolute value of all future elements you wish to deposit in Y, you can call <a class="el" href="idxd_8h.html#a46dfc1c52012649396fdbb801a332811" title="Add complex double precision to suitably indexed manually specified indexed complex double precision ...">idxd_zmzdeposit()</a> to deposit a maximum of <a class="el" href="idxd_8h.html#a2af954e9bac7c6a6aa4cd03449a7a22a" title="Indexed double precision deposit endurance. ">idxd_DIENDURANCE</a> elements into Y before renormalizing Y with <a class="el" href="idxd_8h.html#ad2afbb6d853caef22fb899c66a2cc375" title="Renormalize manually specified indexed complex double precision. ">idxd_zmrenorm()</a>. After any number of successive calls of <a class="el" href="idxd_8h.html#a46dfc1c52012649396fdbb801a332811" title="Add complex double precision to suitably indexed manually specified indexed complex double precision ...">idxd_zmzdeposit()</a> on Y, you must renormalize Y with <a class="el" href="idxd_8h.html#ad2afbb6d853caef22fb899c66a2cc375" title="Renormalize manually specified indexed complex double precision. ">idxd_zmrenorm()</a> before using any other function on Y.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10 Jun 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aba4dd4b9afdabb8d3a17b782ca54a9cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmzmadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add manually specified indexed complex double precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a08247a9a4c47a967314d66fa90f9ba8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmzmset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manually specified indexed complex double precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a1fda122da6662aef9cfbf4465ffeeace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zmzupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>priY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>carY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update manually specified indexed complex double precision with complex double precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value of real and imaginary components less than absolute value of real and imaginary components of X respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">priY</td><td>Y's primary vector </td></tr>
    <tr><td class="paramname">incpriY</td><td>stride within Y's primary vector (use every incpriY'th element) </td></tr>
    <tr><td class="paramname">carY</td><td>Y's carry vector </td></tr>
    <tr><td class="paramname">inccarY</td><td>stride within Y's carry vector (use every inccarY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a97eda1a34da202579e4fc46b6ef7fbce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zziconv_sub </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="idxd_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>conv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert indexed complex double precision to complex double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">conv</td><td>scalar return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a0e3336a5925a0e1e8623abb7bae02c09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idxd_zzmconv_sub </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>priX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incpriX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>carX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>inccarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>conv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert manually specified indexed complex double precision to complex double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">priX</td><td>X's primary vector </td></tr>
    <tr><td class="paramname">incpriX</td><td>stride within X's primary vector (use every incpriX'th element) </td></tr>
    <tr><td class="paramname">carX</td><td>X's carry vector </td></tr>
    <tr><td class="paramname">inccarX</td><td>stride within X's carry vector (use every inccarX'th element) </td></tr>
    <tr><td class="paramname">conv</td><td>scalar return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 18 2016 21:33:12 for ReproBLAS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
