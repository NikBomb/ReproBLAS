\subsection{Update}
    \label{sec:primitiveops_update}
    As noted in Algorithm \ref{alg:deposit}, when adding $x \in \F$ to a $K$-fold
    indexed type $Y$ of index $I$, we make the assumption that $|x| < 2^{b_I}$.
    However, this is not always the case and sometimes it is necessary to adjust the index of $Y$.
    For example, a new indexed type $Y$ is always initialized to have all primary
    and carry fields of 0, therefore prior to adding any non-zero value to $Y$
    it is required to adjust the primary and carry fields of $Y$ first.

    This adjustment is called an \textbf{update}.    
    The process of updating $Y$ to the necessary index is summarized succinctly
    in Algorithm \ref{alg:update}.

    \begin{samepage}
    \begin{alg}
      Update $K$-fold indexed type $Y$ of index $I$ to have an index suitable to deposit $x$.
      \begin{algorithmic}[1]
        \Require
          \Statex ${Y_0}_P$ is 0 or ${Y_0}_P \in (\epsilon^{-1}  2^{a_{I}}, 2  \epsilon^{-1}  2^{a_I})$
        \Function{Update}{K, x, Y}
          \If {x=0}
            \State \Return
          \EndIf
          \State $I$ = \Call{IIndex}{Y}
          \State $J$ = \Call{Index}{x}
          \If{$J < I$}
            \State $[{Y_{\min(I - J, K)}}_P, ..., {Y_{K - 1}}_P] = [{Y_0}_P, ..., {Y_{K - 1 - \min(I - J, K)}}_P]$
            \State $[{Y_0}_P, ..., {Y_{\min(I - J, K) - 1}}_P] = [1.5  \epsilon^{-1}  a_{J}, ..., 1.5  \epsilon^{-1}  a_{\min(I, K + J) - 1}]$
            \State $[{Y_{\min(I - J, K)}}_C, ..., {Y_{K - 1}}_C] = [{Y_0}_C, ..., {Y_{K - 1 - \min(I - J, K)}}_C]$
            \State $[{Y_0}_C, ..., {Y_{\min(I - J, K) - 1}}_C] = [0, ..., 0]$
          \EndIf
        \EndFunction
        \Ensure
          \Statex $Y$ is unchanged if $x = 0$.
            When $x \neq 0$, the bin $(a_{J}, b_{J}]$ satisfies
            $2^{b_{J}} > |x| \geq 2^{a_{J}}$ if $|x| \geq 2^{a_{i_{max}}}$,
            otherwise $J = i_{max}$.
          \Statex The new index of $Y$, ($\min(I, J)$) is such that $2^{b_{\min(I, J)}} > |x|$.
          \Statex Existing accumulators of $Y$ are shifted towards index $0$, losing the lesser bins.
          \Statex New accumulators are shifted into $Y$ with value $0$ in ${Y_k}_C$ and $1.5  \epsilon^{-1}  2^{a_{\min(I, J) + k}}$ in ${Y_k}_P$.
      \end{algorithmic}
      \label{alg:update}
    \end{alg}
    \end{samepage}

    The update operation is described in the ``Update'' Section (lines 7-17) of Algorithm $6$ in \cite{repsum}.

    If $Y$ is the $K$-fold indexed sum of some $x_0, ..., x_{n - 1}$ with index
    $I$, then the shift described by Algorithm \ref{alg:update} produces an
    indexed type of index $J < I$ with the value represented by accumulator $k$
    satisfying
    \begin{equation*}
      \mathcal{Y}_k = \sum\limits_{j = 0}^{n - 1} d(x_j, J + k)
    \end{equation*}

    The new accumulators $Y_k$ with $0 \leq k < I - J$ must represent 0 because
    $x_j < 2^{a_{J + k}} \leq 2^{a_I}$ so
    \(
    	\sum\limits_{j = 0}^{n - 1} d(x_j, J + k) = 0
    \)by Lemma \ref{lem:dzero}.

    It should be noted that if ${Y_0}_P$ is 0, then the update is performed as
    if $I + K < J$. If ${Y_0}_P$ is \texttt{Inf}, \texttt{-Inf}, or
    \texttt{NaN}, then $Y$ is not modified by an update.

    To speed up this operation, the factors $1.5  \epsilon^{-1}  a_j$ for all
    valid $j \in Z$ are stored in a precomputed array.

    It should be noted that if $J$ is such that $J + K > i_{\max}$, then
    ${Y_{i_{\max} - J + 1}}_P, ...,  {Y_{J + K}}_P$ are set to $1.5
    \epsilon^{-1}2^{a_{i_{\max}}}$ and the values in these accumulators are
    ignored.

