\subsection{Update}
    \label{sec:primitiveops_update}
    Sometimes it is necessary to adjust the index of $Y$. For example, in Algorithm \ref{alg:deposit}, when adding $x \in \F$ to a $K$-fold
    indexed type $Y$ of index $I$, we will make the assumption that $|x| < 2^{b_I}$.
    As another example, a new indexed type $Y$ is always initialized to have all primary
    and carry fields set to 0, therefore before adding any non-zero value to $Y$
    it is required to adjust the primary and carry fields of $Y$ first.

    This adjustment is called an \textbf{update}.
    The process of updating $Y$ to the necessary index is summarized succinctly
    in Algorithm \ref{alg:update}. Algorithm \ref{alg:update} is available in ReproBLAS as \texttt{idxd_xixupdate} in \texttt{idxd.h}.

    \begin{samepage}
    \begin{alg}
      Update $K$-fold indexed type $Y$ of index $I$ to have an index $J$ such that $|x| < 2^j$.
      \begin{algorithmic}[1]
        \Require
          \Statex $Y$ is the indexed sum of some $x_0, ..., x_{n - 1} \in \F$
        \Function{Update}{K, x, Y}
          \State $I$ = \Call{IIndex}{Y}
          \State $J$ = \Call{Index}{x}
          \If{$J < I$}
            \State $[{Y_{\min(I - J, K)}}_P, ..., {Y_{K - 1}}_P] = [{Y_0}_P, ..., {Y_{K - 1 - \min(I - J, K)}}_P]$
            \State $[{Y_0}_P, ..., {Y_{\min(I - J, K) - 1}}_P] = [1.5  \epsilon^{-1}  a_{J}, ..., 1.5  \epsilon^{-1}  a_{\min(I, K + J) - 1}]$
            \State $[{Y_{\min(I - J, K)}}_C, ..., {Y_{K - 1}}_C] = [{Y_0}_C, ..., {Y_{K - 1 - \min(I - J, K)}}_C]$
            \State $[{Y_0}_C, ..., {Y_{\min(I - J, K) - 1}}_C] = [0, ..., 0]$
          \EndIf
        \EndFunction
        \Ensure
          \Statex $Y$ has index $J$ where $J$ is the greatest integer such that $|x| < 2^{a_j}$, $\max(|x_j|) < 2^{a_j}$, and $J < i_{\max}$.
          \Statex $\mathcal{Y}_k = \sum\limits_{j = 0}^{n - 1} d(x_j, J + k)$
          \Statex ${Y_k}_P \in \begin{cases}[1.5  \epsilon^{-1} 2^{a_{J + k}}, 1.75  \epsilon^{-1} 2^{a_{J + k}}) \text{ if } I + k > 0 \\ [1.5 \cdot 2^{e_{\max}}, 1.75 \cdot 2^{e_{\max}}) \text{ if } I + k = 0\end{cases}$
      \end{algorithmic}
      \label{alg:update}
    \end{alg}
    \end{samepage}

    The update operation is described in the ``Update'' Section (lines 7-17) of Algorithm $6$ in \cite{repsum}.

    It should be noted that if ${Y_0}_P$ is 0, then the update is performed as
    if $I + K < J$. If ${Y_0}_P$ is \texttt{Inf}, \texttt{-Inf}, or
    \texttt{NaN}, then $Y$ is not modified by an update.
    If $J$ is such that $J + K > i_{\max}$, then
    ${Y_{i_{\max} - J}}_P, ...,  {Y_{K - 1}}_P$ are set to $1.5
    \epsilon^{-1}2^{a_{i_{\max}}}$ and the values in these accumulators are
    ignored.

    If $Y$ represents the indexed sum of finite values, then existing accumulators of $Y$ are shifted towards index $0$, losing the lesser bins. New accumulators are shifted into $Y$ with value $0$ in ${Y_k}_C$ and $1.5  \epsilon^{-1}  2^{a_{\min(I, J) + k}}$ in ${Y_k}_P$.

    The new accumulators $Y_k$ with $0 \leq k < I - J$ must represent 0 because
    $|x_j| < 2^{b_I} \leq a_{I - 1} \leq a_{J + k}$ so
    \(
      \sum\limits_{j = 0}^{n - 1} d(x_j, J + k) = 0
    \) by Lemma \ref{lem:dzero}.

    To speed up this operation, the factors $1.5  \epsilon^{-1}  a_j$ for all
    valid $j \in Z$ are stored in a precomputed array.

