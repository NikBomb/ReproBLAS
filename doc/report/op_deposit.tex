\subsection{Deposit}
    \label{sec:primitiveops_deposit}
    The \textbf{deposit} operation (here referred to as Algorithm \ref{alg:deposit},
    which deals with overflow, unlike a simpler version described in the
    ``Extract $K$ first bins'' Section (lines 18-20) of Algorithm $6$ in
    \cite{repsum}) is used to extract the slices of a floating point number and
    add them to the appropriate accumulators of an indexed type.

    Algorithm \ref{alg:depositrestricted} deposits floating point numbers in
    the case that there is no overflow (the indexed type has an index greater
    than 0).

      \begin{samepage}
      \begin{alg}
        Extract slices of $x \in \F$, where $|x| < 2^{b_I}$, in bins $(a_I,
        b_I], ..., (a_{I + K - 1}, b_{I + K - 1}]$ and add to indexed type $Y$.
        Here, $(r | 1)$ represents the result of setting the last bit of the
        significand ($m_{p - 1}$) of floating point number $r$ to 1. This is a
        restatement of lines 18-20 of Algorithm $6$ in \cite{repsum}.
        \begin{algorithmic}[1]
          \Require
          \Statex No overflow occurs.
          \Statex Operations are performed in some ``to nearest'' rounding mode
          (no specific tie breaking behavior is required).
          \Statex $|x| < 2^{b_I}$.
          \Statex ${Y_k}_P \in (\epsilon^{-1}  2^{a_{I + k}}, 2  \epsilon^{-1}  2^{a_{I + k}})$ at all times.
          (The carry fields ${Y_k}_C$ will be used to ensure this in Algorithm \ref{alg:renorm})
          \Function{DepositRestricted}{K, x, Y}
            \State $r = x$ \label{alg:depositrestricted:rgetsx}
            \For{$k = 0 \To (K - 2)$} \label{alg:depositrestricted:loop}
              \State $S = {Y_k}_P + (r | 1)$ \label{alg:depositrestricted:split}
              \State $q = S - {Y_k}_P$
              \State ${Y_k}_P = S$
              \State $r = r - q$\label{alg:depositrestricted:endsplit}
            \EndFor
            \State ${Y_{K - 1}}_P = {Y_{K - 1}}_P + (r | 1)$
          \EndFunction
          \Ensure
          \Statex The amount added to ${Y_k}_P$ by this algorithm is exactly $d(x, I + k)$.
        \end{algorithmic}
        \label{alg:depositrestricted}
      \end{alg}
      \end{samepage}

      The last bit of $r$ is set to break ties when rounding ``to nearest'' so
      that the amount added to ${Y_k}_P$ does not depend on the size of
      ${Y_k}_P$ so far.
      Algorithm~\ref{alg:depositrestricted} costs $3(K-1)+1=3K-2$ FLOPS,
      not counting the or-bit operation.
      The following theorem proves the ``Ensure'' claim at
      the end of Algorithm \ref{alg:depositrestricted}.

    \begin{samepage}
      \begin{lem}
        Let $Y$ be an $K$-fold indexed type of index $I$. Assume that we run
        Algorithm \ref{alg:depositrestricted} on $Y$ and some $x \in \F$, $|x|
        < 2^{b_I}$. If all requirements of the algorithm are satisfied, then
        the amount added to ${Y_k}_P$ is exactly $d(x, I + k)$.
        \label{lem:ddepositrestricted}
      \end{lem}
    \end{samepage}

      \begin{proof}
        Throughout the proof, assume that the phrase ``for all $k$'' means
        ``for all $k \in \{0, ..., K - 1\}$.'' Assume also that $r_k$ and $S_k$
        refer to the value of $r$ and $S$ after executing line
        \ref{alg:depositrestricted:split} in the $k^{th}$ iteration of the
        loop. Finally, assume ${Y_k}_P$ refers to the initial value of
        ${Y_k}_P$ and $S_k$ refers to the final value of ${Y_k}_P$. Therefore,
        $S_k - {Y_k}_P$ is the amount added to ${Y_k}_P$.

        Note that lines
        \ref{alg:depositrestricted:split}-\ref{alg:depositrestricted:endsplit}
        correspond to Algorithm 4 of \cite{repsum}.  Therefore, if
        $\ulp({Y_k}_P) = \ulp(S_k)$ and $\ulp(r_k) < 0.5\ulp({Y_k}_P)$,
        Corollary 3 of \cite{repsum} applies and we have that
        $S_k - {Y_k}_P \in \ulp({Y_k}_P)\Z \in 2^{a_{I + k} + 1}\Z$
        and that $|r_{k + 1}| \leq 0.5\ulp({Y_k}_P) = 2^{a_{I + k}}$.

        As it is assumed
        ${Y_k}_P, S_k \in (\epsilon^{-1}  2^{a_{I + k}}, 2  \epsilon^{-1}  2^{a_{I + k}})$,
        we have $\ulp(S_k) = \ulp({Y_k}_P)$ for all $k$.

        We show $|r_k| \leq 2^{b_{I + k}} = 2^{a_{I + k - 1}}$ for all $k$ inductively.
        As a base case, $r_0 = x$ (from line \ref{alg:depositrestricted:rgetsx}) so $|r_0| = |x| < 2^{b_{I}}$.
        As an inductive step, assume $|r_k| \leq 2^{b_{I + k}}$. We must show $\ulp(r_k) < 0.5\ulp({Y_k}_P)$.

        By Theorem \ref{thm:underflowufp} we have that ${Y_k}_P$ is normalized
        and therefore $\ulp({Y_k}_P) = 2^{a_{I + k} + 1}$.
        If $r_k$ is normalized, then because 
        \(
            \ulp(r_k) \leq 2^{1 - p}|r_k| \leq 2^{b_{I + k} - (p - 1)} = 2^{a_{I + k} + W - (p - 1)},
        \)
        and $W < p - 2$, we have $\ulp(r_k) \leq 2^{a_{I + k} - 1} < 0.5\ulp({Y_k}_P)$.
        (This case is considered in \cite{repsum}).
        If $r_k$ is denormalized, $\ulp(r_k) = 2^{e_{\min} - p + 1}$
        since the unit in the last place of a denormalized number is always equal to $2^{e_{\min} - p + 1}$.
        Using \eqref{eq:binmin},
        \(
            \ulp(r_k)
                = 2^{e_{\min} - p + 1} \leq 2^{e_{\min} - p + 1 + ((e_{\max} - e_{\min} + p - 1) \mod W)}
                = 2^{a_{i_{\max}} - 1} \leq 2^{a_{I + k} - 1} < 0.5\ulp({Y_k}_P).
        \)

        Therefore we have $\ulp(r_k) < 0.5\ulp({Y_k}_P)$. Thus, Corollary 3 of
        \cite{repsum} applies and we have that $|r_{k + 1}| \leq
        0.5\ulp({Y_k}_P) = 2^{a_{I + k}}$. This completes the induction.

        Next, we show $S_k - {Y_k}_P = \roundtonearestinfty(r_k, a_{I + k} + 1)$.
        As Corollary 3 of \cite{repsum} applies for all $k$, then
        $S_k - {Y_k}_P \in 2^{a_{I + k} + 1}\Z$.
        By Theorem 3 of \cite{repsum}, $r_{k + 1} = r_k - (S_k - {Y_k}_P)$.
        Since $|r_{k + 1}| \leq 2^{a_{I + k}}$, we consider two cases.

        If $|r_k - (S_k - {Y_k}_P)| < 2^{a_{I + k}}$, then
        \(
            S_k - {Y_k}_P = \roundtonearestinfty(r_k, a_{I + k} + 1).
        \)

        If $|r_k - (S_k - {Y_k}_P)| = 2^{a_{I + k}}$, then $S_k - {Y_k}_P \in \{r_k + 2^{a_{I + k}},  r_k - 2^{a_{I + k}}\}$.
        As $S_k = \fl({Y_k}_P + (r_k|1))$, we have $|S_k - {Y_k}_P - (r_k|1)| \leq 0.5\ulp(S_k) = 2^{a_{I + k}}$.  As $\ulp(S_k) = \ulp({Y_k}_P) = 2^{a_{I + k} + 1}$, we also have that $r_k \in 2^{a_{I + k}}\Z$  and because $\ulp(r_k) < 2^{a_{I + k}}$, $|(r_k|1) - r_k| > 0$ (with $(r_k|1) - r_k$ taking the same sign as $r_k$).
        If $r_k > 0$, then $(S_k - {Y_k}_P) = r_k + 2^{a_{I + k}}$ (otherwise we will have $|S_k - {Y_k}_P - (r_k|1)| = |r_k - 2^{a_{I + k}} - (r_k|1)| > 2^{a_{I + k}}$).
        If $r_k < 0$, then $(S_k - {Y_k}_P) = r_k - 2^{a_{I + k}}$ (otherwise we will have $|S_k - {Y_k}_P - (r_k|1)| = |r_k + 2^{a_{I + k}} - (r_k|1)| > 2^{a_{I + k}}$). Therefore, $S_k - {Y_k}_P = \roundtonearestinfty(r_k, a_{I + k} + 1)$.

        We can now show $r_{k + 1} = x - \sum\limits_{i = 0}^{I + k}d(x, i)$ and $S_k - {Y_k}_P = d(x, I + k)$ for all $k$ by induction on $k$.

        In the base case, $S_0 - {Y_0}_P = \roundtonearestinfty(r_0, a_I + 1) = \roundtonearestinfty(x, a_I + 1)$. As $|x| < 2^{b_I}$, Lemma \ref{lem:dmiddle} implies $S_0 - {Y_0}_P = d(x, I)$. By Theorem 3 of \cite{repsum}, $r_1 = r_0 - (S_0 - {Y_0}_P) = x - d(x,I)$. By assumption and  \eqref{eq:a} and \eqref{eq:b}, $|x| < 2^{b_I} \leq 2^{a_{i}}$ for all $i \in \{0, ..., I - 1\}$, and therefore by Lemma \ref{lem:dzero}, $r_1 = x - \sum\limits_{i = 0}^Id(x, i)$.

        In the inductive step, assume $r_{k + 1} = x - \sum\limits_{i = 0}^{I + k}d(x, i)$. Then by definition,

        \begin{equation*}
          S_{k + 1} - {Y_{k + 1}}_P = \roundtonearestinfty(r_{k + 1}, a_{I + k + 1} + 1) = \roundtonearestinfty\bigl(x - \sum\limits_{i = 0}^{I + k}d(x, i), a_{I + k + 1} + 1\bigr) = d(x, I + k + 1)
        \end{equation*}

        And by Theorem 3 of \cite{repsum},
        \begin{equation*}
          r_{k + 2} = r_{k + 1} - (S_{k + 1} - {Y_{k + 1}}_P) = \bigl(x - \sum\limits_{i = 0}^{I + k}d(x, i)\bigr) - d(x, I + k + 1) = x - \sum\limits_{i = 0}^{I + k + 1}d(x, i)
        \end{equation*}
      \end{proof}

      Of course, what remains to be seen is how we can extract and add the
      components of a floating point number to an indexed type $Y$ of index 0,
      i.e. when overflow is an issue. Algorithm \ref{alg:deposit} shows the
      adaptation of Algorithm $\ref{alg:depositrestricted}$ for indexed types
      of index 0. Algorithm \ref{alg:deposit} is available in ReproBLAS as \texttt{idxd\_xixdeposit} in \texttt{idxd.h} (see Section \ref{sec:reproBLAS} for details).

      \begin{samepage}
      \begin{alg}
        Extract components of $x \in \F$, where $|x| < 2^{b_I}$,
        in bins $(a_I,b_I], \ldots, (a_{I + K - 1}, b_{I + K - 1}]$
        and add to indexed type $Y$ of index $I$. Here, $(r | 1)$ represents
        the result of setting the last bit of the significand ($m_{p - 1}$) of
        floating-point $r$ to 1.
        \begin{algorithmic}[1]
          \Require
            \Statex All requirements (except for the absence of overflow, which we will ensure)
            from Algorithm \ref{alg:depositrestricted} except that ${Y_0}_P$
            must now be kept within the range $(2^{e_{\max}}, 2 \cdot 2^{e_{\max}})$ if $Y$ has index 0.
          \Function{Deposit}{K, x, Y}
            \State $I$ = \Call{IIndex}{Y}
            \If{I = 0}
              \State $r = x / 2^{p - W + 1}$ \label{alg:deposit:scaler}
              \State $S = {Y_0}_P + (r | 1)$ \label{alg:deposit:formS}
              \State $q = S - {Y_0}_P$ \label{alg:deposit:formq}
              \State ${Y_0}_P = S$
              \State $q = q \cdot 2^{p - W}$ \label{alg:deposit:scaleq}
              \State $r = x - q$ \label{alg:deposit:formr}
              \State $r = r - q$ \label{alg:deposit:formragain}
              \For{$k = 1 \To (K - 2)$}
                \State $S = {Y_k}_P + (r | 1)$
                \State $q = S - {Y_k}_P$
                \State ${Y_k}_P = S$
                \State $r = r - q$
              \EndFor
              \State ${Y_{K - 1}}_P = {Y_{K - 1}}_P + (r | 1)$
            \Else
              \State\Call{DepositRestricted}{K, x, Y} \label{alg:deposit:callrestricted}
            \EndIf
          \EndFunction
          \Ensure
            \Statex No overflow occurs during the algorithm.
            \Statex The amount added to ${Y_k}_P$ is exactly $d(x, I + k)$ if $I + k \neq 0$.
            \Statex The amount added to ${Y_0}_P$ is exactly $d(x, 0)/2^{p - W + 1}$ if $I = 0$.
        \end{algorithmic}
        \label{alg:deposit}
      \end{alg}
      \end{samepage}

      Algorithm~\ref{alg:deposit} is identical to Algorithm~\ref{alg:depositrestricted} except
      for when the index of $Y$ is $0$, which is rare.
      In that case, the first accumulator $Y_0$ will be scaled by a factor of $2^{W-p-1}$
      so that the value of the first primary field ${Y_0}_P$ stays in the range
      $[2^{e_{max}}, 2 \cdot 2^{e_{max}})$ to avoid overflow.
      The slices corresponding to the first accumulator will also need to be scaled
      by the same factor before being added.
      %Note that if $|x| < 2^{a_0}$ then $d(x,0) = 0$, the deposit process
      %has no effect to the first accumulator.
      %Therefore without loss of generality, we assume here that $|x| \geq$
      Since the scaling is by a power of 2, it does not change any mantissas
      of both the primary field and the input value.
      The binning process as well as the correctness analysis
      are therefore similar to Algorithm~\ref{alg:depositrestricted}.
      If the slice $q$ is scaled back by $2^{p-W+1}$ and subtracted from $x$
      then the rest of the algorithm doesn't change in the absence of overflow.
      However, if $x$ is equal to the biggest value below the overflow threshold,
      then $d(x,0) = 2\cdot 2^{e_{max}}$,
      scaling $q$ back by $2^{p-W+1}$ would cause overflow.
      To handle this special case, instead of scaling $q$ back by $2^{p-W+1}$,
      we only scale $q$ back by $2^{p-W}$ to obtain a value of $d(x,0)/2$
      and perform twice the subtraction $x-q$ to compute $r$.
      Note that if an FMA (Fused-Multiply Adder) is available,
      we would not have to explicitly scale $q$ back,
      one single FMA instruction suffices to compute $r = x - q * 2^{p-W+1}$
      without any overflow.

      In the rare case when the index of $Y$ is 0, Algorithm~\ref{alg:deposit}
      costs $3 * (K-2) + 7 = 3K+1$ FLOPS. Otherwise it has the same cost
      of $3K-2$ FLOPS as Algorithm~\ref{alg:depositrestricted}.
      Theorem \ref{thm:ddeposit} shows that Algorithm \ref{alg:deposit}
      enjoys the necessary properties.

      \begin{samepage}
      \begin{thm}
        Let $Y$ be a $K$-fold indexed type of index $I$. Assume that we run
        Algorithm \ref{alg:deposit} on $Y$ and some $x \in \F$, $|x|<2^{b_I}$.
        If all requirements of the algorithm are satisfied, then the
        ``Ensure'' claim of Algorithm \ref{alg:deposit} holds.
        \label{thm:ddeposit}
      \end{thm}
    \end{samepage}

      \begin{proof}
        \begin{comment}
        We can break the proof into two cases based on the index $I$ of $Y$.

        If $I \neq 0$, then we execute line \ref{alg:deposit:callrestricted}. By  \eqref{eq:b}, $|x| < 2^{b_I} \leq 2^{e_{\max} + 1 - W}$. By Theorem \ref{thm:overflow}, all quantities are obviously well below the overflow threshold and Lemma \ref{lem:ddepositrestricted} applies and we are done.

        If $I = 0$, more work is needed.

        We begin by showing that the amount added to ${Y_0}_P$ ($S - {Y_0}_P$ in line \ref{alg:deposit:formS}) is equal to $\roundtonearestinfty(r, a_0 - p + W)$.

        As $|x| < 2^{b_0} = 2 \cdot 2^{e_{\max}}$ and we scale by a power of two, we have $|r| < 2^{b_0 - p + W - 1} = 2^{e_{\max} - p + W}$ in line \ref{alg:deposit:scaler}.

        Since ${Y_0}_P, S \in (2^{e_{\max}}, 2 \cdot 2^{e_{\max}})$, we have $\ulp({Y_0}_P) = \ulp(S)$ in line \ref{alg:deposit:formS}. As $|r| < 2^{e_{\max} - p + W}$ and $W < p - 2$, we have $\ulp(r) \leq |r| 2^{1 - p} < 2^{e_{\max} + 1 - 2p + W} < 0.5\ulp({Y_0}_P)$ in line \ref{alg:deposit:formS}.

        Because line \ref{alg:deposit:formS} corresponds to lines 1-2 of Algorithm 4 of \cite{repsum}, Corollary 3 of \cite{repsum} applies and we have that $S - {Y_0}_P \in \ulp({Y_0}_P)\Z = 2^{a_0 - p + W}\Z$ and $|r - (S - {Y_0}_P)| \leq 0.5  \ulp({Y_0}_P) = 2^{a_0 - p + W - 1}$ in line \ref{alg:deposit:formS}.

        If $|r - (S - {Y_0}_P)| < 2^{a_{0} - p + W - 1}$, then $S - {Y_k}_P = \roundtonearestinfty(r, a_{0} - p + W)$.

        If $|r - (S - {Y_0}_P)| = 2^{a_{0} - p + W - 1}$, then $S - {Y_0}_P \in \{r + 2^{a_0 - p + W - 1},  r_k - 2^{a_{0} - p + W - 1}\}$.
        As $S = \fl({Y_0}_P + (r|1))$, we have $|S - {Y_0}_P - (r|1)| \leq 0.5\ulp(S) = 2^{a_{0} - p + W - 1}$.  As $\ulp(S) = \ulp({Y_0}_P) = 2^{a_{0} - p + W}$, we also have that $r \in 2^{a_{0} - p + W - 1}\Z$  and because $\ulp(r) < 2^{a_{0} - p + W - 1}$, $|(r|1) - r| > 0$ (with $(r|1) - r$ taking the same sign as $r$).
        If $r > 0$, then $(S - {Y_0}_P) = r + 2^{a_{0} - p + W - 1}$ (otherwise we will have $|S - {Y_0}_P - (r|1)| = |r - 2^{a_{0} - p + W - 1} - (r|1)| > 2^{a_{0} - p + W - 1}$).
        If $r < 0$, then $(S - {Y_0}_P) = r - 2^{a_{0} - p + W}$ (otherwise we will have $|S - {Y_0}_P - (r|1)| = |r + 2^{a_{0} - p + W - 1} - (r|1)| > 2^{a_{0} - p + W - 1}$). Therefore, $S - {Y_0}_P = \roundtonearestinfty(r, a_{0} - p + W)$.

        Next, we show that $S - {Y_0}_P = d(x, 0)/2^{p - W + 1}$.

        We divide into two cases based on the size of $x$.

        If $|x| < 2^{a_0} = 2^{e_{\max} + 1 - W}$, then we have $|r| < 2^{a_0 - p + W - 1}$ in line \ref{alg:deposit:scaler} regardless of whether or not there is underflow in the division as we scale by a power of two.
         Therefore, since $|r| < 2^{a_0 - p + W - 1}$, $S - {Y_0}_P = \roundtonearestinfty(r, a_0 - p + W) = 0 = d(x, 0)/2^{p - W - 1}$ by Lemma \ref{lem:dzero}.

        If $|x| \geq 2^{a_0}= 2^{e_{\max} + 1 - W}$, then there is no underflow in line \ref{alg:deposit:scaler} and $r = x / 2^{p - W + 1}$ exactly as we scale by a power of two. Therefore, $S - {Y_0}_P = \roundtonearestinfty(x/2^{p - W + 1}, a_0 - p + W) = d(x, 0)/2^{p - W + 1}$

        At this point, all that remains to be shown is that $r = x - d(x, 0)$ in line \ref{alg:deposit:formragain}. 
        \end{comment}

        As noted earlier, in order to prove the correctness of Algorithm~\ref{alg:deposit},
        we only need to show that $r = x - d(x, 0)$ in line \ref{alg:deposit:formragain} 
        for the case $\textproc{IIndex}(Y) = 0$.

        In line \ref{alg:deposit:formq}, we have that
        \(
            q = S - {Y_0}_P = d(x,0)/2^{p - W + 1}.
        \)
        By Theorem \ref{thm:dbound}, $d(x, 0) \leq 2 \cdot
        2^{e_{\max}}$. We then have that in line \ref{alg:deposit:scaleq},
        since $q = (d(x, 0)/2^{p - W + 1})2^{p - W} \leq 2^{e_{\max}}$ there is
        no overflow and as we scale by a power of two, $q = d(x, 0)/2$ exactly.
        Again we divide into two cases based on the size of $x$.

        If $|x| < 2^{a_0}$, we have $d(x, 0) = 0$ by Lemma \ref{lem:dzero} and therefore
        $r = x - d(x, 0) = x$ exactly in both line \ref{alg:deposit:formr}
        and line \ref{alg:deposit:formragain}.

        If $|x| \geq 2^{a_0}$, we have $|x - d(x, 0)| \leq 2^{a_0}$ by Theorem \ref{thm:dround}.
        Therefore, we have $|x| \geq |x - d(x, 0)|$. 

        If $x > 0$, we have
        \begin{equation*}
          x \geq x - d(x, 0)/2 \geq x - d(x, 0) \geq -x
        \end{equation*}

         If $x < 0$, we have
        \begin{equation*}
          -x \geq x - d(x, 0) \geq x - d(x, 0)/2 \geq x
        \end{equation*}

        In either case we have $|x - d(x, 0)/2| \leq |x|$.

        Since
        \(
            d(x, 0)/2 = \roundtonearestinfty(x, a_0 + 1)/2 \in 2^{a_0}\Z \in 2\epsilon 2^{b_0}
        \)
        (As $W < p - 2$) and $x \leq 2^{b_0}$, $d(x, 0)/2 \in \ulp(x)\Z$ and
        therefore $x - d(x, 0)/2 \in \ulp(x)\Z$. Combined with $|x - d(x, 0)/2| \leq |x|$
        this implies that $x - d(x, 0)/2$ is representable,
        and that $r=x-q$ exactly in line \ref{alg:deposit:formr}.

        Again since $d(x, 0)/2, x - d(x, 0)/2 \in \ulp(x)\Z$, $x - d(x, 0) \in
        \ulp(x)\Z$ and since $|x - d(x, 0)| \leq |x|$, $x - d(x, 0)$ is
        representable and $r=r-q$ exactly in line \ref{alg:deposit:formragain}.

        At this point, since $r = x - d(x, 0)$ and $|r| \leq 2^{a_0}$, no more
        overflow can occur in the algorithm and since the algorithm at this
        point is identical to Algorithm \ref{alg:depositrestricted}, the proof
        of Lemma \ref{lem:ddepositrestricted} applies.
      \end{proof}

      Modifying Algorithm \ref{alg:deposit} to correctly handle exceptional
      values is easy to implement. At the beginning of Algorithm
      \ref{alg:deposit}, we may simply check $x$ and ${Y_0}_P$ for the
      exceptional values \texttt{Inf}, \texttt{-Inf}, and \texttt{NaN}. If any
      one of $x$ or ${Y_0}_P$ is indeed exceptional, we add $x$ to the
      (possibly finite) ${Y_0}_P$. Otherwise, we deposit the finite value
      normally.

      Note that if we ignore the explicit check for exceptional values,
      even though Algorithm \ref{alg:deposit} does not correctly propagate 
      floating-point exceptions, computed results are still reproducible.
      If any input value is $\pm \texttt{Inf}$, the or-bit operation
      at line 5 of Algorithm~\ref{alg:deposit} will return a \texttt{NaN},
      which in turn will be propagated and results in a \texttt{NaN} value for ${Y_0}_P$.
      It means that if there is any exceptional value in input data,
      the final computed result will be a \texttt{NaN}, which is also reproducible.

      Although checking for exceptional values explicitly is expensive, the
      cost can be reduced if several values are to be summed in the same method.
      We can run a block of summation assuming that there are no exceptional values, and then check at the end of the block if the final computed result is \texttt{NaN}. If it is indeed \texttt{NaN}, we can compute the exceptional result directly, without using any of the primitive operations.
