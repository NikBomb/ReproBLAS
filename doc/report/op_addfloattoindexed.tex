\subsection{Add Float To Indexed}
  \label{sec:primitiveops_addfloattoindexed}
  Algorithm~\ref{alg:addfloattoindexed} allows the user to add a single floating
  point number to an indexed sum. By running this algorithm iteratively on each
  element of a vector, the user can make a naive local sum. However, a more
  efficient summation algorithm is presented in Section \ref{alg:sum}, making this method more useful for small sums or sums where the summands are not gathered into a vector. 
  This method is available in ReproBLAS as \texttt{idxd\_xixadd} in \texttt{idxd.h}

  \begin{alg}
    Add floating point $x_n \in F$ to $K$-fold indexed sum $Y$
    \label{alg:addfloattoindexed}
    \begin{algorithmic}[1]
      \Require
        $Y$ is the indexed sum of $x_0, ..., x_{n - 1} \in F$.
      \Function{Add Float To Indexed}{$K$, $x_n$, $Y$}
        \State \Call{Update}{$K$, $x_n$, $Y$}
        \State \Call{Deposit}{$K$, $x_n$, $Y$}
        \State \Call{Renorm}{$K$, $Y$}
      \EndFunction
      \Ensure
        $Y$ is the indexed sum of $x_0, ..., x_{n}$.
    \end{algorithmic}
  \end{alg}

  The following theorem proves the ``Ensure'' claim at the end of Algorithm~\ref{alg:addfloattoindexed}.
  \begin{thm}
    If $Y$ is the $K$-fold indexed sum of $x_0, ..., x_{n - 1}$, then after
    running Algorithm~\ref{alg:addfloattoindexed} on $Y$ and some $x_n \in \F$,
    $Y$ is the indexed sum of $x_0, ..., x_n$.
    \label{thm:addfloattoindexed}
  \end{thm}

  \begin{proof}
    As $Y$ is the indexed sum of $x_0, ..., x_{n - 1}$, the requirements of the update operation (Algorithm \ref{alg:update}) are satisfied. Therefore, after the update operation completes, we have that the index of $Y$ is the greatest integer $I$ such that for all $j$, $0 \leq j \leq n$, $|x_j| < 2^{b_I}$ and $I \leq i_{\max}$. We also have that 
\[
\mathcal{Y}_k = \sum\limits_{j = 0}^{n - 1} d(x_j, I + k)
\]
  and
  \begin{equation}
          {Y_k}_P \in \begin{cases}[1.5  \epsilon^{-1} 2^{a_{I + k}}, 1.75  \epsilon^{-1} 2^{a_{I + k}}) \text{ if } I + k > 0 \\ [1.5 \cdot 2^{e_{\max}}, 1.75 \cdot 2^{e_{\max}})\text{ otherwise}\end{cases} \label{eq:addfloattoindexedupdatestep}
  \end{equation}
  (Unless ${Y_0}_P$ was \texttt{Inf}, \texttt{-Inf}, or \texttt{NaN} before the update operation, in which case $Y$ was unchanged and is still exceptional)

  Therefore, the requirements of the deposit operation (Algorithm \ref{alg:deposit}) are satisfied and after it is complete, we have that
  \begin{equation}
    \mathcal{Y}_k = \sum\limits_{j = 0}^{n} d(x_j, I + k)
    \label{eq:addfloattoindexedaccumvalue}
  \end{equation}
  (Unless ${Y_0}_P$ was \texttt{Inf}, \texttt{-Inf}, or \texttt{NaN} before the update operation, in which case ${Y_0}_P$ should reflect the correct value. Since the renormalization step does not act on exceptional indexed types, we are done in this case.)

  Finally, since \eqref{eq:addfloattoindexedupdatestep} held before the deposit operation, Theorem \ref{thm:renormfreq} holds and after the 1 deposit (in section \ref{sec:primitiveops_sum} we will use the fact that up to $2^{p - W - 2}$ deposits may be performed here as long as each new $x_j$ is such that $|x_j| < 2^{b_I}$), the requirements of the renormalization operation (Algorithm \ref{alg:renorm}) hold and we have that once again
  \[
  {Y_k}_P \in \begin{cases}[1.5  \epsilon^{-1} 2^{a_{I + k}}, 1.75  \epsilon^{-1} 2^{a_{I + k}}) \text{ if } I + k > 0 \\ [1.5 \cdot 2^{e_{\max}}, 1.75 \cdot 2^{e_{\max}})\text{ otherwise}\end{cases}
  \]
  Since the renormalization step does not affect the values of the accumulators or the index of the indexed type, \eqref{eq:addfloattoindexedaccumvalue} still holds and all of the properties of the indexed sum are satisfied.
  \end{proof}

