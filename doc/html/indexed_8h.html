<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>ReproBLAS: include/indexed.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ReproBLAS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">indexed.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="indexed_8h.html" title="indexed.h defines the indexed types and the lower level functions associated with their use...">indexed.h</a> defines the indexed types and the lower level functions associated with their use.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;complex.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="indexed_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7faa719140c9185b579053769e4a5cdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7faa719140c9185b579053769e4a5cdc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_FOLD</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a7faa719140c9185b579053769e4a5cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4f97de021a0bed1b84317670c9abd1bb"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a></td></tr>
<tr class="memdesc:a4f97de021a0bed1b84317670c9abd1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexed double datatype.  <a href="#a4f97de021a0bed1b84317670c9abd1bb">More...</a><br /></td></tr>
<tr class="separator:a4f97de021a0bed1b84317670c9abd1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2eabe291f8e4804c5d19c036a62292"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a></td></tr>
<tr class="memdesc:a1f2eabe291f8e4804c5d19c036a62292"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexed complex double datatype.  <a href="#a1f2eabe291f8e4804c5d19c036a62292">More...</a><br /></td></tr>
<tr class="separator:a1f2eabe291f8e4804c5d19c036a62292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c164750f0c6d25d7e5e2e15b463965"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a></td></tr>
<tr class="memdesc:ad8c164750f0c6d25d7e5e2e15b463965"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexed float datatype.  <a href="#ad8c164750f0c6d25d7e5e2e15b463965">More...</a><br /></td></tr>
<tr class="separator:ad8c164750f0c6d25d7e5e2e15b463965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fb6b6c787120ead562dd4558003b73"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a></td></tr>
<tr class="memdesc:a87fb6b6c787120ead562dd4558003b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexed complex float datatype.  <a href="#a87fb6b6c787120ead562dd4558003b73">More...</a><br /></td></tr>
<tr class="separator:a87fb6b6c787120ead562dd4558003b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae896eef2aee8dc58532139d773e85cff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ae896eef2aee8dc58532139d773e85cff">disize</a> (const int fold)</td></tr>
<tr class="memdesc:ae896eef2aee8dc58532139d773e85cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed double precision size  <a href="#ae896eef2aee8dc58532139d773e85cff">More...</a><br /></td></tr>
<tr class="separator:ae896eef2aee8dc58532139d773e85cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cccb9dc997e33b361b46be3e8aae98"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a92cccb9dc997e33b361b46be3e8aae98">zisize</a> (const int fold)</td></tr>
<tr class="memdesc:a92cccb9dc997e33b361b46be3e8aae98"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex double precision size  <a href="#a92cccb9dc997e33b361b46be3e8aae98">More...</a><br /></td></tr>
<tr class="separator:a92cccb9dc997e33b361b46be3e8aae98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c245038720cc37de95bfa620dc7e906"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a5c245038720cc37de95bfa620dc7e906">sisize</a> (const int fold)</td></tr>
<tr class="memdesc:a5c245038720cc37de95bfa620dc7e906"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed single precision size  <a href="#a5c245038720cc37de95bfa620dc7e906">More...</a><br /></td></tr>
<tr class="separator:a5c245038720cc37de95bfa620dc7e906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac7f27381307db1968c94e5a96fa7fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#adac7f27381307db1968c94e5a96fa7fa">cisize</a> (const int fold)</td></tr>
<tr class="memdesc:adac7f27381307db1968c94e5a96fa7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex single precision size  <a href="#adac7f27381307db1968c94e5a96fa7fa">More...</a><br /></td></tr>
<tr class="separator:adac7f27381307db1968c94e5a96fa7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2119834f475bb83f1939af4385869325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a2119834f475bb83f1939af4385869325">dialloc</a> (const int fold)</td></tr>
<tr class="memdesc:a2119834f475bb83f1939af4385869325"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed double precision allocation  <a href="#a2119834f475bb83f1939af4385869325">More...</a><br /></td></tr>
<tr class="separator:a2119834f475bb83f1939af4385869325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc21ea822f41d7111d7591135796fd74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#abc21ea822f41d7111d7591135796fd74">zialloc</a> (const int fold)</td></tr>
<tr class="memdesc:abc21ea822f41d7111d7591135796fd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex double precision allocation  <a href="#abc21ea822f41d7111d7591135796fd74">More...</a><br /></td></tr>
<tr class="separator:abc21ea822f41d7111d7591135796fd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a61430e637a195cafd3285e0c926c8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a6a61430e637a195cafd3285e0c926c8c">sialloc</a> (const int fold)</td></tr>
<tr class="memdesc:a6a61430e637a195cafd3285e0c926c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed single precision allocation  <a href="#a6a61430e637a195cafd3285e0c926c8c">More...</a><br /></td></tr>
<tr class="separator:a6a61430e637a195cafd3285e0c926c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1f974593d317482f36873cbd76cb33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#aaf1f974593d317482f36873cbd76cb33">cialloc</a> (const int fold)</td></tr>
<tr class="memdesc:aaf1f974593d317482f36873cbd76cb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex single precision allocation  <a href="#aaf1f974593d317482f36873cbd76cb33">More...</a><br /></td></tr>
<tr class="separator:aaf1f974593d317482f36873cbd76cb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cdde42c1bdaa686436b3d6221a9d48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a60cdde42c1bdaa686436b3d6221a9d48">dinum</a> (const int fold)</td></tr>
<tr class="memdesc:a60cdde42c1bdaa686436b3d6221a9d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed double precision size  <a href="#a60cdde42c1bdaa686436b3d6221a9d48">More...</a><br /></td></tr>
<tr class="separator:a60cdde42c1bdaa686436b3d6221a9d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fd7a628484330c0b728f6ee44aa4f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a36fd7a628484330c0b728f6ee44aa4f3">zinum</a> (const int fold)</td></tr>
<tr class="memdesc:a36fd7a628484330c0b728f6ee44aa4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex double precision size  <a href="#a36fd7a628484330c0b728f6ee44aa4f3">More...</a><br /></td></tr>
<tr class="separator:a36fd7a628484330c0b728f6ee44aa4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556e669781552b914372cf21ba01bf3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a556e669781552b914372cf21ba01bf3a">sinum</a> (const int fold)</td></tr>
<tr class="memdesc:a556e669781552b914372cf21ba01bf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed single precision size  <a href="#a556e669781552b914372cf21ba01bf3a">More...</a><br /></td></tr>
<tr class="separator:a556e669781552b914372cf21ba01bf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91b8b69e0b8d9c349b990bc5f8824e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ad91b8b69e0b8d9c349b990bc5f8824e1">cinum</a> (const int fold)</td></tr>
<tr class="memdesc:ad91b8b69e0b8d9c349b990bc5f8824e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexed complex single precision size  <a href="#ad91b8b69e0b8d9c349b990bc5f8824e1">More...</a><br /></td></tr>
<tr class="separator:ad91b8b69e0b8d9c349b990bc5f8824e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0895d61e99d2053525502a551aac34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ade0895d61e99d2053525502a551aac34">diwidth</a> ()</td></tr>
<tr class="memdesc:ade0895d61e99d2053525502a551aac34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indexed double precision bin width.  <a href="#ade0895d61e99d2053525502a551aac34">More...</a><br /></td></tr>
<tr class="separator:ade0895d61e99d2053525502a551aac34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e73f4f70b3f110697b4a06abb1c28b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a30e73f4f70b3f110697b4a06abb1c28b">siwidth</a> ()</td></tr>
<tr class="memdesc:a30e73f4f70b3f110697b4a06abb1c28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indexed single precision bin width.  <a href="#a30e73f4f70b3f110697b4a06abb1c28b">More...</a><br /></td></tr>
<tr class="separator:a30e73f4f70b3f110697b4a06abb1c28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16324a445b3515349522860502b7e9cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a16324a445b3515349522860502b7e9cd">dicapacity</a> ()</td></tr>
<tr class="memdesc:a16324a445b3515349522860502b7e9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indexed double precision deposit capacity.  <a href="#a16324a445b3515349522860502b7e9cd">More...</a><br /></td></tr>
<tr class="separator:a16324a445b3515349522860502b7e9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace991dae3ae98d13b2c0175469553803"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ace991dae3ae98d13b2c0175469553803">sicapacity</a> ()</td></tr>
<tr class="memdesc:ace991dae3ae98d13b2c0175469553803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indexed single precision deposit capacity.  <a href="#ace991dae3ae98d13b2c0175469553803">More...</a><br /></td></tr>
<tr class="separator:ace991dae3ae98d13b2c0175469553803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2897fc8d49923e6d445939647b59c1e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2897fc8d49923e6d445939647b59c1e2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dmexpansion</b> ()</td></tr>
<tr class="separator:a2897fc8d49923e6d445939647b59c1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1e08ad78dcd6ef117cee286177bf9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a1e08ad78dcd6ef117cee286177bf9b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dmcompression</b> ()</td></tr>
<tr class="separator:a4a1e08ad78dcd6ef117cee286177bf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491f5caaab9ab24ddc5bef11ccffb519"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a491f5caaab9ab24ddc5bef11ccffb519">dibound</a> (const int fold, const int N, const double X)</td></tr>
<tr class="memdesc:a491f5caaab9ab24ddc5bef11ccffb519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indexed double precision summation error bound.  <a href="#a491f5caaab9ab24ddc5bef11ccffb519">More...</a><br /></td></tr>
<tr class="separator:a491f5caaab9ab24ddc5bef11ccffb519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7aeed5b0b5e0faf109b69a66bb85ca0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ac7aeed5b0b5e0faf109b69a66bb85ca0">dbin</a> (const int X)</td></tr>
<tr class="memdesc:ac7aeed5b0b5e0faf109b69a66bb85ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get double precision bin corresponding to index.  <a href="#ac7aeed5b0b5e0faf109b69a66bb85ca0">More...</a><br /></td></tr>
<tr class="separator:ac7aeed5b0b5e0faf109b69a66bb85ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e63cab16d614a5471fa0a35d10c176"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92e63cab16d614a5471fa0a35d10c176"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmbin</b> (const int fold, const int X, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:a92e63cab16d614a5471fa0a35d10c176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84238583da9fae4e259933d230005b23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a84238583da9fae4e259933d230005b23">dindex</a> (const double X)</td></tr>
<tr class="memdesc:a84238583da9fae4e259933d230005b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of double precision.  <a href="#a84238583da9fae4e259933d230005b23">More...</a><br /></td></tr>
<tr class="separator:a84238583da9fae4e259933d230005b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087b2934a43df2101170a6070958add3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a087b2934a43df2101170a6070958add3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dmindex</b> (const double *manX)</td></tr>
<tr class="separator:a087b2934a43df2101170a6070958add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71974f5ef0fd9eea451eaee29ce9518"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab71974f5ef0fd9eea451eaee29ce9518"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>smexpansion</b> ()</td></tr>
<tr class="separator:ab71974f5ef0fd9eea451eaee29ce9518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dbb8eb23ef65d955448268a5cb6b8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1dbb8eb23ef65d955448268a5cb6b8d"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>smcompression</b> ()</td></tr>
<tr class="separator:aa1dbb8eb23ef65d955448268a5cb6b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc79ca843eb563aee215f836168fa0a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a3dc79ca843eb563aee215f836168fa0a">sibound</a> (const int fold, const int N, const float X)</td></tr>
<tr class="memdesc:a3dc79ca843eb563aee215f836168fa0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indexed single precision summation error bound.  <a href="#a3dc79ca843eb563aee215f836168fa0a">More...</a><br /></td></tr>
<tr class="separator:a3dc79ca843eb563aee215f836168fa0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf7b5dc36d90d75b67edd66e3e77b69"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a5cf7b5dc36d90d75b67edd66e3e77b69">sbin</a> (const int X)</td></tr>
<tr class="memdesc:a5cf7b5dc36d90d75b67edd66e3e77b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get single precision bin corresponding to index.  <a href="#a5cf7b5dc36d90d75b67edd66e3e77b69">More...</a><br /></td></tr>
<tr class="separator:a5cf7b5dc36d90d75b67edd66e3e77b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa703a07e226e479aa247d8e7c5210c25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa703a07e226e479aa247d8e7c5210c25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smbin</b> (const int fold, const int X, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:aa703a07e226e479aa247d8e7c5210c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9153c546d18df2c48409181a80034c42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a9153c546d18df2c48409181a80034c42">sindex</a> (const float X)</td></tr>
<tr class="memdesc:a9153c546d18df2c48409181a80034c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of single precision.  <a href="#a9153c546d18df2c48409181a80034c42">More...</a><br /></td></tr>
<tr class="separator:a9153c546d18df2c48409181a80034c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bc849103e0654f1ea766d8152aea4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78bc849103e0654f1ea766d8152aea4a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>smindex</b> (const float *manX)</td></tr>
<tr class="separator:a78bc849103e0654f1ea766d8152aea4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457a3b8acbc742628430857bf1d7a737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a457a3b8acbc742628430857bf1d7a737">ciprint</a> (const int fold, const <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:a457a3b8acbc742628430857bf1d7a737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print indexed complex single precision.  <a href="#a457a3b8acbc742628430857bf1d7a737">More...</a><br /></td></tr>
<tr class="separator:a457a3b8acbc742628430857bf1d7a737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30316cffc9ee799984c3d22a3b673296"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30316cffc9ee799984c3d22a3b673296"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmprint</b> (const int fold, const float *manX, const int incmanX, const float *carX, const int inccarX)</td></tr>
<tr class="separator:a30316cffc9ee799984c3d22a3b673296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4221e97b4cb792de75302ebbbd0678f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a4221e97b4cb792de75302ebbbd0678f1">diprint</a> (const int fold, const <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X)</td></tr>
<tr class="memdesc:a4221e97b4cb792de75302ebbbd0678f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print indexed double precision.  <a href="#a4221e97b4cb792de75302ebbbd0678f1">More...</a><br /></td></tr>
<tr class="separator:a4221e97b4cb792de75302ebbbd0678f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc8bb9ee44dde6027ed5dc7c8022d5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bc8bb9ee44dde6027ed5dc7c8022d5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmprint</b> (const int fold, const double *manX, const int incmanX, const double *carX, const int inccarX)</td></tr>
<tr class="separator:a6bc8bb9ee44dde6027ed5dc7c8022d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50945ea80e58582ff6776869487992a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a50945ea80e58582ff6776869487992a0">siprint</a> (const int fold, const <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X)</td></tr>
<tr class="memdesc:a50945ea80e58582ff6776869487992a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print indexed single precision.  <a href="#a50945ea80e58582ff6776869487992a0">More...</a><br /></td></tr>
<tr class="separator:a50945ea80e58582ff6776869487992a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce5312c30ac34d3982d6587a3a502fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ce5312c30ac34d3982d6587a3a502fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smprint</b> (const int fold, const float *manX, const int incmanX, const float *carX, const int inccarX)</td></tr>
<tr class="separator:a6ce5312c30ac34d3982d6587a3a502fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad013648e8e554a410481bc6c41c0ee43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ad013648e8e554a410481bc6c41c0ee43">ziprint</a> (const int fold, const <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:ad013648e8e554a410481bc6c41c0ee43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print indexed complex double precision.  <a href="#ad013648e8e554a410481bc6c41c0ee43">More...</a><br /></td></tr>
<tr class="separator:ad013648e8e554a410481bc6c41c0ee43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41b87e99c5702391fa875ccbb9086a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af41b87e99c5702391fa875ccbb9086a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmprint</b> (const int fold, const double *manX, const int incmanX, const double *carX, const int inccarX)</td></tr>
<tr class="separator:af41b87e99c5702391fa875ccbb9086a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133037274a386e09f5199f11b11a0b23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a133037274a386e09f5199f11b11a0b23">didiset</a> (const int fold, const <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X, <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a133037274a386e09f5199f11b11a0b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed double precision (Y = X)  <a href="#a133037274a386e09f5199f11b11a0b23">More...</a><br /></td></tr>
<tr class="separator:a133037274a386e09f5199f11b11a0b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bd9336afa443f54b5eeb0918d4dbd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82bd9336afa443f54b5eeb0918d4dbd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmdmset</b> (const int fold, const double *manX, const int incmanX, const double *carX, const int inccarX, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:a82bd9336afa443f54b5eeb0918d4dbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52ba60e5f2561aecc0c6289f4a609ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ad52ba60e5f2561aecc0c6289f4a609ef">ziziset</a> (const int fold, const <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:ad52ba60e5f2561aecc0c6289f4a609ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed complex double precision (Y = X)  <a href="#ad52ba60e5f2561aecc0c6289f4a609ef">More...</a><br /></td></tr>
<tr class="separator:ad52ba60e5f2561aecc0c6289f4a609ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d278f8b25f7a19aaeb5a1496d98b52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32d278f8b25f7a19aaeb5a1496d98b52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmzmset</b> (const int fold, const double *manX, const int incmanX, const double *carX, const int inccarX, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:a32d278f8b25f7a19aaeb5a1496d98b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99457e1bd46d7a7c6b2728582e90b387"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a99457e1bd46d7a7c6b2728582e90b387">zidiset</a> (const int fold, const <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a99457e1bd46d7a7c6b2728582e90b387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed complex double precision to indexed double precision (Y = X)  <a href="#a99457e1bd46d7a7c6b2728582e90b387">More...</a><br /></td></tr>
<tr class="separator:a99457e1bd46d7a7c6b2728582e90b387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ded5b930af33024bcfee95d60adc5a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ded5b930af33024bcfee95d60adc5a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmdmset</b> (const int fold, const double *manX, const int incmanX, const double *carX, const int inccarX, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:a3ded5b930af33024bcfee95d60adc5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dae3550fd21843d03183147ba6729f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a05dae3550fd21843d03183147ba6729f">sisiset</a> (const int fold, const <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X, <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a05dae3550fd21843d03183147ba6729f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed single precision (Y = X)  <a href="#a05dae3550fd21843d03183147ba6729f">More...</a><br /></td></tr>
<tr class="separator:a05dae3550fd21843d03183147ba6729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555d0fe384a25491b8c611eae03b9296"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a555d0fe384a25491b8c611eae03b9296"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smsmset</b> (const int fold, const float *manX, const int incmanX, const float *carX, const int inccarX, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:a555d0fe384a25491b8c611eae03b9296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53af4efd6a9cc89b12b6d8698c61a8ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a53af4efd6a9cc89b12b6d8698c61a8ac">ciciset</a> (const int fold, const <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a53af4efd6a9cc89b12b6d8698c61a8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed complex single precision (Y = X)  <a href="#a53af4efd6a9cc89b12b6d8698c61a8ac">More...</a><br /></td></tr>
<tr class="separator:a53af4efd6a9cc89b12b6d8698c61a8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407b415b6aaf69eb14716b0c2f9b8bfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a407b415b6aaf69eb14716b0c2f9b8bfc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmcmset</b> (const int fold, const float *manX, const int incmanX, const float *carX, const int inccarX, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:a407b415b6aaf69eb14716b0c2f9b8bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa3905eb53e2878662eb49ba988dfa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#abfa3905eb53e2878662eb49ba988dfa1">cisiset</a> (const int fold, const <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:abfa3905eb53e2878662eb49ba988dfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed complex single precision to indexed single precision (Y = X)  <a href="#abfa3905eb53e2878662eb49ba988dfa1">More...</a><br /></td></tr>
<tr class="separator:abfa3905eb53e2878662eb49ba988dfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37631d19e19b2ac13dbea2c853115bbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37631d19e19b2ac13dbea2c853115bbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmsmset</b> (const int fold, const float *manX, const int incmanX, const float *carX, const int inccarX, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:a37631d19e19b2ac13dbea2c853115bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d9879b3579007beeb976dc72a1db90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a16d9879b3579007beeb976dc72a1db90">disetzero</a> (const int fold, <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X)</td></tr>
<tr class="memdesc:a16d9879b3579007beeb976dc72a1db90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed double precision to 0 (X = 0)  <a href="#a16d9879b3579007beeb976dc72a1db90">More...</a><br /></td></tr>
<tr class="separator:a16d9879b3579007beeb976dc72a1db90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5f1a0cb2d91fb0c2b4e6e3cedced57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b5f1a0cb2d91fb0c2b4e6e3cedced57"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmsetzero</b> (const int fold, double *manX, const int incmanX, double *carX, const int inccarX)</td></tr>
<tr class="separator:a5b5f1a0cb2d91fb0c2b4e6e3cedced57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d113381e316fe5fbf6349276430d11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#aa9d113381e316fe5fbf6349276430d11">zisetzero</a> (const int fold, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:aa9d113381e316fe5fbf6349276430d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed double precision to 0 (X = 0)  <a href="#aa9d113381e316fe5fbf6349276430d11">More...</a><br /></td></tr>
<tr class="separator:aa9d113381e316fe5fbf6349276430d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22aec05a945b7f5f37e50c6a7f741172"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22aec05a945b7f5f37e50c6a7f741172"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmsetzero</b> (const int fold, double *manX, const int incmanX, double *carX, const int inccarX)</td></tr>
<tr class="separator:a22aec05a945b7f5f37e50c6a7f741172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14174d6afc61231bcce1ebbefb714fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#af14174d6afc61231bcce1ebbefb714fc">sisetzero</a> (const int fold, <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X)</td></tr>
<tr class="memdesc:af14174d6afc61231bcce1ebbefb714fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed single precision to 0 (X = 0)  <a href="#af14174d6afc61231bcce1ebbefb714fc">More...</a><br /></td></tr>
<tr class="separator:af14174d6afc61231bcce1ebbefb714fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235ea32317b4de200dc8a44290361f7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a235ea32317b4de200dc8a44290361f7a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smsetzero</b> (const int fold, float *manX, const int incmanX, float *carX, const int inccarX)</td></tr>
<tr class="separator:a235ea32317b4de200dc8a44290361f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace97a1b74eb3d54b02f4b23628bdef00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ace97a1b74eb3d54b02f4b23628bdef00">cisetzero</a> (const int fold, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:ace97a1b74eb3d54b02f4b23628bdef00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set indexed single precision to 0 (X = 0)  <a href="#ace97a1b74eb3d54b02f4b23628bdef00">More...</a><br /></td></tr>
<tr class="separator:ace97a1b74eb3d54b02f4b23628bdef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b890650fe687738f708f08be6d5f12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8b890650fe687738f708f08be6d5f12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmsetzero</b> (const int fold, float *manX, const int incmanX, float *carX, const int inccarX)</td></tr>
<tr class="separator:ac8b890650fe687738f708f08be6d5f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5807734560bdfca08090891ffe65a59a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a5807734560bdfca08090891ffe65a59a">didiadd</a> (const int fold, const <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X, <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a5807734560bdfca08090891ffe65a59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed double precision (Y += X)  <a href="#a5807734560bdfca08090891ffe65a59a">More...</a><br /></td></tr>
<tr class="separator:a5807734560bdfca08090891ffe65a59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae31891813e20d12804dc5f45e7e5c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ae31891813e20d12804dc5f45e7e5c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmdmadd</b> (const int fold, const double *manX, const int incmanX, const double *carX, const int inccarX, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:a5ae31891813e20d12804dc5f45e7e5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58c7ffd4bebd172186baeceacb17c3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#aa58c7ffd4bebd172186baeceacb17c3d">ziziadd</a> (const int fold, const <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:aa58c7ffd4bebd172186baeceacb17c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed complex double precision (Y += X)  <a href="#aa58c7ffd4bebd172186baeceacb17c3d">More...</a><br /></td></tr>
<tr class="separator:aa58c7ffd4bebd172186baeceacb17c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95acdd2cd20476f0a1b66ae14cebe12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab95acdd2cd20476f0a1b66ae14cebe12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmzmadd</b> (const int fold, const double *manX, const int incmanX, const double *carX, const int inccarX, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:ab95acdd2cd20476f0a1b66ae14cebe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926c3c1fba021eea3aba563f461ce0ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a926c3c1fba021eea3aba563f461ce0ca">sisiadd</a> (const int fold, const <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X, <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a926c3c1fba021eea3aba563f461ce0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed single precision (Y += X)  <a href="#a926c3c1fba021eea3aba563f461ce0ca">More...</a><br /></td></tr>
<tr class="separator:a926c3c1fba021eea3aba563f461ce0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454e4a17105589230f07b8cffeb1c721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a454e4a17105589230f07b8cffeb1c721"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smsmadd</b> (const int fold, const float *manX, const int incmanX, const float *carX, const int inccarX, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:a454e4a17105589230f07b8cffeb1c721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cb8177474554fa4157136af10d7e8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a41cb8177474554fa4157136af10d7e8f">ciciadd</a> (const int fold, const <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a41cb8177474554fa4157136af10d7e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add indexed complex single precision (Y += X)  <a href="#a41cb8177474554fa4157136af10d7e8f">More...</a><br /></td></tr>
<tr class="separator:a41cb8177474554fa4157136af10d7e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a1ebb73d6951f9c7fb2b5716e274b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2a1ebb73d6951f9c7fb2b5716e274b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmcmadd</b> (const int fold, const float *manX, const int incmanX, const float *carX, const int inccarX, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:aa2a1ebb73d6951f9c7fb2b5716e274b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775ec83d9974465ef7e6bb7fcbf626ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a775ec83d9974465ef7e6bb7fcbf626ef">didadd</a> (const int fold, const double X, <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a775ec83d9974465ef7e6bb7fcbf626ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add double precision to indexed double precision (Y += X)  <a href="#a775ec83d9974465ef7e6bb7fcbf626ef">More...</a><br /></td></tr>
<tr class="separator:a775ec83d9974465ef7e6bb7fcbf626ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4a41b0b793347f1c31cb02d9ace41d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a4a41b0b793347f1c31cb02d9ace41d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmdadd</b> (const int fold, const double X, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:a9a4a41b0b793347f1c31cb02d9ace41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb301ae0f0905f8d1011b024d9f838c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a9cb301ae0f0905f8d1011b024d9f838c">zizadd</a> (const int fold, const void *X, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a9cb301ae0f0905f8d1011b024d9f838c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex double precision to indexed complex double precision (Y += X)  <a href="#a9cb301ae0f0905f8d1011b024d9f838c">More...</a><br /></td></tr>
<tr class="separator:a9cb301ae0f0905f8d1011b024d9f838c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae3ca2fb7fa8b42740b6f5c69862700"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ae3ca2fb7fa8b42740b6f5c69862700"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmzadd</b> (const int fold, const void *X, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:a4ae3ca2fb7fa8b42740b6f5c69862700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bac4331fdcff5f8276c0db7d04d691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a03bac4331fdcff5f8276c0db7d04d691">sisadd</a> (const int fold, const float X, <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a03bac4331fdcff5f8276c0db7d04d691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add single precision to indexed single precision (Y += X)  <a href="#a03bac4331fdcff5f8276c0db7d04d691">More...</a><br /></td></tr>
<tr class="separator:a03bac4331fdcff5f8276c0db7d04d691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a223061db0f855605765a6ddb2e1d35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a223061db0f855605765a6ddb2e1d35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smsadd</b> (const int fold, const float X, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:a9a223061db0f855605765a6ddb2e1d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e44e3ceecd38a58457fe22fa995ba0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a6e44e3ceecd38a58457fe22fa995ba0e">cicadd</a> (const int fold, const void *X, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a6e44e3ceecd38a58457fe22fa995ba0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex single precision to indexed complex single precision (Y += X)  <a href="#a6e44e3ceecd38a58457fe22fa995ba0e">More...</a><br /></td></tr>
<tr class="separator:a6e44e3ceecd38a58457fe22fa995ba0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d594e45e8a5a143c71edb9f4732097f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d594e45e8a5a143c71edb9f4732097f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmcadd</b> (const int fold, const void *X, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:a0d594e45e8a5a143c71edb9f4732097f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9250e4067ee9895399a501eeb9bd47d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#af9250e4067ee9895399a501eeb9bd47d">didupdate</a> (const int fold, const double X, <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:af9250e4067ee9895399a501eeb9bd47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed double precision with double precision (X -&gt; Y)  <a href="#af9250e4067ee9895399a501eeb9bd47d">More...</a><br /></td></tr>
<tr class="separator:af9250e4067ee9895399a501eeb9bd47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27393224f44df4f05097db9a47c335db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27393224f44df4f05097db9a47c335db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmdupdate</b> (const int fold, const double X, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:a27393224f44df4f05097db9a47c335db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac767d68e07546fe17cdbf2c09e8339fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ac767d68e07546fe17cdbf2c09e8339fe">zizupdate</a> (const int fold, const void *X, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:ac767d68e07546fe17cdbf2c09e8339fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed complex double precision with complex double precision (X -&gt; Y)  <a href="#ac767d68e07546fe17cdbf2c09e8339fe">More...</a><br /></td></tr>
<tr class="separator:ac767d68e07546fe17cdbf2c09e8339fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b61167a5830c78b7eb042ce2d27b828"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b61167a5830c78b7eb042ce2d27b828"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmzupdate</b> (const int fold, const void *X, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:a5b61167a5830c78b7eb042ce2d27b828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42992767849052350dbaac437ad5cd76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a42992767849052350dbaac437ad5cd76">zidupdate</a> (const int fold, const double X, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a42992767849052350dbaac437ad5cd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed complex double precision with double precision (X -&gt; Y)  <a href="#a42992767849052350dbaac437ad5cd76">More...</a><br /></td></tr>
<tr class="separator:a42992767849052350dbaac437ad5cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd2a34db68ef6917ef7c60421b6804f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fd2a34db68ef6917ef7c60421b6804f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmdupdate</b> (const int fold, const double X, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:a7fd2a34db68ef6917ef7c60421b6804f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dca4497086fce1c23924e007770e58e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a5dca4497086fce1c23924e007770e58e">sisupdate</a> (const int fold, const float X, <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a5dca4497086fce1c23924e007770e58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed single precision with single precision (X -&gt; Y)  <a href="#a5dca4497086fce1c23924e007770e58e">More...</a><br /></td></tr>
<tr class="separator:a5dca4497086fce1c23924e007770e58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c275573b3a7349dcab23b22c45ba560"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c275573b3a7349dcab23b22c45ba560"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smsupdate</b> (const int fold, const float X, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:a5c275573b3a7349dcab23b22c45ba560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c8f43c75ef9038802f2c03c84acb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a318c8f43c75ef9038802f2c03c84acb8">cicupdate</a> (const int fold, const void *X, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a318c8f43c75ef9038802f2c03c84acb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed complex single precision with complex single precision (X -&gt; Y)  <a href="#a318c8f43c75ef9038802f2c03c84acb8">More...</a><br /></td></tr>
<tr class="separator:a318c8f43c75ef9038802f2c03c84acb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa82f8dd6829068eace067bcde7ce91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfa82f8dd6829068eace067bcde7ce91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmcupdate</b> (const int fold, const void *X, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:abfa82f8dd6829068eace067bcde7ce91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338b3963ae5999b9c5b17e31b52adc08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a338b3963ae5999b9c5b17e31b52adc08">cisupdate</a> (const int fold, const float X, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a338b3963ae5999b9c5b17e31b52adc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indexed complex single precision with single precision (X -&gt; Y)  <a href="#a338b3963ae5999b9c5b17e31b52adc08">More...</a><br /></td></tr>
<tr class="separator:a338b3963ae5999b9c5b17e31b52adc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e0f65393da489451a298916437c1fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47e0f65393da489451a298916437c1fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmsupdate</b> (const int fold, const float X, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:a47e0f65393da489451a298916437c1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d461761d4872fd62cef198f9d09f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ae6d461761d4872fd62cef198f9d09f30">diddeposit</a> (const int fold, const double X, <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:ae6d461761d4872fd62cef198f9d09f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add double precision to suitably indexed indexed double precision (Y += X)  <a href="#ae6d461761d4872fd62cef198f9d09f30">More...</a><br /></td></tr>
<tr class="separator:ae6d461761d4872fd62cef198f9d09f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b11c0be2d4e6e6a72995aa8a597791"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0b11c0be2d4e6e6a72995aa8a597791"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmddeposit</b> (const int fold, const double X, double *manY, const int incmanY)</td></tr>
<tr class="separator:ac0b11c0be2d4e6e6a72995aa8a597791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab429773530f804ccfb6a4f72d9c265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a7ab429773530f804ccfb6a4f72d9c265">zizdeposit</a> (const int fold, const void *X, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a7ab429773530f804ccfb6a4f72d9c265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex double precision to suitably indexed manually specified indexed complex double precision (Y += X)  <a href="#a7ab429773530f804ccfb6a4f72d9c265">More...</a><br /></td></tr>
<tr class="separator:a7ab429773530f804ccfb6a4f72d9c265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2940a839ae0d96715ecc271fcb62ffaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2940a839ae0d96715ecc271fcb62ffaf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmzdeposit</b> (const int fold, const void *X, double *manY, const int incmanY)</td></tr>
<tr class="separator:a2940a839ae0d96715ecc271fcb62ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81218cfb2e0264eab021f2cb0567b602"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a81218cfb2e0264eab021f2cb0567b602">sisdeposit</a> (const int fold, const float X, <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a81218cfb2e0264eab021f2cb0567b602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add single precision to suitably indexed indexed single precision (Y += X)  <a href="#a81218cfb2e0264eab021f2cb0567b602">More...</a><br /></td></tr>
<tr class="separator:a81218cfb2e0264eab021f2cb0567b602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d0bc10c4194963a5a5ee1f34168c34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6d0bc10c4194963a5a5ee1f34168c34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smsdeposit</b> (const int fold, const float X, float *manY, const int incmanY)</td></tr>
<tr class="separator:ab6d0bc10c4194963a5a5ee1f34168c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865f4f1a7e2637d7d4f5206f1ad386fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a865f4f1a7e2637d7d4f5206f1ad386fd">cicdeposit</a> (const int fold, const void *X, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a865f4f1a7e2637d7d4f5206f1ad386fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add complex single precision to suitably indexed manually specified indexed complex single precision (Y += X)  <a href="#a865f4f1a7e2637d7d4f5206f1ad386fd">More...</a><br /></td></tr>
<tr class="separator:a865f4f1a7e2637d7d4f5206f1ad386fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e8d8b4fc7cb6a4871049fce8a48961"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6e8d8b4fc7cb6a4871049fce8a48961"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmcdeposit</b> (const int fold, const void *X, float *manY, const int incmanY)</td></tr>
<tr class="separator:ae6e8d8b4fc7cb6a4871049fce8a48961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ac43d882b1ab2f971da51997f29764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a25ac43d882b1ab2f971da51997f29764">direnorm</a> (const int fold, <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X)</td></tr>
<tr class="memdesc:a25ac43d882b1ab2f971da51997f29764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize indexed double precision.  <a href="#a25ac43d882b1ab2f971da51997f29764">More...</a><br /></td></tr>
<tr class="separator:a25ac43d882b1ab2f971da51997f29764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad611cd0be6548e47dcf3d7b55a7f758d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad611cd0be6548e47dcf3d7b55a7f758d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmrenorm</b> (const int fold, double *manX, const int incmanX, double *carX, const int inccarX)</td></tr>
<tr class="separator:ad611cd0be6548e47dcf3d7b55a7f758d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e814df8f4d69e39953e8600ab785d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#aa6e814df8f4d69e39953e8600ab785d6">zirenorm</a> (const int fold, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:aa6e814df8f4d69e39953e8600ab785d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize indexed complex double precision.  <a href="#aa6e814df8f4d69e39953e8600ab785d6">More...</a><br /></td></tr>
<tr class="separator:aa6e814df8f4d69e39953e8600ab785d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb34fb00793873a9b8da263e149abe22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb34fb00793873a9b8da263e149abe22"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmrenorm</b> (const int fold, double *manX, const int incmanX, double *carX, const int inccarX)</td></tr>
<tr class="separator:adb34fb00793873a9b8da263e149abe22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99e0a55b17693e473b39bcb71df0f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ac99e0a55b17693e473b39bcb71df0f4a">sirenorm</a> (const int fold, <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X)</td></tr>
<tr class="memdesc:ac99e0a55b17693e473b39bcb71df0f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize indexed single precision.  <a href="#ac99e0a55b17693e473b39bcb71df0f4a">More...</a><br /></td></tr>
<tr class="separator:ac99e0a55b17693e473b39bcb71df0f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ddfd5f445cbf3df35962e35dc1d126"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2ddfd5f445cbf3df35962e35dc1d126"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smrenorm</b> (const int fold, float *manX, const int incmanX, float *carX, const int inccarX)</td></tr>
<tr class="separator:ac2ddfd5f445cbf3df35962e35dc1d126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a08f14e1b2af207daaad62d3305a4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a54a08f14e1b2af207daaad62d3305a4c">cirenorm</a> (const int fold, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:a54a08f14e1b2af207daaad62d3305a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalize indexed complex single precision.  <a href="#a54a08f14e1b2af207daaad62d3305a4c">More...</a><br /></td></tr>
<tr class="separator:a54a08f14e1b2af207daaad62d3305a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e6e02bc190521e1780fe1627015227"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15e6e02bc190521e1780fe1627015227"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmrenorm</b> (const int fold, float *manX, const int incmanX, float *carX, const int inccarX)</td></tr>
<tr class="separator:a15e6e02bc190521e1780fe1627015227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bad329ce9945e51dc70da42500b7dbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a2bad329ce9945e51dc70da42500b7dbd">didconv</a> (const int fold, const double X, <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *Y)</td></tr>
<tr class="memdesc:a2bad329ce9945e51dc70da42500b7dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert double precision to indexed double precision (X -&gt; Y)  <a href="#a2bad329ce9945e51dc70da42500b7dbd">More...</a><br /></td></tr>
<tr class="separator:a2bad329ce9945e51dc70da42500b7dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63974ddccccd1937d52fe1551e68513"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af63974ddccccd1937d52fe1551e68513"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmdconv</b> (const int fold, const double X, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:af63974ddccccd1937d52fe1551e68513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840dc2b77e19d5d1bd8dd708569440f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a840dc2b77e19d5d1bd8dd708569440f1">zizconv</a> (const int fold, const void *X, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:a840dc2b77e19d5d1bd8dd708569440f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert complex double precision to indexed complex double precision (X -&gt; Y)  <a href="#a840dc2b77e19d5d1bd8dd708569440f1">More...</a><br /></td></tr>
<tr class="separator:a840dc2b77e19d5d1bd8dd708569440f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad156481683814163676331175361bba5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad156481683814163676331175361bba5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmzconv</b> (const int fold, const void *X, double *manY, const int incmanY, double *carY, const int inccarY)</td></tr>
<tr class="separator:ad156481683814163676331175361bba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c618f3b2c05170c714f5661f2d1cea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a0c618f3b2c05170c714f5661f2d1cea7">sisconv</a> (const int fold, const float X, <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *Y)</td></tr>
<tr class="memdesc:a0c618f3b2c05170c714f5661f2d1cea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert single precision to indexed single precision (X -&gt; Y)  <a href="#a0c618f3b2c05170c714f5661f2d1cea7">More...</a><br /></td></tr>
<tr class="separator:a0c618f3b2c05170c714f5661f2d1cea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8599ccc108f33808a9caa308c82c8b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8599ccc108f33808a9caa308c82c8b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smsconv</b> (const int fold, const float X, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:ae8599ccc108f33808a9caa308c82c8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab926dd0f349150d4a655a7d1b9b2ef4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ab926dd0f349150d4a655a7d1b9b2ef4f">cicconv</a> (const int fold, const void *X, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *Y)</td></tr>
<tr class="memdesc:ab926dd0f349150d4a655a7d1b9b2ef4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert complex single precision to indexed complex single precision (X -&gt; Y)  <a href="#ab926dd0f349150d4a655a7d1b9b2ef4f">More...</a><br /></td></tr>
<tr class="separator:ab926dd0f349150d4a655a7d1b9b2ef4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a49231a8c0dde7ade321da7064dda3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a49231a8c0dde7ade321da7064dda3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmcconv</b> (const int fold, const void *X, float *manY, const int incmanY, float *carY, const int inccarY)</td></tr>
<tr class="separator:a4a49231a8c0dde7ade321da7064dda3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107650f1e9c2f53422d6a0e4a2ae050a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a107650f1e9c2f53422d6a0e4a2ae050a">ddiconv</a> (const int fold, const <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X)</td></tr>
<tr class="memdesc:a107650f1e9c2f53422d6a0e4a2ae050a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert indexed double precision to double precision (X -&gt; Y)  <a href="#a107650f1e9c2f53422d6a0e4a2ae050a">More...</a><br /></td></tr>
<tr class="separator:a107650f1e9c2f53422d6a0e4a2ae050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfb362417dd4bcbc14d1b8eb4594a59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebfb362417dd4bcbc14d1b8eb4594a59"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>ddmconv</b> (const int fold, const double *manX, const int incmanX, const double *carX, const int inccarX)</td></tr>
<tr class="separator:aebfb362417dd4bcbc14d1b8eb4594a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60eac54f2106cbb7d5b8bb7fafc74d96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a60eac54f2106cbb7d5b8bb7fafc74d96">zziconv_sub</a> (const int fold, const <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X, void *conv)</td></tr>
<tr class="memdesc:a60eac54f2106cbb7d5b8bb7fafc74d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert indexed complex double precision to complex double precision (X -&gt; Y)  <a href="#a60eac54f2106cbb7d5b8bb7fafc74d96">More...</a><br /></td></tr>
<tr class="separator:a60eac54f2106cbb7d5b8bb7fafc74d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3667c2c97b01de5c95f7677a79f6a93f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3667c2c97b01de5c95f7677a79f6a93f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zzmconv_sub</b> (const int fold, const double *manX, const int incmanX, const double *carX, const int inccarX, void *conv)</td></tr>
<tr class="separator:a3667c2c97b01de5c95f7677a79f6a93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63c3d88a702fc74ceb9eef55f79ee7b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ad63c3d88a702fc74ceb9eef55f79ee7b">ssiconv</a> (const int fold, const <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X)</td></tr>
<tr class="memdesc:ad63c3d88a702fc74ceb9eef55f79ee7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert indexed single precision to single precision (X -&gt; Y)  <a href="#ad63c3d88a702fc74ceb9eef55f79ee7b">More...</a><br /></td></tr>
<tr class="separator:ad63c3d88a702fc74ceb9eef55f79ee7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f8a75177d5dfc7fab7ba74b6fa6560"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28f8a75177d5dfc7fab7ba74b6fa6560"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>ssmconv</b> (const int fold, const float *manX, const int incmanX, const float *carX, const int inccarX)</td></tr>
<tr class="separator:a28f8a75177d5dfc7fab7ba74b6fa6560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0b8554c4cd8869991cc7efbcfb91b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a9f0b8554c4cd8869991cc7efbcfb91b3">cciconv_sub</a> (const int fold, const <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X, void *conv)</td></tr>
<tr class="memdesc:a9f0b8554c4cd8869991cc7efbcfb91b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert indexed complex single precision to complex single precision (X -&gt; Y)  <a href="#a9f0b8554c4cd8869991cc7efbcfb91b3">More...</a><br /></td></tr>
<tr class="separator:a9f0b8554c4cd8869991cc7efbcfb91b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a39c98a91a90ddc9ef9feb6e1c84a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50a39c98a91a90ddc9ef9feb6e1c84a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ccmconv_sub</b> (const int fold, const float *manX, const int incmanX, const float *carX, const int inccarX, void *conv)</td></tr>
<tr class="separator:a50a39c98a91a90ddc9ef9feb6e1c84a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963ecd228b8948538bab0225d36148d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a963ecd228b8948538bab0225d36148d3">dinegate</a> (const int fold, <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *X)</td></tr>
<tr class="memdesc:a963ecd228b8948538bab0225d36148d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate indexed double precision (X = -X)  <a href="#a963ecd228b8948538bab0225d36148d3">More...</a><br /></td></tr>
<tr class="separator:a963ecd228b8948538bab0225d36148d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bdb9ab93e158d468c0eb284bc29173"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3bdb9ab93e158d468c0eb284bc29173"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dmnegate</b> (const int fold, double *manX, const int incmanX, double *carX, const int inccarX)</td></tr>
<tr class="separator:af3bdb9ab93e158d468c0eb284bc29173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ec3e79e8f614a18f6840ff3aca7e4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#ab8ec3e79e8f614a18f6840ff3aca7e4d">zinegate</a> (const int fold, <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:ab8ec3e79e8f614a18f6840ff3aca7e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate indexed complex double precision (X = -X)  <a href="#ab8ec3e79e8f614a18f6840ff3aca7e4d">More...</a><br /></td></tr>
<tr class="separator:ab8ec3e79e8f614a18f6840ff3aca7e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcc7dcb6585cae6921baa8b15df2b4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bcc7dcb6585cae6921baa8b15df2b4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zmnegate</b> (const int fold, double *manX, const int incmanX, double *carX, const int inccarX)</td></tr>
<tr class="separator:a4bcc7dcb6585cae6921baa8b15df2b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e35913cc75f4b9b815c41606485a056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a6e35913cc75f4b9b815c41606485a056">sinegate</a> (const int fold, <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *X)</td></tr>
<tr class="memdesc:a6e35913cc75f4b9b815c41606485a056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate indexed single precision (X = -X)  <a href="#a6e35913cc75f4b9b815c41606485a056">More...</a><br /></td></tr>
<tr class="separator:a6e35913cc75f4b9b815c41606485a056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dc3aea02ce2aff8a6bb75634991aa6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96dc3aea02ce2aff8a6bb75634991aa6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smnegate</b> (const int fold, float *manX, const int incmanX, float *carX, const int inccarX)</td></tr>
<tr class="separator:a96dc3aea02ce2aff8a6bb75634991aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ceb0fda5c942617e1e4985cda5e962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="indexed_8h.html#a73ceb0fda5c942617e1e4985cda5e962">cinegate</a> (const int fold, <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *X)</td></tr>
<tr class="memdesc:a73ceb0fda5c942617e1e4985cda5e962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate indexed complex single precision (X = -X)  <a href="#a73ceb0fda5c942617e1e4985cda5e962">More...</a><br /></td></tr>
<tr class="separator:a73ceb0fda5c942617e1e4985cda5e962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a976fab0d827327f1270083ddaf3c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5a976fab0d827327f1270083ddaf3c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmnegate</b> (const int fold, float *manX, const int incmanX, float *carX, const int inccarX)</td></tr>
<tr class="separator:af5a976fab0d827327f1270083ddaf3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6ffbb6ff8d6d5eeeb234d84166d067"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6ffbb6ff8d6d5eeeb234d84166d067"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>ufp</b> (const double X)</td></tr>
<tr class="separator:a1f6ffbb6ff8d6d5eeeb234d84166d067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef8552f015fd72b7e11e62a90e5fac7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abef8552f015fd72b7e11e62a90e5fac7"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>ufpf</b> (const float X)</td></tr>
<tr class="separator:abef8552f015fd72b7e11e62a90e5fac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="indexed_8h.html" title="indexed.h defines the indexed types and the lower level functions associated with their use...">indexed.h</a> defines the indexed types and the lower level functions associated with their use. </p>
<p>This header is modeled after cblas.h, and as such functions are prefixed with character sets describing the data types they operate upon. For example, the function <code>dfoo</code> would perform the function <code>foo</code> on <code>double</code> possibly returning a <code>double</code>.</p>
<p>If two character sets are prefixed, the first set of characters describes the output and the second the input type. For example, the function <code>dzbar</code> would perform the function <code>bar</code> on <code>double</code> <code>complex</code> and return a <code>double</code>.</p>
<p>Such character sets are listed as follows:</p><ul>
<li>d - double (<code>double</code>)</li>
<li>z - complex double (<code>*void</code>)</li>
<li>s - float (<code>float</code>)</li>
<li>c - complex float (<code>*void</code>)</li>
<li>di - indexed double (<a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a>)</li>
<li>zi - indexed complex double (<a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a>)</li>
<li>si - indexed float (<a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a>)</li>
<li>ci - indexed complex float (<a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a>)</li>
<li>dm - manually specified indexed double (<code>double</code>, <code>double</code>)</li>
<li>zm - manually specified indexed complex double (<code>double</code>, <code>double</code>)</li>
<li>sm - manually specified indexed float (<code>float</code>, <code>float</code>)</li>
<li>cm - manually specified indexed complex float (<code>float</code>, <code>float</code>)</li>
</ul>
<p>Throughout the library, complex types are specified via <code>*void</code> pointers. These routines will sometimes be suffixed by sub, to represent that a function has been made into a subroutine. This allows programmers to use whatever complex types they are already using, as long as the memory pointed to is of the form of two adjacent floating point types, the first and second representing real and imaginary components of the complex number.</p>
<p>The goal of using indexed types is to obtain either more accurate or reproducible summation of floating point numbers. Indexed types are composed of several adjacent bins...</p>
<p>The parameter <code>fold</code> describes how many bins are used in the indexed types supplied to a subroutine. The maximum value for this parameter can be set in config.h. If you are unsure of what value to use for , we recommend 3. Note that the <code>fold</code> of indexed types must be the same for all indexed types that interact with each other. Operations on more than one indexed type assume all indexed types being operated upon have the same <code>fold</code>. Note that the <code>fold</code> of an indexed type may not be changed once the type has been allocated. A common use case would be to set the value of <code>fold</code> as a global macro in your code and supply it to all indexed functions that you use. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a1f2eabe291f8e4804c5d19c036a62292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indexed complex double datatype. </p>
<p>To allocate a <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a>, call <a class="el" href="indexed_8h.html#abc21ea822f41d7111d7591135796fd74" title="indexed complex double precision allocation ">zialloc()</a></p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a> is, under the hood, an array of <code>double</code>. Therefore, if you have defined an array of <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a>, you must index it by multiplying the index into the array by the number of underlying <code>double</code> that make up the <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292" title="The indexed complex double datatype. ">double_complex_indexed</a>. This number can be obtained by a call to <a class="el" href="indexed_8h.html#a36fd7a628484330c0b728f6ee44aa4f3" title="indexed complex double precision size ">zinum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f97de021a0bed1b84317670c9abd1bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indexed double datatype. </p>
<p>To allocate a <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a>, call <a class="el" href="indexed_8h.html#a2119834f475bb83f1939af4385869325" title="indexed double precision allocation ">dialloc()</a></p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a> is, under the hood, an array of <code>double</code>. Therefore, if you have defined an array of <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a>, you must index it by multiplying the index into the array by the number of underlying <code>double</code> that make up the <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb" title="The indexed double datatype. ">double_indexed</a>. This number can be obtained by a call to <a class="el" href="indexed_8h.html#a60cdde42c1bdaa686436b3d6221a9d48" title="indexed double precision size ">dinum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a87fb6b6c787120ead562dd4558003b73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indexed complex float datatype. </p>
<p>To allocate a <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a>, call <a class="el" href="indexed_8h.html#aaf1f974593d317482f36873cbd76cb33" title="indexed complex single precision allocation ">cialloc()</a></p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a> is, under the hood, an array of <code>float</code>. Therefore, if you have defined an array of <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a>, you must index it by multiplying the index into the array by the number of underlying <code>float</code> that make up the <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73" title="The indexed complex float datatype. ">float_complex_indexed</a>. This number can be obtained by a call to <a class="el" href="indexed_8h.html#ad91b8b69e0b8d9c349b990bc5f8824e1" title="indexed complex single precision size ">cinum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8c164750f0c6d25d7e5e2e15b463965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indexed float datatype. </p>
<p>To allocate a <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a>, call <a class="el" href="indexed_8h.html#a6a61430e637a195cafd3285e0c926c8c" title="indexed single precision allocation ">sialloc()</a></p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a> is, under the hood, an array of <code>float</code>. Therefore, if you have defined an array of <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a>, you must index it by multiplying the index into the array by the number of underlying <code>float</code> that make up the <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965" title="The indexed float datatype. ">float_indexed</a>. This number can be obtained by a call to <a class="el" href="indexed_8h.html#a556e669781552b914372cf21ba01bf3a" title="indexed single precision size ">sinum()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9f0b8554c4cd8869991cc7efbcfb91b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cciconv_sub </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>conv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert indexed complex single precision to complex single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">conv</td><td>scalar return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aaf1f974593d317482f36873cbd76cb33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a>* cialloc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex single precision allocation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a freshly allocated indexed type. (free with <code>free()</code>)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6e44e3ceecd38a58457fe22fa995ba0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cicadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex single precision to indexed complex single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ab926dd0f349150d4a655a7d1b9b2ef4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cicconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert complex single precision to indexed complex single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a865f4f1a7e2637d7d4f5206f1ad386fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cicdeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex single precision to suitably indexed manually specified indexed complex single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="indexed_8h.html#a318c8f43c75ef9038802f2c03c84acb8" title="Update indexed complex single precision with complex single precision (X -> Y) ">cicupdate()</a> on Y with the maximum absolute value of any elements you wish to deposit in Y, you can call this method to deposit a maximum of <a class="el" href="indexed_8h.html#ace991dae3ae98d13b2c0175469553803" title="Get indexed single precision deposit capacity. ">sicapacity()</a> elements into Y. After calling <a class="el" href="indexed_8h.html#a865f4f1a7e2637d7d4f5206f1ad386fd" title="Add complex single precision to suitably indexed manually specified indexed complex single precision ...">cicdeposit()</a> on an indexed type, you must renormalize the indexed type with <a class="el" href="indexed_8h.html#a54a08f14e1b2af207daaad62d3305a4c" title="Renormalize indexed complex single precision. ">cirenorm()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">manY</td><td>Y's mantissa vector </td></tr>
    <tr><td class="paramname">incmanY</td><td>stride within Y's mantissa vector (use every incmanY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a41cb8177474554fa4157136af10d7e8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ciciadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed complex single precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a53af4efd6a9cc89b12b6d8698c61a8ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ciciset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed complex single precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a318c8f43c75ef9038802f2c03c84acb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cicupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed complex single precision with complex single precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value of real and imaginary components less than absolute value of real and imaginary components of X respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a73ceb0fda5c942617e1e4985cda5e962"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cinegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate indexed complex single precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ad91b8b69e0b8d9c349b990bc5f8824e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cinum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex single precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in <code>float</code>) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a457a3b8acbc742628430857bf1d7a737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ciprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print indexed complex single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a54a08f14e1b2af207daaad62d3305a4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cirenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize indexed complex single precision. </p>
<p>Renormalization keeps the mantissa vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ace97a1b74eb3d54b02f4b23628bdef00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed single precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="abfa3905eb53e2878662eb49ba988dfa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisiset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed complex single precision to indexed single precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="adac7f27381307db1968c94e5a96fa7fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cisize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex single precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a338b3963ae5999b9c5b17e31b52adc08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a87fb6b6c787120ead562dd4558003b73">float_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed complex single precision with single precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac7aeed5b0b5e0faf109b69a66bb85ca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dbin </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get double precision bin corresponding to index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bin</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a107650f1e9c2f53422d6a0e4a2ae050a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ddiconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert indexed double precision to double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a2119834f475bb83f1939af4385869325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a>* dialloc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed double precision allocation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a freshly allocated indexed type. (free with <code>free()</code>)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a491f5caaab9ab24ddc5bef11ccffb519"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dibound </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indexed double precision summation error bound. </p>
<p>This is a bound on the absolute error of a summation using indexed types</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>the number of double precision floating point summands </td></tr>
    <tr><td class="paramname">X</td><td>the maximum absolute value of the summands </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error bound</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a16324a445b3515349522860502b7e9cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dicapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indexed double precision deposit capacity. </p>
<p>The number of deposits that can be performed before a renorm is necessary. This function applies also to indexed complex double precision.</p>
<dl class="section return"><dt>Returns</dt><dd>deposit capacity</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a775ec83d9974465ef7e6bb7fcbf626ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void didadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add double precision to indexed double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a2bad329ce9945e51dc70da42500b7dbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void didconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert double precision to indexed double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ae6d461761d4872fd62cef198f9d09f30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diddeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add double precision to suitably indexed indexed double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="indexed_8h.html#af9250e4067ee9895399a501eeb9bd47d" title="Update indexed double precision with double precision (X -> Y) ">didupdate()</a> on Y with the maximum absolute value of any elements you wish to deposit in Y, you can call this method to deposit a maximum of <a class="el" href="indexed_8h.html#a16324a445b3515349522860502b7e9cd" title="Get indexed double precision deposit capacity. ">dicapacity()</a> elements into Y. After calling <a class="el" href="indexed_8h.html#ae6d461761d4872fd62cef198f9d09f30" title="Add double precision to suitably indexed indexed double precision (Y += X) ">diddeposit()</a> on an indexed type, you must renormalize the indexed type with <a class="el" href="indexed_8h.html#a25ac43d882b1ab2f971da51997f29764" title="Renormalize indexed double precision. ">direnorm()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5807734560bdfca08090891ffe65a59a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void didiadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed double precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a133037274a386e09f5199f11b11a0b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void didiset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed double precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af9250e4067ee9895399a501eeb9bd47d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void didupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed double precision with double precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a84238583da9fae4e259933d230005b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dindex </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index of double precision. </p>
<p>The index of a non-indexed type is the smallest index an indexed type would need to have to sum it reproducibly. Higher indicies correspond to smaller bins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X's index</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a963ecd228b8948538bab0225d36148d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dinegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate indexed double precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a60cdde42c1bdaa686436b3d6221a9d48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dinum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed double precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in <code>double</code>) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a4221e97b4cb792de75302ebbbd0678f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print indexed double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a25ac43d882b1ab2f971da51997f29764"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void direnorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize indexed double precision. </p>
<p>Renormalization keeps the mantissa vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a16d9879b3579007beeb976dc72a1db90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed double precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ae896eef2aee8dc58532139d773e85cff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t disize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed double precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ade0895d61e99d2053525502a551aac34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int diwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indexed double precision bin width. </p>
<dl class="section return"><dt>Returns</dt><dd>bin width (in bits)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf7b5dc36d90d75b67edd66e3e77b69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sbin </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get single precision bin corresponding to index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bin (bin)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6a61430e637a195cafd3285e0c926c8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a>* sialloc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed single precision allocation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a freshly allocated indexed type. (free with <code>free()</code>)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a3dc79ca843eb563aee215f836168fa0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sibound </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indexed single precision summation error bound. </p>
<p>This is a bound on the absolute error of a summation using indexed types</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">N</td><td>the number of single precision floating point summands </td></tr>
    <tr><td class="paramname">X</td><td>the maximum absolute value of the summands </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error bound</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ace991dae3ae98d13b2c0175469553803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sicapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indexed single precision deposit capacity. </p>
<p>The number of deposits that can be performed before a renorm is necessary. This function applies also to indexed complex single precision.</p>
<dl class="section return"><dt>Returns</dt><dd>deposit capacity</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a9153c546d18df2c48409181a80034c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sindex </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index of single precision. </p>
<p>The index of a non-indexed type is the smallest index an indexed type would need to have to sum it reproducibly. Higher indicies correspond to smaller bins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X's index</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd>
<dd>
Hong Diep Nguyen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19 May 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6e35913cc75f4b9b815c41606485a056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sinegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate indexed single precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a556e669781552b914372cf21ba01bf3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sinum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed single precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in <code>float</code>) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a50945ea80e58582ff6776869487992a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void siprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print indexed single precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac99e0a55b17693e473b39bcb71df0f4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sirenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize indexed single precision. </p>
<p>Renormalization keeps the mantissa vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a03bac4331fdcff5f8276c0db7d04d691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sisadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add single precision to indexed single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a0c618f3b2c05170c714f5661f2d1cea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sisconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert single precision to indexed single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a81218cfb2e0264eab021f2cb0567b602"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sisdeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add single precision to suitably indexed indexed single precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="indexed_8h.html#a5dca4497086fce1c23924e007770e58e" title="Update indexed single precision with single precision (X -> Y) ">sisupdate()</a> on Y with the maximum absolute value of any elements you wish to deposit in Y, you can call this method to deposit a maximum of <a class="el" href="indexed_8h.html#ace991dae3ae98d13b2c0175469553803" title="Get indexed single precision deposit capacity. ">sicapacity()</a> elements into Y. After calling <a class="el" href="indexed_8h.html#a81218cfb2e0264eab021f2cb0567b602" title="Add single precision to suitably indexed indexed single precision (Y += X) ">sisdeposit()</a> on an indexed type, you must renormalize the indexed type with <a class="el" href="indexed_8h.html#ac99e0a55b17693e473b39bcb71df0f4a" title="Renormalize indexed single precision. ">sirenorm()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af14174d6afc61231bcce1ebbefb714fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sisetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed single precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a926c3c1fba021eea3aba563f461ce0ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sisiadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed single precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a05dae3550fd21843d03183147ba6729f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sisiset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed single precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5c245038720cc37de95bfa620dc7e906"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sisize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed single precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a5dca4497086fce1c23924e007770e58e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sisupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed single precision with single precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a30e73f4f70b3f110697b4a06abb1c28b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int siwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get indexed single precision bin width. </p>
<dl class="section return"><dt>Returns</dt><dd>bin width (in bits)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ad63c3d88a702fc74ceb9eef55f79ee7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ssiconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#ad8c164750f0c6d25d7e5e2e15b463965">float_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert indexed single precision to single precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar Y</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="abc21ea822f41d7111d7591135796fd74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a>* zialloc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex double precision allocation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a freshly allocated indexed type. (free with <code>free()</code>)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a99457e1bd46d7a7c6b2728582e90b387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zidiset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a4f97de021a0bed1b84317670c9abd1bb">double_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed complex double precision to indexed double precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a42992767849052350dbaac437ad5cd76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zidupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed complex double precision with double precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value less than X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ab8ec3e79e8f614a18f6840ff3aca7e4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zinegate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate indexed complex double precision (X = -X) </p>
<p>Performs the operation X = -X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a36fd7a628484330c0b728f6ee44aa4f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zinum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex double precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in <code>double</code>) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ad013648e8e554a410481bc6c41c0ee43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ziprint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print indexed complex double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aa6e814df8f4d69e39953e8600ab785d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zirenorm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renormalize indexed complex double precision. </p>
<p>Renormalization keeps the mantissa vector within the necessary bins by shifting over to the carry vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aa9d113381e316fe5fbf6349276430d11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zisetzero </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed double precision to 0 (X = 0) </p>
<p>Performs the operation X = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a92cccb9dc997e33b361b46be3e8aae98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t zisize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indexed complex double precision size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the indexed type</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a9cb301ae0f0905f8d1011b024d9f838c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zizadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex double precision to indexed complex double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a840dc2b77e19d5d1bd8dd708569440f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zizconv </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert complex double precision to indexed complex double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a7ab429773530f804ccfb6a4f72d9c265"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zizdeposit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add complex double precision to suitably indexed manually specified indexed complex double precision (Y += X) </p>
<p>Performs the operation Y += X on an indexed type Y where the index of Y is larger than the index of X</p>
<dl class="section note"><dt>Note</dt><dd>This routine was provided as a means of allowing the you to optimize your code. After you have called <a class="el" href="indexed_8h.html#ac767d68e07546fe17cdbf2c09e8339fe" title="Update indexed complex double precision with complex double precision (X -> Y) ">zizupdate()</a> on Y with the maximum absolute value of any elements you wish to deposit in Y, you can call this method to deposit a maximum of <a class="el" href="indexed_8h.html#a16324a445b3515349522860502b7e9cd" title="Get indexed double precision deposit capacity. ">dicapacity()</a> elements into Y. After calling <a class="el" href="indexed_8h.html#a7ab429773530f804ccfb6a4f72d9c265" title="Add complex double precision to suitably indexed manually specified indexed complex double precision ...">zizdeposit()</a> on an indexed type, you must renormalize the indexed type with <a class="el" href="indexed_8h.html#aa6e814df8f4d69e39953e8600ab785d6" title="Renormalize indexed complex double precision. ">zirenorm()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">manY</td><td>Y's mantissa vector </td></tr>
    <tr><td class="paramname">incmanY</td><td>stride within Y's mantissa vector (use every incmanY'th element)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aa58c7ffd4bebd172186baeceacb17c3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ziziadd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add indexed complex double precision (Y += X) </p>
<p>Performs the operation Y += X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ad52ba60e5f2561aecc0c6289f4a609ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ziziset </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set indexed complex double precision (Y = X) </p>
<p>Performs the operation Y = X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac767d68e07546fe17cdbf2c09e8339fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zizupdate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update indexed complex double precision with complex double precision (X -&gt; Y) </p>
<p>This method updates Y to an index suitable for adding numbers with absolute value of real and imaginary components less than absolute value of real and imaginary components of X respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>scalar X </td></tr>
    <tr><td class="paramname">Y</td><td>indexed scalar Y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a60eac54f2106cbb7d5b8bb7fafc74d96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zziconv_sub </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="indexed_8h.html#a1f2eabe291f8e4804c5d19c036a62292">double_complex_indexed</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>conv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert indexed complex double precision to complex double precision (X -&gt; Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>the fold of the indexed types </td></tr>
    <tr><td class="paramname">X</td><td>indexed scalar X </td></tr>
    <tr><td class="paramname">conv</td><td>scalar return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hong Diep Nguyen </dd>
<dd>
Peter Ahrens </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27 Apr 2015 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 27 2015 15:27:59 for ReproBLAS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
